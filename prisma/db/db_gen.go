// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package db

import (
	"context"
	"os"
	"testing"

	"github.com/steebchen/prisma-client-go/engine"
	"github.com/steebchen/prisma-client-go/engine/mock"
	"github.com/steebchen/prisma-client-go/runtime/builder"
	"github.com/steebchen/prisma-client-go/runtime/lifecycle"
	"github.com/steebchen/prisma-client-go/runtime/raw"
	"github.com/steebchen/prisma-client-go/runtime/transaction"
	"github.com/steebchen/prisma-client-go/runtime/types"
	rawmodels "github.com/steebchen/prisma-client-go/runtime/types/raw"

	// no-op import for go modules
	_ "github.com/iancoleman/strcase"
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"
	_ "github.com/takuoki/gocase"
	_ "golang.org/x/text/cases"
)

// ignore unused os import as it may not be needed depending on engine type
var _ = os.DevNull

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

type RawString = rawmodels.String
type RawInt = rawmodels.Int
type RawFloat = rawmodels.Float
type RawBoolean = rawmodels.Boolean
type RawDateTime = rawmodels.DateTime
type RawJSON = rawmodels.JSON
type RawBytes = rawmodels.Bytes
type RawBigInt = rawmodels.BigInt
type RawDecimal = rawmodels.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template create.gotpl ---

// Creates a single contactFormSubmissions.
func (r contactFormSubmissionsActions) CreateOne(
	_email ContactFormSubmissionsWithPrismaEmailSetParam,
	_message ContactFormSubmissionsWithPrismaMessageSetParam,

	optional ...ContactFormSubmissionsSetParam,
) contactFormSubmissionsCreateOne {
	var v contactFormSubmissionsCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "contact_form_submissions"
	v.query.Outputs = contactFormSubmissionsOutput

	var fields []builder.Field

	fields = append(fields, _email.field())
	fields = append(fields, _message.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r contactFormSubmissionsCreateOne) With(params ...ContactFormSubmissionsRelationWith) contactFormSubmissionsCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type contactFormSubmissionsCreateOne struct {
	query builder.Query
}

func (p contactFormSubmissionsCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsCreateOne) contactFormSubmissionsModel() {}

func (r contactFormSubmissionsCreateOne) Exec(ctx context.Context) (*ContactFormSubmissionsModel, error) {
	var v ContactFormSubmissionsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r contactFormSubmissionsCreateOne) Tx() contactFormSubmissionsUniqueTxResult {
	v := NewcontactFormSubmissionsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single users.
func (r usersActions) CreateOne(
	_email UsersWithPrismaEmailSetParam,
	_hashedPassword UsersWithPrismaHashedPasswordSetParam,

	optional ...UsersSetParam,
) usersCreateOne {
	var v usersCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "users"
	v.query.Outputs = usersOutput

	var fields []builder.Field

	fields = append(fields, _email.field())
	fields = append(fields, _hashedPassword.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r usersCreateOne) With(params ...UsersRelationWith) usersCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type usersCreateOne struct {
	query builder.Query
}

func (p usersCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p usersCreateOne) usersModel() {}

func (r usersCreateOne) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersCreateOne) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single invitations.
func (r invitationsActions) CreateOne(
	_email InvitationsWithPrismaEmailSetParam,
	_teams InvitationsWithPrismaTeamsSetParam,

	optional ...InvitationsSetParam,
) invitationsCreateOne {
	var v invitationsCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "invitations"
	v.query.Outputs = invitationsOutput

	var fields []builder.Field

	fields = append(fields, _email.field())
	fields = append(fields, _teams.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r invitationsCreateOne) With(params ...InvitationsRelationWith) invitationsCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type invitationsCreateOne struct {
	query builder.Query
}

func (p invitationsCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p invitationsCreateOne) invitationsModel() {}

func (r invitationsCreateOne) Exec(ctx context.Context) (*InvitationsModel, error) {
	var v InvitationsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r invitationsCreateOne) Tx() invitationsUniqueTxResult {
	v := NewinvitationsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single projects.
func (r projectsActions) CreateOne(
	_name ProjectsWithPrismaNameSetParam,

	optional ...ProjectsSetParam,
) projectsCreateOne {
	var v projectsCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "projects"
	v.query.Outputs = projectsOutput

	var fields []builder.Field

	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r projectsCreateOne) With(params ...ProjectsRelationWith) projectsCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type projectsCreateOne struct {
	query builder.Query
}

func (p projectsCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p projectsCreateOne) projectsModel() {}

func (r projectsCreateOne) Exec(ctx context.Context) (*ProjectsModel, error) {
	var v ProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r projectsCreateOne) Tx() projectsUniqueTxResult {
	v := NewprojectsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single teams.
func (r teamsActions) CreateOne(
	_name TeamsWithPrismaNameSetParam,

	optional ...TeamsSetParam,
) teamsCreateOne {
	var v teamsCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "teams"
	v.query.Outputs = teamsOutput

	var fields []builder.Field

	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r teamsCreateOne) With(params ...TeamsRelationWith) teamsCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type teamsCreateOne struct {
	query builder.Query
}

func (p teamsCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p teamsCreateOne) teamsModel() {}

func (r teamsCreateOne) Exec(ctx context.Context) (*TeamsModel, error) {
	var v TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsCreateOne) Tx() teamsUniqueTxResult {
	v := NewteamsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single teamsProjects.
func (r teamsProjectsActions) CreateOne(
	_projects TeamsProjectsWithPrismaProjectsSetParam,
	_teams TeamsProjectsWithPrismaTeamsSetParam,

	optional ...TeamsProjectsSetParam,
) teamsProjectsCreateOne {
	var v teamsProjectsCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "teams_projects"
	v.query.Outputs = teamsProjectsOutput

	var fields []builder.Field

	fields = append(fields, _projects.field())
	fields = append(fields, _teams.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r teamsProjectsCreateOne) With(params ...TeamsProjectsRelationWith) teamsProjectsCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type teamsProjectsCreateOne struct {
	query builder.Query
}

func (p teamsProjectsCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p teamsProjectsCreateOne) teamsProjectsModel() {}

func (r teamsProjectsCreateOne) Exec(ctx context.Context) (*TeamsProjectsModel, error) {
	var v TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsProjectsCreateOne) Tx() teamsProjectsUniqueTxResult {
	v := NewteamsProjectsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single teamsUsers.
func (r teamsUsersActions) CreateOne(
	_teams TeamsUsersWithPrismaTeamsSetParam,
	_users TeamsUsersWithPrismaUsersSetParam,

	optional ...TeamsUsersSetParam,
) teamsUsersCreateOne {
	var v teamsUsersCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "teams_users"
	v.query.Outputs = teamsUsersOutput

	var fields []builder.Field

	fields = append(fields, _teams.field())
	fields = append(fields, _users.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r teamsUsersCreateOne) With(params ...TeamsUsersRelationWith) teamsUsersCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type teamsUsersCreateOne struct {
	query builder.Query
}

func (p teamsUsersCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p teamsUsersCreateOne) teamsUsersModel() {}

func (r teamsUsersCreateOne) Exec(ctx context.Context) (*TeamsUsersModel, error) {
	var v TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUsersCreateOne) Tx() teamsUsersUniqueTxResult {
	v := NewteamsUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type contactFormSubmissionsToUsersFindUnique struct {
	query builder.Query
}

func (r contactFormSubmissionsToUsersFindUnique) getQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsToUsersFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsToUsersFindUnique) with()                           {}
func (r contactFormSubmissionsToUsersFindUnique) contactFormSubmissionsModel()    {}
func (r contactFormSubmissionsToUsersFindUnique) contactFormSubmissionsRelation() {}

func (r contactFormSubmissionsToUsersFindUnique) With(params ...UsersRelationWith) contactFormSubmissionsToUsersFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r contactFormSubmissionsToUsersFindUnique) Exec(ctx context.Context) (
	*ContactFormSubmissionsModel,
	error,
) {
	var v *ContactFormSubmissionsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r contactFormSubmissionsToUsersFindUnique) ExecInner(ctx context.Context) (
	*InnerContactFormSubmissions,
	error,
) {
	var v *InnerContactFormSubmissions
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r contactFormSubmissionsToUsersFindUnique) Update(params ...ContactFormSubmissionsSetParam) contactFormSubmissionsToUsersUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "contact_form_submissions"

	var v contactFormSubmissionsToUsersUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type contactFormSubmissionsToUsersUpdateUnique struct {
	query builder.Query
}

func (r contactFormSubmissionsToUsersUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsToUsersUpdateUnique) contactFormSubmissionsModel() {}

func (r contactFormSubmissionsToUsersUpdateUnique) Exec(ctx context.Context) (*ContactFormSubmissionsModel, error) {
	var v ContactFormSubmissionsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r contactFormSubmissionsToUsersUpdateUnique) Tx() contactFormSubmissionsUniqueTxResult {
	v := NewcontactFormSubmissionsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r contactFormSubmissionsToUsersFindUnique) Delete() contactFormSubmissionsToUsersDeleteUnique {
	var v contactFormSubmissionsToUsersDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "contact_form_submissions"

	return v
}

type contactFormSubmissionsToUsersDeleteUnique struct {
	query builder.Query
}

func (r contactFormSubmissionsToUsersDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p contactFormSubmissionsToUsersDeleteUnique) contactFormSubmissionsModel() {}

func (r contactFormSubmissionsToUsersDeleteUnique) Exec(ctx context.Context) (*ContactFormSubmissionsModel, error) {
	var v ContactFormSubmissionsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r contactFormSubmissionsToUsersDeleteUnique) Tx() contactFormSubmissionsUniqueTxResult {
	v := NewcontactFormSubmissionsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type contactFormSubmissionsToUsersFindFirst struct {
	query builder.Query
}

func (r contactFormSubmissionsToUsersFindFirst) getQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsToUsersFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsToUsersFindFirst) with()                           {}
func (r contactFormSubmissionsToUsersFindFirst) contactFormSubmissionsModel()    {}
func (r contactFormSubmissionsToUsersFindFirst) contactFormSubmissionsRelation() {}

func (r contactFormSubmissionsToUsersFindFirst) With(params ...UsersRelationWith) contactFormSubmissionsToUsersFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r contactFormSubmissionsToUsersFindFirst) OrderBy(params ...UsersOrderByParam) contactFormSubmissionsToUsersFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r contactFormSubmissionsToUsersFindFirst) Skip(count int) contactFormSubmissionsToUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r contactFormSubmissionsToUsersFindFirst) Take(count int) contactFormSubmissionsToUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r contactFormSubmissionsToUsersFindFirst) Cursor(cursor ContactFormSubmissionsCursorParam) contactFormSubmissionsToUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r contactFormSubmissionsToUsersFindFirst) Exec(ctx context.Context) (
	*ContactFormSubmissionsModel,
	error,
) {
	var v *ContactFormSubmissionsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r contactFormSubmissionsToUsersFindFirst) ExecInner(ctx context.Context) (
	*InnerContactFormSubmissions,
	error,
) {
	var v *InnerContactFormSubmissions
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type contactFormSubmissionsToUsersFindMany struct {
	query builder.Query
}

func (r contactFormSubmissionsToUsersFindMany) getQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsToUsersFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsToUsersFindMany) with()                           {}
func (r contactFormSubmissionsToUsersFindMany) contactFormSubmissionsModel()    {}
func (r contactFormSubmissionsToUsersFindMany) contactFormSubmissionsRelation() {}

func (r contactFormSubmissionsToUsersFindMany) With(params ...UsersRelationWith) contactFormSubmissionsToUsersFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r contactFormSubmissionsToUsersFindMany) OrderBy(params ...UsersOrderByParam) contactFormSubmissionsToUsersFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r contactFormSubmissionsToUsersFindMany) Skip(count int) contactFormSubmissionsToUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r contactFormSubmissionsToUsersFindMany) Take(count int) contactFormSubmissionsToUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r contactFormSubmissionsToUsersFindMany) Cursor(cursor ContactFormSubmissionsCursorParam) contactFormSubmissionsToUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r contactFormSubmissionsToUsersFindMany) Exec(ctx context.Context) (
	[]ContactFormSubmissionsModel,
	error,
) {
	var v []ContactFormSubmissionsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r contactFormSubmissionsToUsersFindMany) ExecInner(ctx context.Context) (
	[]InnerContactFormSubmissions,
	error,
) {
	var v []InnerContactFormSubmissions
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r contactFormSubmissionsToUsersFindMany) Update(params ...ContactFormSubmissionsSetParam) contactFormSubmissionsToUsersUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "contact_form_submissions"

	r.query.Outputs = countOutput

	var v contactFormSubmissionsToUsersUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type contactFormSubmissionsToUsersUpdateMany struct {
	query builder.Query
}

func (r contactFormSubmissionsToUsersUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsToUsersUpdateMany) contactFormSubmissionsModel() {}

func (r contactFormSubmissionsToUsersUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r contactFormSubmissionsToUsersUpdateMany) Tx() contactFormSubmissionsManyTxResult {
	v := NewcontactFormSubmissionsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r contactFormSubmissionsToUsersFindMany) Delete() contactFormSubmissionsToUsersDeleteMany {
	var v contactFormSubmissionsToUsersDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "contact_form_submissions"

	v.query.Outputs = countOutput

	return v
}

type contactFormSubmissionsToUsersDeleteMany struct {
	query builder.Query
}

func (r contactFormSubmissionsToUsersDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p contactFormSubmissionsToUsersDeleteMany) contactFormSubmissionsModel() {}

func (r contactFormSubmissionsToUsersDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r contactFormSubmissionsToUsersDeleteMany) Tx() contactFormSubmissionsManyTxResult {
	v := NewcontactFormSubmissionsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type contactFormSubmissionsFindUnique struct {
	query builder.Query
}

func (r contactFormSubmissionsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsFindUnique) with()                           {}
func (r contactFormSubmissionsFindUnique) contactFormSubmissionsModel()    {}
func (r contactFormSubmissionsFindUnique) contactFormSubmissionsRelation() {}

func (r contactFormSubmissionsActions) FindUnique(
	params ContactFormSubmissionsEqualsUniqueWhereParam,
) contactFormSubmissionsFindUnique {
	var v contactFormSubmissionsFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "contact_form_submissions"
	v.query.Outputs = contactFormSubmissionsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r contactFormSubmissionsFindUnique) With(params ...ContactFormSubmissionsRelationWith) contactFormSubmissionsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r contactFormSubmissionsFindUnique) Exec(ctx context.Context) (
	*ContactFormSubmissionsModel,
	error,
) {
	var v *ContactFormSubmissionsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r contactFormSubmissionsFindUnique) ExecInner(ctx context.Context) (
	*InnerContactFormSubmissions,
	error,
) {
	var v *InnerContactFormSubmissions
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r contactFormSubmissionsFindUnique) Update(params ...ContactFormSubmissionsSetParam) contactFormSubmissionsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "contact_form_submissions"

	var v contactFormSubmissionsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type contactFormSubmissionsUpdateUnique struct {
	query builder.Query
}

func (r contactFormSubmissionsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsUpdateUnique) contactFormSubmissionsModel() {}

func (r contactFormSubmissionsUpdateUnique) Exec(ctx context.Context) (*ContactFormSubmissionsModel, error) {
	var v ContactFormSubmissionsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r contactFormSubmissionsUpdateUnique) Tx() contactFormSubmissionsUniqueTxResult {
	v := NewcontactFormSubmissionsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r contactFormSubmissionsFindUnique) Delete() contactFormSubmissionsDeleteUnique {
	var v contactFormSubmissionsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "contact_form_submissions"

	return v
}

type contactFormSubmissionsDeleteUnique struct {
	query builder.Query
}

func (r contactFormSubmissionsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p contactFormSubmissionsDeleteUnique) contactFormSubmissionsModel() {}

func (r contactFormSubmissionsDeleteUnique) Exec(ctx context.Context) (*ContactFormSubmissionsModel, error) {
	var v ContactFormSubmissionsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r contactFormSubmissionsDeleteUnique) Tx() contactFormSubmissionsUniqueTxResult {
	v := NewcontactFormSubmissionsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type contactFormSubmissionsFindFirst struct {
	query builder.Query
}

func (r contactFormSubmissionsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsFindFirst) with()                           {}
func (r contactFormSubmissionsFindFirst) contactFormSubmissionsModel()    {}
func (r contactFormSubmissionsFindFirst) contactFormSubmissionsRelation() {}

func (r contactFormSubmissionsActions) FindFirst(
	params ...ContactFormSubmissionsWhereParam,
) contactFormSubmissionsFindFirst {
	var v contactFormSubmissionsFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "contact_form_submissions"
	v.query.Outputs = contactFormSubmissionsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r contactFormSubmissionsFindFirst) With(params ...ContactFormSubmissionsRelationWith) contactFormSubmissionsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r contactFormSubmissionsFindFirst) OrderBy(params ...ContactFormSubmissionsOrderByParam) contactFormSubmissionsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r contactFormSubmissionsFindFirst) Skip(count int) contactFormSubmissionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r contactFormSubmissionsFindFirst) Take(count int) contactFormSubmissionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r contactFormSubmissionsFindFirst) Cursor(cursor ContactFormSubmissionsCursorParam) contactFormSubmissionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r contactFormSubmissionsFindFirst) Exec(ctx context.Context) (
	*ContactFormSubmissionsModel,
	error,
) {
	var v *ContactFormSubmissionsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r contactFormSubmissionsFindFirst) ExecInner(ctx context.Context) (
	*InnerContactFormSubmissions,
	error,
) {
	var v *InnerContactFormSubmissions
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type contactFormSubmissionsFindMany struct {
	query builder.Query
}

func (r contactFormSubmissionsFindMany) getQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsFindMany) with()                           {}
func (r contactFormSubmissionsFindMany) contactFormSubmissionsModel()    {}
func (r contactFormSubmissionsFindMany) contactFormSubmissionsRelation() {}

func (r contactFormSubmissionsActions) FindMany(
	params ...ContactFormSubmissionsWhereParam,
) contactFormSubmissionsFindMany {
	var v contactFormSubmissionsFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "contact_form_submissions"
	v.query.Outputs = contactFormSubmissionsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r contactFormSubmissionsFindMany) With(params ...ContactFormSubmissionsRelationWith) contactFormSubmissionsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r contactFormSubmissionsFindMany) OrderBy(params ...ContactFormSubmissionsOrderByParam) contactFormSubmissionsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r contactFormSubmissionsFindMany) Skip(count int) contactFormSubmissionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r contactFormSubmissionsFindMany) Take(count int) contactFormSubmissionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r contactFormSubmissionsFindMany) Cursor(cursor ContactFormSubmissionsCursorParam) contactFormSubmissionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r contactFormSubmissionsFindMany) Exec(ctx context.Context) (
	[]ContactFormSubmissionsModel,
	error,
) {
	var v []ContactFormSubmissionsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r contactFormSubmissionsFindMany) ExecInner(ctx context.Context) (
	[]InnerContactFormSubmissions,
	error,
) {
	var v []InnerContactFormSubmissions
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r contactFormSubmissionsFindMany) Update(params ...ContactFormSubmissionsSetParam) contactFormSubmissionsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "contact_form_submissions"

	r.query.Outputs = countOutput

	var v contactFormSubmissionsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type contactFormSubmissionsUpdateMany struct {
	query builder.Query
}

func (r contactFormSubmissionsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsUpdateMany) contactFormSubmissionsModel() {}

func (r contactFormSubmissionsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r contactFormSubmissionsUpdateMany) Tx() contactFormSubmissionsManyTxResult {
	v := NewcontactFormSubmissionsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r contactFormSubmissionsFindMany) Delete() contactFormSubmissionsDeleteMany {
	var v contactFormSubmissionsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "contact_form_submissions"

	v.query.Outputs = countOutput

	return v
}

type contactFormSubmissionsDeleteMany struct {
	query builder.Query
}

func (r contactFormSubmissionsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p contactFormSubmissionsDeleteMany) contactFormSubmissionsModel() {}

func (r contactFormSubmissionsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r contactFormSubmissionsDeleteMany) Tx() contactFormSubmissionsManyTxResult {
	v := NewcontactFormSubmissionsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersToContactFormSubmissionsFindUnique struct {
	query builder.Query
}

func (r usersToContactFormSubmissionsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r usersToContactFormSubmissionsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToContactFormSubmissionsFindUnique) with()          {}
func (r usersToContactFormSubmissionsFindUnique) usersModel()    {}
func (r usersToContactFormSubmissionsFindUnique) usersRelation() {}

func (r usersToContactFormSubmissionsFindUnique) With(params ...ContactFormSubmissionsRelationWith) usersToContactFormSubmissionsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersToContactFormSubmissionsFindUnique) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersToContactFormSubmissionsFindUnique) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersToContactFormSubmissionsFindUnique) Update(params ...UsersSetParam) usersToContactFormSubmissionsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "users"

	var v usersToContactFormSubmissionsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersToContactFormSubmissionsUpdateUnique struct {
	query builder.Query
}

func (r usersToContactFormSubmissionsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToContactFormSubmissionsUpdateUnique) usersModel() {}

func (r usersToContactFormSubmissionsUpdateUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToContactFormSubmissionsUpdateUnique) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersToContactFormSubmissionsFindUnique) Delete() usersToContactFormSubmissionsDeleteUnique {
	var v usersToContactFormSubmissionsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "users"

	return v
}

type usersToContactFormSubmissionsDeleteUnique struct {
	query builder.Query
}

func (r usersToContactFormSubmissionsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p usersToContactFormSubmissionsDeleteUnique) usersModel() {}

func (r usersToContactFormSubmissionsDeleteUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToContactFormSubmissionsDeleteUnique) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersToContactFormSubmissionsFindFirst struct {
	query builder.Query
}

func (r usersToContactFormSubmissionsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r usersToContactFormSubmissionsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToContactFormSubmissionsFindFirst) with()          {}
func (r usersToContactFormSubmissionsFindFirst) usersModel()    {}
func (r usersToContactFormSubmissionsFindFirst) usersRelation() {}

func (r usersToContactFormSubmissionsFindFirst) With(params ...ContactFormSubmissionsRelationWith) usersToContactFormSubmissionsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersToContactFormSubmissionsFindFirst) OrderBy(params ...ContactFormSubmissionsOrderByParam) usersToContactFormSubmissionsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usersToContactFormSubmissionsFindFirst) Skip(count int) usersToContactFormSubmissionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersToContactFormSubmissionsFindFirst) Take(count int) usersToContactFormSubmissionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersToContactFormSubmissionsFindFirst) Cursor(cursor UsersCursorParam) usersToContactFormSubmissionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersToContactFormSubmissionsFindFirst) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersToContactFormSubmissionsFindFirst) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type usersToContactFormSubmissionsFindMany struct {
	query builder.Query
}

func (r usersToContactFormSubmissionsFindMany) getQuery() builder.Query {
	return r.query
}

func (r usersToContactFormSubmissionsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToContactFormSubmissionsFindMany) with()          {}
func (r usersToContactFormSubmissionsFindMany) usersModel()    {}
func (r usersToContactFormSubmissionsFindMany) usersRelation() {}

func (r usersToContactFormSubmissionsFindMany) With(params ...ContactFormSubmissionsRelationWith) usersToContactFormSubmissionsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersToContactFormSubmissionsFindMany) OrderBy(params ...ContactFormSubmissionsOrderByParam) usersToContactFormSubmissionsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usersToContactFormSubmissionsFindMany) Skip(count int) usersToContactFormSubmissionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersToContactFormSubmissionsFindMany) Take(count int) usersToContactFormSubmissionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersToContactFormSubmissionsFindMany) Cursor(cursor UsersCursorParam) usersToContactFormSubmissionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersToContactFormSubmissionsFindMany) Exec(ctx context.Context) (
	[]UsersModel,
	error,
) {
	var v []UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersToContactFormSubmissionsFindMany) ExecInner(ctx context.Context) (
	[]InnerUsers,
	error,
) {
	var v []InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersToContactFormSubmissionsFindMany) Update(params ...UsersSetParam) usersToContactFormSubmissionsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "users"

	r.query.Outputs = countOutput

	var v usersToContactFormSubmissionsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersToContactFormSubmissionsUpdateMany struct {
	query builder.Query
}

func (r usersToContactFormSubmissionsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToContactFormSubmissionsUpdateMany) usersModel() {}

func (r usersToContactFormSubmissionsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToContactFormSubmissionsUpdateMany) Tx() usersManyTxResult {
	v := NewusersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersToContactFormSubmissionsFindMany) Delete() usersToContactFormSubmissionsDeleteMany {
	var v usersToContactFormSubmissionsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "users"

	v.query.Outputs = countOutput

	return v
}

type usersToContactFormSubmissionsDeleteMany struct {
	query builder.Query
}

func (r usersToContactFormSubmissionsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p usersToContactFormSubmissionsDeleteMany) usersModel() {}

func (r usersToContactFormSubmissionsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToContactFormSubmissionsDeleteMany) Tx() usersManyTxResult {
	v := NewusersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersToTeamsUsersFindUnique struct {
	query builder.Query
}

func (r usersToTeamsUsersFindUnique) getQuery() builder.Query {
	return r.query
}

func (r usersToTeamsUsersFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToTeamsUsersFindUnique) with()          {}
func (r usersToTeamsUsersFindUnique) usersModel()    {}
func (r usersToTeamsUsersFindUnique) usersRelation() {}

func (r usersToTeamsUsersFindUnique) With(params ...TeamsUsersRelationWith) usersToTeamsUsersFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersToTeamsUsersFindUnique) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersToTeamsUsersFindUnique) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersToTeamsUsersFindUnique) Update(params ...UsersSetParam) usersToTeamsUsersUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "users"

	var v usersToTeamsUsersUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersToTeamsUsersUpdateUnique struct {
	query builder.Query
}

func (r usersToTeamsUsersUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToTeamsUsersUpdateUnique) usersModel() {}

func (r usersToTeamsUsersUpdateUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToTeamsUsersUpdateUnique) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersToTeamsUsersFindUnique) Delete() usersToTeamsUsersDeleteUnique {
	var v usersToTeamsUsersDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "users"

	return v
}

type usersToTeamsUsersDeleteUnique struct {
	query builder.Query
}

func (r usersToTeamsUsersDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p usersToTeamsUsersDeleteUnique) usersModel() {}

func (r usersToTeamsUsersDeleteUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToTeamsUsersDeleteUnique) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersToTeamsUsersFindFirst struct {
	query builder.Query
}

func (r usersToTeamsUsersFindFirst) getQuery() builder.Query {
	return r.query
}

func (r usersToTeamsUsersFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToTeamsUsersFindFirst) with()          {}
func (r usersToTeamsUsersFindFirst) usersModel()    {}
func (r usersToTeamsUsersFindFirst) usersRelation() {}

func (r usersToTeamsUsersFindFirst) With(params ...TeamsUsersRelationWith) usersToTeamsUsersFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersToTeamsUsersFindFirst) OrderBy(params ...TeamsUsersOrderByParam) usersToTeamsUsersFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usersToTeamsUsersFindFirst) Skip(count int) usersToTeamsUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersToTeamsUsersFindFirst) Take(count int) usersToTeamsUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersToTeamsUsersFindFirst) Cursor(cursor UsersCursorParam) usersToTeamsUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersToTeamsUsersFindFirst) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersToTeamsUsersFindFirst) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type usersToTeamsUsersFindMany struct {
	query builder.Query
}

func (r usersToTeamsUsersFindMany) getQuery() builder.Query {
	return r.query
}

func (r usersToTeamsUsersFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToTeamsUsersFindMany) with()          {}
func (r usersToTeamsUsersFindMany) usersModel()    {}
func (r usersToTeamsUsersFindMany) usersRelation() {}

func (r usersToTeamsUsersFindMany) With(params ...TeamsUsersRelationWith) usersToTeamsUsersFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersToTeamsUsersFindMany) OrderBy(params ...TeamsUsersOrderByParam) usersToTeamsUsersFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usersToTeamsUsersFindMany) Skip(count int) usersToTeamsUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersToTeamsUsersFindMany) Take(count int) usersToTeamsUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersToTeamsUsersFindMany) Cursor(cursor UsersCursorParam) usersToTeamsUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersToTeamsUsersFindMany) Exec(ctx context.Context) (
	[]UsersModel,
	error,
) {
	var v []UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersToTeamsUsersFindMany) ExecInner(ctx context.Context) (
	[]InnerUsers,
	error,
) {
	var v []InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersToTeamsUsersFindMany) Update(params ...UsersSetParam) usersToTeamsUsersUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "users"

	r.query.Outputs = countOutput

	var v usersToTeamsUsersUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersToTeamsUsersUpdateMany struct {
	query builder.Query
}

func (r usersToTeamsUsersUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToTeamsUsersUpdateMany) usersModel() {}

func (r usersToTeamsUsersUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToTeamsUsersUpdateMany) Tx() usersManyTxResult {
	v := NewusersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersToTeamsUsersFindMany) Delete() usersToTeamsUsersDeleteMany {
	var v usersToTeamsUsersDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "users"

	v.query.Outputs = countOutput

	return v
}

type usersToTeamsUsersDeleteMany struct {
	query builder.Query
}

func (r usersToTeamsUsersDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p usersToTeamsUsersDeleteMany) usersModel() {}

func (r usersToTeamsUsersDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToTeamsUsersDeleteMany) Tx() usersManyTxResult {
	v := NewusersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersFindUnique struct {
	query builder.Query
}

func (r usersFindUnique) getQuery() builder.Query {
	return r.query
}

func (r usersFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersFindUnique) with()          {}
func (r usersFindUnique) usersModel()    {}
func (r usersFindUnique) usersRelation() {}

func (r usersActions) FindUnique(
	params UsersEqualsUniqueWhereParam,
) usersFindUnique {
	var v usersFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "users"
	v.query.Outputs = usersOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r usersFindUnique) With(params ...UsersRelationWith) usersFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersFindUnique) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersFindUnique) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersFindUnique) Update(params ...UsersSetParam) usersUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "users"

	var v usersUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersUpdateUnique struct {
	query builder.Query
}

func (r usersUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersUpdateUnique) usersModel() {}

func (r usersUpdateUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersUpdateUnique) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersFindUnique) Delete() usersDeleteUnique {
	var v usersDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "users"

	return v
}

type usersDeleteUnique struct {
	query builder.Query
}

func (r usersDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p usersDeleteUnique) usersModel() {}

func (r usersDeleteUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersDeleteUnique) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersFindFirst struct {
	query builder.Query
}

func (r usersFindFirst) getQuery() builder.Query {
	return r.query
}

func (r usersFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r usersFindFirst) with()          {}
func (r usersFindFirst) usersModel()    {}
func (r usersFindFirst) usersRelation() {}

func (r usersActions) FindFirst(
	params ...UsersWhereParam,
) usersFindFirst {
	var v usersFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "users"
	v.query.Outputs = usersOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r usersFindFirst) With(params ...UsersRelationWith) usersFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersFindFirst) OrderBy(params ...UsersOrderByParam) usersFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usersFindFirst) Skip(count int) usersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersFindFirst) Take(count int) usersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersFindFirst) Cursor(cursor UsersCursorParam) usersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersFindFirst) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersFindFirst) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type usersFindMany struct {
	query builder.Query
}

func (r usersFindMany) getQuery() builder.Query {
	return r.query
}

func (r usersFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersFindMany) with()          {}
func (r usersFindMany) usersModel()    {}
func (r usersFindMany) usersRelation() {}

func (r usersActions) FindMany(
	params ...UsersWhereParam,
) usersFindMany {
	var v usersFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "users"
	v.query.Outputs = usersOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r usersFindMany) With(params ...UsersRelationWith) usersFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersFindMany) OrderBy(params ...UsersOrderByParam) usersFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usersFindMany) Skip(count int) usersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersFindMany) Take(count int) usersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersFindMany) Cursor(cursor UsersCursorParam) usersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersFindMany) Exec(ctx context.Context) (
	[]UsersModel,
	error,
) {
	var v []UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersFindMany) ExecInner(ctx context.Context) (
	[]InnerUsers,
	error,
) {
	var v []InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersFindMany) Update(params ...UsersSetParam) usersUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "users"

	r.query.Outputs = countOutput

	var v usersUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersUpdateMany struct {
	query builder.Query
}

func (r usersUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersUpdateMany) usersModel() {}

func (r usersUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersUpdateMany) Tx() usersManyTxResult {
	v := NewusersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersFindMany) Delete() usersDeleteMany {
	var v usersDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "users"

	v.query.Outputs = countOutput

	return v
}

type usersDeleteMany struct {
	query builder.Query
}

func (r usersDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p usersDeleteMany) usersModel() {}

func (r usersDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersDeleteMany) Tx() usersManyTxResult {
	v := NewusersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type invitationsToTeamsFindUnique struct {
	query builder.Query
}

func (r invitationsToTeamsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r invitationsToTeamsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r invitationsToTeamsFindUnique) with()                {}
func (r invitationsToTeamsFindUnique) invitationsModel()    {}
func (r invitationsToTeamsFindUnique) invitationsRelation() {}

func (r invitationsToTeamsFindUnique) With(params ...TeamsRelationWith) invitationsToTeamsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r invitationsToTeamsFindUnique) Exec(ctx context.Context) (
	*InvitationsModel,
	error,
) {
	var v *InvitationsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r invitationsToTeamsFindUnique) ExecInner(ctx context.Context) (
	*InnerInvitations,
	error,
) {
	var v *InnerInvitations
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r invitationsToTeamsFindUnique) Update(params ...InvitationsSetParam) invitationsToTeamsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "invitations"

	var v invitationsToTeamsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type invitationsToTeamsUpdateUnique struct {
	query builder.Query
}

func (r invitationsToTeamsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r invitationsToTeamsUpdateUnique) invitationsModel() {}

func (r invitationsToTeamsUpdateUnique) Exec(ctx context.Context) (*InvitationsModel, error) {
	var v InvitationsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r invitationsToTeamsUpdateUnique) Tx() invitationsUniqueTxResult {
	v := NewinvitationsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r invitationsToTeamsFindUnique) Delete() invitationsToTeamsDeleteUnique {
	var v invitationsToTeamsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "invitations"

	return v
}

type invitationsToTeamsDeleteUnique struct {
	query builder.Query
}

func (r invitationsToTeamsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p invitationsToTeamsDeleteUnique) invitationsModel() {}

func (r invitationsToTeamsDeleteUnique) Exec(ctx context.Context) (*InvitationsModel, error) {
	var v InvitationsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r invitationsToTeamsDeleteUnique) Tx() invitationsUniqueTxResult {
	v := NewinvitationsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type invitationsToTeamsFindFirst struct {
	query builder.Query
}

func (r invitationsToTeamsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r invitationsToTeamsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r invitationsToTeamsFindFirst) with()                {}
func (r invitationsToTeamsFindFirst) invitationsModel()    {}
func (r invitationsToTeamsFindFirst) invitationsRelation() {}

func (r invitationsToTeamsFindFirst) With(params ...TeamsRelationWith) invitationsToTeamsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r invitationsToTeamsFindFirst) OrderBy(params ...TeamsOrderByParam) invitationsToTeamsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r invitationsToTeamsFindFirst) Skip(count int) invitationsToTeamsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r invitationsToTeamsFindFirst) Take(count int) invitationsToTeamsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r invitationsToTeamsFindFirst) Cursor(cursor InvitationsCursorParam) invitationsToTeamsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r invitationsToTeamsFindFirst) Exec(ctx context.Context) (
	*InvitationsModel,
	error,
) {
	var v *InvitationsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r invitationsToTeamsFindFirst) ExecInner(ctx context.Context) (
	*InnerInvitations,
	error,
) {
	var v *InnerInvitations
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type invitationsToTeamsFindMany struct {
	query builder.Query
}

func (r invitationsToTeamsFindMany) getQuery() builder.Query {
	return r.query
}

func (r invitationsToTeamsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r invitationsToTeamsFindMany) with()                {}
func (r invitationsToTeamsFindMany) invitationsModel()    {}
func (r invitationsToTeamsFindMany) invitationsRelation() {}

func (r invitationsToTeamsFindMany) With(params ...TeamsRelationWith) invitationsToTeamsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r invitationsToTeamsFindMany) OrderBy(params ...TeamsOrderByParam) invitationsToTeamsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r invitationsToTeamsFindMany) Skip(count int) invitationsToTeamsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r invitationsToTeamsFindMany) Take(count int) invitationsToTeamsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r invitationsToTeamsFindMany) Cursor(cursor InvitationsCursorParam) invitationsToTeamsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r invitationsToTeamsFindMany) Exec(ctx context.Context) (
	[]InvitationsModel,
	error,
) {
	var v []InvitationsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r invitationsToTeamsFindMany) ExecInner(ctx context.Context) (
	[]InnerInvitations,
	error,
) {
	var v []InnerInvitations
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r invitationsToTeamsFindMany) Update(params ...InvitationsSetParam) invitationsToTeamsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "invitations"

	r.query.Outputs = countOutput

	var v invitationsToTeamsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type invitationsToTeamsUpdateMany struct {
	query builder.Query
}

func (r invitationsToTeamsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r invitationsToTeamsUpdateMany) invitationsModel() {}

func (r invitationsToTeamsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r invitationsToTeamsUpdateMany) Tx() invitationsManyTxResult {
	v := NewinvitationsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r invitationsToTeamsFindMany) Delete() invitationsToTeamsDeleteMany {
	var v invitationsToTeamsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "invitations"

	v.query.Outputs = countOutput

	return v
}

type invitationsToTeamsDeleteMany struct {
	query builder.Query
}

func (r invitationsToTeamsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p invitationsToTeamsDeleteMany) invitationsModel() {}

func (r invitationsToTeamsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r invitationsToTeamsDeleteMany) Tx() invitationsManyTxResult {
	v := NewinvitationsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type invitationsFindUnique struct {
	query builder.Query
}

func (r invitationsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r invitationsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r invitationsFindUnique) with()                {}
func (r invitationsFindUnique) invitationsModel()    {}
func (r invitationsFindUnique) invitationsRelation() {}

func (r invitationsActions) FindUnique(
	params InvitationsEqualsUniqueWhereParam,
) invitationsFindUnique {
	var v invitationsFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "invitations"
	v.query.Outputs = invitationsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r invitationsFindUnique) With(params ...InvitationsRelationWith) invitationsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r invitationsFindUnique) Exec(ctx context.Context) (
	*InvitationsModel,
	error,
) {
	var v *InvitationsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r invitationsFindUnique) ExecInner(ctx context.Context) (
	*InnerInvitations,
	error,
) {
	var v *InnerInvitations
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r invitationsFindUnique) Update(params ...InvitationsSetParam) invitationsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "invitations"

	var v invitationsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type invitationsUpdateUnique struct {
	query builder.Query
}

func (r invitationsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r invitationsUpdateUnique) invitationsModel() {}

func (r invitationsUpdateUnique) Exec(ctx context.Context) (*InvitationsModel, error) {
	var v InvitationsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r invitationsUpdateUnique) Tx() invitationsUniqueTxResult {
	v := NewinvitationsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r invitationsFindUnique) Delete() invitationsDeleteUnique {
	var v invitationsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "invitations"

	return v
}

type invitationsDeleteUnique struct {
	query builder.Query
}

func (r invitationsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p invitationsDeleteUnique) invitationsModel() {}

func (r invitationsDeleteUnique) Exec(ctx context.Context) (*InvitationsModel, error) {
	var v InvitationsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r invitationsDeleteUnique) Tx() invitationsUniqueTxResult {
	v := NewinvitationsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type invitationsFindFirst struct {
	query builder.Query
}

func (r invitationsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r invitationsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r invitationsFindFirst) with()                {}
func (r invitationsFindFirst) invitationsModel()    {}
func (r invitationsFindFirst) invitationsRelation() {}

func (r invitationsActions) FindFirst(
	params ...InvitationsWhereParam,
) invitationsFindFirst {
	var v invitationsFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "invitations"
	v.query.Outputs = invitationsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r invitationsFindFirst) With(params ...InvitationsRelationWith) invitationsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r invitationsFindFirst) OrderBy(params ...InvitationsOrderByParam) invitationsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r invitationsFindFirst) Skip(count int) invitationsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r invitationsFindFirst) Take(count int) invitationsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r invitationsFindFirst) Cursor(cursor InvitationsCursorParam) invitationsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r invitationsFindFirst) Exec(ctx context.Context) (
	*InvitationsModel,
	error,
) {
	var v *InvitationsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r invitationsFindFirst) ExecInner(ctx context.Context) (
	*InnerInvitations,
	error,
) {
	var v *InnerInvitations
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type invitationsFindMany struct {
	query builder.Query
}

func (r invitationsFindMany) getQuery() builder.Query {
	return r.query
}

func (r invitationsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r invitationsFindMany) with()                {}
func (r invitationsFindMany) invitationsModel()    {}
func (r invitationsFindMany) invitationsRelation() {}

func (r invitationsActions) FindMany(
	params ...InvitationsWhereParam,
) invitationsFindMany {
	var v invitationsFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "invitations"
	v.query.Outputs = invitationsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r invitationsFindMany) With(params ...InvitationsRelationWith) invitationsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r invitationsFindMany) OrderBy(params ...InvitationsOrderByParam) invitationsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r invitationsFindMany) Skip(count int) invitationsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r invitationsFindMany) Take(count int) invitationsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r invitationsFindMany) Cursor(cursor InvitationsCursorParam) invitationsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r invitationsFindMany) Exec(ctx context.Context) (
	[]InvitationsModel,
	error,
) {
	var v []InvitationsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r invitationsFindMany) ExecInner(ctx context.Context) (
	[]InnerInvitations,
	error,
) {
	var v []InnerInvitations
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r invitationsFindMany) Update(params ...InvitationsSetParam) invitationsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "invitations"

	r.query.Outputs = countOutput

	var v invitationsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type invitationsUpdateMany struct {
	query builder.Query
}

func (r invitationsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r invitationsUpdateMany) invitationsModel() {}

func (r invitationsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r invitationsUpdateMany) Tx() invitationsManyTxResult {
	v := NewinvitationsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r invitationsFindMany) Delete() invitationsDeleteMany {
	var v invitationsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "invitations"

	v.query.Outputs = countOutput

	return v
}

type invitationsDeleteMany struct {
	query builder.Query
}

func (r invitationsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p invitationsDeleteMany) invitationsModel() {}

func (r invitationsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r invitationsDeleteMany) Tx() invitationsManyTxResult {
	v := NewinvitationsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type projectsToTeamsProjectsFindUnique struct {
	query builder.Query
}

func (r projectsToTeamsProjectsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r projectsToTeamsProjectsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r projectsToTeamsProjectsFindUnique) with()             {}
func (r projectsToTeamsProjectsFindUnique) projectsModel()    {}
func (r projectsToTeamsProjectsFindUnique) projectsRelation() {}

func (r projectsToTeamsProjectsFindUnique) With(params ...TeamsProjectsRelationWith) projectsToTeamsProjectsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r projectsToTeamsProjectsFindUnique) Exec(ctx context.Context) (
	*ProjectsModel,
	error,
) {
	var v *ProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r projectsToTeamsProjectsFindUnique) ExecInner(ctx context.Context) (
	*InnerProjects,
	error,
) {
	var v *InnerProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r projectsToTeamsProjectsFindUnique) Update(params ...ProjectsSetParam) projectsToTeamsProjectsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "projects"

	var v projectsToTeamsProjectsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type projectsToTeamsProjectsUpdateUnique struct {
	query builder.Query
}

func (r projectsToTeamsProjectsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r projectsToTeamsProjectsUpdateUnique) projectsModel() {}

func (r projectsToTeamsProjectsUpdateUnique) Exec(ctx context.Context) (*ProjectsModel, error) {
	var v ProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r projectsToTeamsProjectsUpdateUnique) Tx() projectsUniqueTxResult {
	v := NewprojectsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r projectsToTeamsProjectsFindUnique) Delete() projectsToTeamsProjectsDeleteUnique {
	var v projectsToTeamsProjectsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "projects"

	return v
}

type projectsToTeamsProjectsDeleteUnique struct {
	query builder.Query
}

func (r projectsToTeamsProjectsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p projectsToTeamsProjectsDeleteUnique) projectsModel() {}

func (r projectsToTeamsProjectsDeleteUnique) Exec(ctx context.Context) (*ProjectsModel, error) {
	var v ProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r projectsToTeamsProjectsDeleteUnique) Tx() projectsUniqueTxResult {
	v := NewprojectsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type projectsToTeamsProjectsFindFirst struct {
	query builder.Query
}

func (r projectsToTeamsProjectsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r projectsToTeamsProjectsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r projectsToTeamsProjectsFindFirst) with()             {}
func (r projectsToTeamsProjectsFindFirst) projectsModel()    {}
func (r projectsToTeamsProjectsFindFirst) projectsRelation() {}

func (r projectsToTeamsProjectsFindFirst) With(params ...TeamsProjectsRelationWith) projectsToTeamsProjectsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r projectsToTeamsProjectsFindFirst) OrderBy(params ...TeamsProjectsOrderByParam) projectsToTeamsProjectsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r projectsToTeamsProjectsFindFirst) Skip(count int) projectsToTeamsProjectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r projectsToTeamsProjectsFindFirst) Take(count int) projectsToTeamsProjectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r projectsToTeamsProjectsFindFirst) Cursor(cursor ProjectsCursorParam) projectsToTeamsProjectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r projectsToTeamsProjectsFindFirst) Exec(ctx context.Context) (
	*ProjectsModel,
	error,
) {
	var v *ProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r projectsToTeamsProjectsFindFirst) ExecInner(ctx context.Context) (
	*InnerProjects,
	error,
) {
	var v *InnerProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type projectsToTeamsProjectsFindMany struct {
	query builder.Query
}

func (r projectsToTeamsProjectsFindMany) getQuery() builder.Query {
	return r.query
}

func (r projectsToTeamsProjectsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r projectsToTeamsProjectsFindMany) with()             {}
func (r projectsToTeamsProjectsFindMany) projectsModel()    {}
func (r projectsToTeamsProjectsFindMany) projectsRelation() {}

func (r projectsToTeamsProjectsFindMany) With(params ...TeamsProjectsRelationWith) projectsToTeamsProjectsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r projectsToTeamsProjectsFindMany) OrderBy(params ...TeamsProjectsOrderByParam) projectsToTeamsProjectsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r projectsToTeamsProjectsFindMany) Skip(count int) projectsToTeamsProjectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r projectsToTeamsProjectsFindMany) Take(count int) projectsToTeamsProjectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r projectsToTeamsProjectsFindMany) Cursor(cursor ProjectsCursorParam) projectsToTeamsProjectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r projectsToTeamsProjectsFindMany) Exec(ctx context.Context) (
	[]ProjectsModel,
	error,
) {
	var v []ProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r projectsToTeamsProjectsFindMany) ExecInner(ctx context.Context) (
	[]InnerProjects,
	error,
) {
	var v []InnerProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r projectsToTeamsProjectsFindMany) Update(params ...ProjectsSetParam) projectsToTeamsProjectsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "projects"

	r.query.Outputs = countOutput

	var v projectsToTeamsProjectsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type projectsToTeamsProjectsUpdateMany struct {
	query builder.Query
}

func (r projectsToTeamsProjectsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r projectsToTeamsProjectsUpdateMany) projectsModel() {}

func (r projectsToTeamsProjectsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r projectsToTeamsProjectsUpdateMany) Tx() projectsManyTxResult {
	v := NewprojectsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r projectsToTeamsProjectsFindMany) Delete() projectsToTeamsProjectsDeleteMany {
	var v projectsToTeamsProjectsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "projects"

	v.query.Outputs = countOutput

	return v
}

type projectsToTeamsProjectsDeleteMany struct {
	query builder.Query
}

func (r projectsToTeamsProjectsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p projectsToTeamsProjectsDeleteMany) projectsModel() {}

func (r projectsToTeamsProjectsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r projectsToTeamsProjectsDeleteMany) Tx() projectsManyTxResult {
	v := NewprojectsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type projectsFindUnique struct {
	query builder.Query
}

func (r projectsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r projectsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r projectsFindUnique) with()             {}
func (r projectsFindUnique) projectsModel()    {}
func (r projectsFindUnique) projectsRelation() {}

func (r projectsActions) FindUnique(
	params ProjectsEqualsUniqueWhereParam,
) projectsFindUnique {
	var v projectsFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "projects"
	v.query.Outputs = projectsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r projectsFindUnique) With(params ...ProjectsRelationWith) projectsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r projectsFindUnique) Exec(ctx context.Context) (
	*ProjectsModel,
	error,
) {
	var v *ProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r projectsFindUnique) ExecInner(ctx context.Context) (
	*InnerProjects,
	error,
) {
	var v *InnerProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r projectsFindUnique) Update(params ...ProjectsSetParam) projectsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "projects"

	var v projectsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type projectsUpdateUnique struct {
	query builder.Query
}

func (r projectsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r projectsUpdateUnique) projectsModel() {}

func (r projectsUpdateUnique) Exec(ctx context.Context) (*ProjectsModel, error) {
	var v ProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r projectsUpdateUnique) Tx() projectsUniqueTxResult {
	v := NewprojectsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r projectsFindUnique) Delete() projectsDeleteUnique {
	var v projectsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "projects"

	return v
}

type projectsDeleteUnique struct {
	query builder.Query
}

func (r projectsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p projectsDeleteUnique) projectsModel() {}

func (r projectsDeleteUnique) Exec(ctx context.Context) (*ProjectsModel, error) {
	var v ProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r projectsDeleteUnique) Tx() projectsUniqueTxResult {
	v := NewprojectsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type projectsFindFirst struct {
	query builder.Query
}

func (r projectsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r projectsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r projectsFindFirst) with()             {}
func (r projectsFindFirst) projectsModel()    {}
func (r projectsFindFirst) projectsRelation() {}

func (r projectsActions) FindFirst(
	params ...ProjectsWhereParam,
) projectsFindFirst {
	var v projectsFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "projects"
	v.query.Outputs = projectsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r projectsFindFirst) With(params ...ProjectsRelationWith) projectsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r projectsFindFirst) OrderBy(params ...ProjectsOrderByParam) projectsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r projectsFindFirst) Skip(count int) projectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r projectsFindFirst) Take(count int) projectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r projectsFindFirst) Cursor(cursor ProjectsCursorParam) projectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r projectsFindFirst) Exec(ctx context.Context) (
	*ProjectsModel,
	error,
) {
	var v *ProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r projectsFindFirst) ExecInner(ctx context.Context) (
	*InnerProjects,
	error,
) {
	var v *InnerProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type projectsFindMany struct {
	query builder.Query
}

func (r projectsFindMany) getQuery() builder.Query {
	return r.query
}

func (r projectsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r projectsFindMany) with()             {}
func (r projectsFindMany) projectsModel()    {}
func (r projectsFindMany) projectsRelation() {}

func (r projectsActions) FindMany(
	params ...ProjectsWhereParam,
) projectsFindMany {
	var v projectsFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "projects"
	v.query.Outputs = projectsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r projectsFindMany) With(params ...ProjectsRelationWith) projectsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r projectsFindMany) OrderBy(params ...ProjectsOrderByParam) projectsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r projectsFindMany) Skip(count int) projectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r projectsFindMany) Take(count int) projectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r projectsFindMany) Cursor(cursor ProjectsCursorParam) projectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r projectsFindMany) Exec(ctx context.Context) (
	[]ProjectsModel,
	error,
) {
	var v []ProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r projectsFindMany) ExecInner(ctx context.Context) (
	[]InnerProjects,
	error,
) {
	var v []InnerProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r projectsFindMany) Update(params ...ProjectsSetParam) projectsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "projects"

	r.query.Outputs = countOutput

	var v projectsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type projectsUpdateMany struct {
	query builder.Query
}

func (r projectsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r projectsUpdateMany) projectsModel() {}

func (r projectsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r projectsUpdateMany) Tx() projectsManyTxResult {
	v := NewprojectsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r projectsFindMany) Delete() projectsDeleteMany {
	var v projectsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "projects"

	v.query.Outputs = countOutput

	return v
}

type projectsDeleteMany struct {
	query builder.Query
}

func (r projectsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p projectsDeleteMany) projectsModel() {}

func (r projectsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r projectsDeleteMany) Tx() projectsManyTxResult {
	v := NewprojectsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsToInvitationsFindUnique struct {
	query builder.Query
}

func (r teamsToInvitationsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r teamsToInvitationsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToInvitationsFindUnique) with()          {}
func (r teamsToInvitationsFindUnique) teamsModel()    {}
func (r teamsToInvitationsFindUnique) teamsRelation() {}

func (r teamsToInvitationsFindUnique) With(params ...InvitationsRelationWith) teamsToInvitationsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsToInvitationsFindUnique) Exec(ctx context.Context) (
	*TeamsModel,
	error,
) {
	var v *TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsToInvitationsFindUnique) ExecInner(ctx context.Context) (
	*InnerTeams,
	error,
) {
	var v *InnerTeams
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsToInvitationsFindUnique) Update(params ...TeamsSetParam) teamsToInvitationsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "teams"

	var v teamsToInvitationsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsToInvitationsUpdateUnique struct {
	query builder.Query
}

func (r teamsToInvitationsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToInvitationsUpdateUnique) teamsModel() {}

func (r teamsToInvitationsUpdateUnique) Exec(ctx context.Context) (*TeamsModel, error) {
	var v TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsToInvitationsUpdateUnique) Tx() teamsUniqueTxResult {
	v := NewteamsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsToInvitationsFindUnique) Delete() teamsToInvitationsDeleteUnique {
	var v teamsToInvitationsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "teams"

	return v
}

type teamsToInvitationsDeleteUnique struct {
	query builder.Query
}

func (r teamsToInvitationsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsToInvitationsDeleteUnique) teamsModel() {}

func (r teamsToInvitationsDeleteUnique) Exec(ctx context.Context) (*TeamsModel, error) {
	var v TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsToInvitationsDeleteUnique) Tx() teamsUniqueTxResult {
	v := NewteamsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsToInvitationsFindFirst struct {
	query builder.Query
}

func (r teamsToInvitationsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r teamsToInvitationsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToInvitationsFindFirst) with()          {}
func (r teamsToInvitationsFindFirst) teamsModel()    {}
func (r teamsToInvitationsFindFirst) teamsRelation() {}

func (r teamsToInvitationsFindFirst) With(params ...InvitationsRelationWith) teamsToInvitationsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsToInvitationsFindFirst) OrderBy(params ...InvitationsOrderByParam) teamsToInvitationsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsToInvitationsFindFirst) Skip(count int) teamsToInvitationsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsToInvitationsFindFirst) Take(count int) teamsToInvitationsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsToInvitationsFindFirst) Cursor(cursor TeamsCursorParam) teamsToInvitationsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsToInvitationsFindFirst) Exec(ctx context.Context) (
	*TeamsModel,
	error,
) {
	var v *TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsToInvitationsFindFirst) ExecInner(ctx context.Context) (
	*InnerTeams,
	error,
) {
	var v *InnerTeams
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type teamsToInvitationsFindMany struct {
	query builder.Query
}

func (r teamsToInvitationsFindMany) getQuery() builder.Query {
	return r.query
}

func (r teamsToInvitationsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToInvitationsFindMany) with()          {}
func (r teamsToInvitationsFindMany) teamsModel()    {}
func (r teamsToInvitationsFindMany) teamsRelation() {}

func (r teamsToInvitationsFindMany) With(params ...InvitationsRelationWith) teamsToInvitationsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsToInvitationsFindMany) OrderBy(params ...InvitationsOrderByParam) teamsToInvitationsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsToInvitationsFindMany) Skip(count int) teamsToInvitationsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsToInvitationsFindMany) Take(count int) teamsToInvitationsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsToInvitationsFindMany) Cursor(cursor TeamsCursorParam) teamsToInvitationsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsToInvitationsFindMany) Exec(ctx context.Context) (
	[]TeamsModel,
	error,
) {
	var v []TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsToInvitationsFindMany) ExecInner(ctx context.Context) (
	[]InnerTeams,
	error,
) {
	var v []InnerTeams
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsToInvitationsFindMany) Update(params ...TeamsSetParam) teamsToInvitationsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "teams"

	r.query.Outputs = countOutput

	var v teamsToInvitationsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsToInvitationsUpdateMany struct {
	query builder.Query
}

func (r teamsToInvitationsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToInvitationsUpdateMany) teamsModel() {}

func (r teamsToInvitationsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsToInvitationsUpdateMany) Tx() teamsManyTxResult {
	v := NewteamsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsToInvitationsFindMany) Delete() teamsToInvitationsDeleteMany {
	var v teamsToInvitationsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "teams"

	v.query.Outputs = countOutput

	return v
}

type teamsToInvitationsDeleteMany struct {
	query builder.Query
}

func (r teamsToInvitationsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsToInvitationsDeleteMany) teamsModel() {}

func (r teamsToInvitationsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsToInvitationsDeleteMany) Tx() teamsManyTxResult {
	v := NewteamsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsToTeamsProjectsFindUnique struct {
	query builder.Query
}

func (r teamsToTeamsProjectsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsProjectsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsProjectsFindUnique) with()          {}
func (r teamsToTeamsProjectsFindUnique) teamsModel()    {}
func (r teamsToTeamsProjectsFindUnique) teamsRelation() {}

func (r teamsToTeamsProjectsFindUnique) With(params ...TeamsProjectsRelationWith) teamsToTeamsProjectsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsToTeamsProjectsFindUnique) Exec(ctx context.Context) (
	*TeamsModel,
	error,
) {
	var v *TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsToTeamsProjectsFindUnique) ExecInner(ctx context.Context) (
	*InnerTeams,
	error,
) {
	var v *InnerTeams
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsToTeamsProjectsFindUnique) Update(params ...TeamsSetParam) teamsToTeamsProjectsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "teams"

	var v teamsToTeamsProjectsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsToTeamsProjectsUpdateUnique struct {
	query builder.Query
}

func (r teamsToTeamsProjectsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsProjectsUpdateUnique) teamsModel() {}

func (r teamsToTeamsProjectsUpdateUnique) Exec(ctx context.Context) (*TeamsModel, error) {
	var v TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsToTeamsProjectsUpdateUnique) Tx() teamsUniqueTxResult {
	v := NewteamsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsToTeamsProjectsFindUnique) Delete() teamsToTeamsProjectsDeleteUnique {
	var v teamsToTeamsProjectsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "teams"

	return v
}

type teamsToTeamsProjectsDeleteUnique struct {
	query builder.Query
}

func (r teamsToTeamsProjectsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsToTeamsProjectsDeleteUnique) teamsModel() {}

func (r teamsToTeamsProjectsDeleteUnique) Exec(ctx context.Context) (*TeamsModel, error) {
	var v TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsToTeamsProjectsDeleteUnique) Tx() teamsUniqueTxResult {
	v := NewteamsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsToTeamsProjectsFindFirst struct {
	query builder.Query
}

func (r teamsToTeamsProjectsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsProjectsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsProjectsFindFirst) with()          {}
func (r teamsToTeamsProjectsFindFirst) teamsModel()    {}
func (r teamsToTeamsProjectsFindFirst) teamsRelation() {}

func (r teamsToTeamsProjectsFindFirst) With(params ...TeamsProjectsRelationWith) teamsToTeamsProjectsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsToTeamsProjectsFindFirst) OrderBy(params ...TeamsProjectsOrderByParam) teamsToTeamsProjectsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsToTeamsProjectsFindFirst) Skip(count int) teamsToTeamsProjectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsToTeamsProjectsFindFirst) Take(count int) teamsToTeamsProjectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsToTeamsProjectsFindFirst) Cursor(cursor TeamsCursorParam) teamsToTeamsProjectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsToTeamsProjectsFindFirst) Exec(ctx context.Context) (
	*TeamsModel,
	error,
) {
	var v *TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsToTeamsProjectsFindFirst) ExecInner(ctx context.Context) (
	*InnerTeams,
	error,
) {
	var v *InnerTeams
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type teamsToTeamsProjectsFindMany struct {
	query builder.Query
}

func (r teamsToTeamsProjectsFindMany) getQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsProjectsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsProjectsFindMany) with()          {}
func (r teamsToTeamsProjectsFindMany) teamsModel()    {}
func (r teamsToTeamsProjectsFindMany) teamsRelation() {}

func (r teamsToTeamsProjectsFindMany) With(params ...TeamsProjectsRelationWith) teamsToTeamsProjectsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsToTeamsProjectsFindMany) OrderBy(params ...TeamsProjectsOrderByParam) teamsToTeamsProjectsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsToTeamsProjectsFindMany) Skip(count int) teamsToTeamsProjectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsToTeamsProjectsFindMany) Take(count int) teamsToTeamsProjectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsToTeamsProjectsFindMany) Cursor(cursor TeamsCursorParam) teamsToTeamsProjectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsToTeamsProjectsFindMany) Exec(ctx context.Context) (
	[]TeamsModel,
	error,
) {
	var v []TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsToTeamsProjectsFindMany) ExecInner(ctx context.Context) (
	[]InnerTeams,
	error,
) {
	var v []InnerTeams
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsToTeamsProjectsFindMany) Update(params ...TeamsSetParam) teamsToTeamsProjectsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "teams"

	r.query.Outputs = countOutput

	var v teamsToTeamsProjectsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsToTeamsProjectsUpdateMany struct {
	query builder.Query
}

func (r teamsToTeamsProjectsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsProjectsUpdateMany) teamsModel() {}

func (r teamsToTeamsProjectsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsToTeamsProjectsUpdateMany) Tx() teamsManyTxResult {
	v := NewteamsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsToTeamsProjectsFindMany) Delete() teamsToTeamsProjectsDeleteMany {
	var v teamsToTeamsProjectsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "teams"

	v.query.Outputs = countOutput

	return v
}

type teamsToTeamsProjectsDeleteMany struct {
	query builder.Query
}

func (r teamsToTeamsProjectsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsToTeamsProjectsDeleteMany) teamsModel() {}

func (r teamsToTeamsProjectsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsToTeamsProjectsDeleteMany) Tx() teamsManyTxResult {
	v := NewteamsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsToTeamsUsersFindUnique struct {
	query builder.Query
}

func (r teamsToTeamsUsersFindUnique) getQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsUsersFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsUsersFindUnique) with()          {}
func (r teamsToTeamsUsersFindUnique) teamsModel()    {}
func (r teamsToTeamsUsersFindUnique) teamsRelation() {}

func (r teamsToTeamsUsersFindUnique) With(params ...TeamsUsersRelationWith) teamsToTeamsUsersFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsToTeamsUsersFindUnique) Exec(ctx context.Context) (
	*TeamsModel,
	error,
) {
	var v *TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsToTeamsUsersFindUnique) ExecInner(ctx context.Context) (
	*InnerTeams,
	error,
) {
	var v *InnerTeams
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsToTeamsUsersFindUnique) Update(params ...TeamsSetParam) teamsToTeamsUsersUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "teams"

	var v teamsToTeamsUsersUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsToTeamsUsersUpdateUnique struct {
	query builder.Query
}

func (r teamsToTeamsUsersUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsUsersUpdateUnique) teamsModel() {}

func (r teamsToTeamsUsersUpdateUnique) Exec(ctx context.Context) (*TeamsModel, error) {
	var v TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsToTeamsUsersUpdateUnique) Tx() teamsUniqueTxResult {
	v := NewteamsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsToTeamsUsersFindUnique) Delete() teamsToTeamsUsersDeleteUnique {
	var v teamsToTeamsUsersDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "teams"

	return v
}

type teamsToTeamsUsersDeleteUnique struct {
	query builder.Query
}

func (r teamsToTeamsUsersDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsToTeamsUsersDeleteUnique) teamsModel() {}

func (r teamsToTeamsUsersDeleteUnique) Exec(ctx context.Context) (*TeamsModel, error) {
	var v TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsToTeamsUsersDeleteUnique) Tx() teamsUniqueTxResult {
	v := NewteamsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsToTeamsUsersFindFirst struct {
	query builder.Query
}

func (r teamsToTeamsUsersFindFirst) getQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsUsersFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsUsersFindFirst) with()          {}
func (r teamsToTeamsUsersFindFirst) teamsModel()    {}
func (r teamsToTeamsUsersFindFirst) teamsRelation() {}

func (r teamsToTeamsUsersFindFirst) With(params ...TeamsUsersRelationWith) teamsToTeamsUsersFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsToTeamsUsersFindFirst) OrderBy(params ...TeamsUsersOrderByParam) teamsToTeamsUsersFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsToTeamsUsersFindFirst) Skip(count int) teamsToTeamsUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsToTeamsUsersFindFirst) Take(count int) teamsToTeamsUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsToTeamsUsersFindFirst) Cursor(cursor TeamsCursorParam) teamsToTeamsUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsToTeamsUsersFindFirst) Exec(ctx context.Context) (
	*TeamsModel,
	error,
) {
	var v *TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsToTeamsUsersFindFirst) ExecInner(ctx context.Context) (
	*InnerTeams,
	error,
) {
	var v *InnerTeams
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type teamsToTeamsUsersFindMany struct {
	query builder.Query
}

func (r teamsToTeamsUsersFindMany) getQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsUsersFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsUsersFindMany) with()          {}
func (r teamsToTeamsUsersFindMany) teamsModel()    {}
func (r teamsToTeamsUsersFindMany) teamsRelation() {}

func (r teamsToTeamsUsersFindMany) With(params ...TeamsUsersRelationWith) teamsToTeamsUsersFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsToTeamsUsersFindMany) OrderBy(params ...TeamsUsersOrderByParam) teamsToTeamsUsersFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsToTeamsUsersFindMany) Skip(count int) teamsToTeamsUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsToTeamsUsersFindMany) Take(count int) teamsToTeamsUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsToTeamsUsersFindMany) Cursor(cursor TeamsCursorParam) teamsToTeamsUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsToTeamsUsersFindMany) Exec(ctx context.Context) (
	[]TeamsModel,
	error,
) {
	var v []TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsToTeamsUsersFindMany) ExecInner(ctx context.Context) (
	[]InnerTeams,
	error,
) {
	var v []InnerTeams
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsToTeamsUsersFindMany) Update(params ...TeamsSetParam) teamsToTeamsUsersUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "teams"

	r.query.Outputs = countOutput

	var v teamsToTeamsUsersUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsToTeamsUsersUpdateMany struct {
	query builder.Query
}

func (r teamsToTeamsUsersUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsToTeamsUsersUpdateMany) teamsModel() {}

func (r teamsToTeamsUsersUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsToTeamsUsersUpdateMany) Tx() teamsManyTxResult {
	v := NewteamsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsToTeamsUsersFindMany) Delete() teamsToTeamsUsersDeleteMany {
	var v teamsToTeamsUsersDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "teams"

	v.query.Outputs = countOutput

	return v
}

type teamsToTeamsUsersDeleteMany struct {
	query builder.Query
}

func (r teamsToTeamsUsersDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsToTeamsUsersDeleteMany) teamsModel() {}

func (r teamsToTeamsUsersDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsToTeamsUsersDeleteMany) Tx() teamsManyTxResult {
	v := NewteamsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsFindUnique struct {
	query builder.Query
}

func (r teamsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r teamsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsFindUnique) with()          {}
func (r teamsFindUnique) teamsModel()    {}
func (r teamsFindUnique) teamsRelation() {}

func (r teamsActions) FindUnique(
	params TeamsEqualsUniqueWhereParam,
) teamsFindUnique {
	var v teamsFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "teams"
	v.query.Outputs = teamsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r teamsFindUnique) With(params ...TeamsRelationWith) teamsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsFindUnique) Exec(ctx context.Context) (
	*TeamsModel,
	error,
) {
	var v *TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsFindUnique) ExecInner(ctx context.Context) (
	*InnerTeams,
	error,
) {
	var v *InnerTeams
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsFindUnique) Update(params ...TeamsSetParam) teamsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "teams"

	var v teamsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsUpdateUnique struct {
	query builder.Query
}

func (r teamsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUpdateUnique) teamsModel() {}

func (r teamsUpdateUnique) Exec(ctx context.Context) (*TeamsModel, error) {
	var v TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUpdateUnique) Tx() teamsUniqueTxResult {
	v := NewteamsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsFindUnique) Delete() teamsDeleteUnique {
	var v teamsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "teams"

	return v
}

type teamsDeleteUnique struct {
	query builder.Query
}

func (r teamsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsDeleteUnique) teamsModel() {}

func (r teamsDeleteUnique) Exec(ctx context.Context) (*TeamsModel, error) {
	var v TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsDeleteUnique) Tx() teamsUniqueTxResult {
	v := NewteamsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsFindFirst struct {
	query builder.Query
}

func (r teamsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r teamsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsFindFirst) with()          {}
func (r teamsFindFirst) teamsModel()    {}
func (r teamsFindFirst) teamsRelation() {}

func (r teamsActions) FindFirst(
	params ...TeamsWhereParam,
) teamsFindFirst {
	var v teamsFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "teams"
	v.query.Outputs = teamsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r teamsFindFirst) With(params ...TeamsRelationWith) teamsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsFindFirst) OrderBy(params ...TeamsOrderByParam) teamsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsFindFirst) Skip(count int) teamsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsFindFirst) Take(count int) teamsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsFindFirst) Cursor(cursor TeamsCursorParam) teamsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsFindFirst) Exec(ctx context.Context) (
	*TeamsModel,
	error,
) {
	var v *TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsFindFirst) ExecInner(ctx context.Context) (
	*InnerTeams,
	error,
) {
	var v *InnerTeams
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type teamsFindMany struct {
	query builder.Query
}

func (r teamsFindMany) getQuery() builder.Query {
	return r.query
}

func (r teamsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsFindMany) with()          {}
func (r teamsFindMany) teamsModel()    {}
func (r teamsFindMany) teamsRelation() {}

func (r teamsActions) FindMany(
	params ...TeamsWhereParam,
) teamsFindMany {
	var v teamsFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "teams"
	v.query.Outputs = teamsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r teamsFindMany) With(params ...TeamsRelationWith) teamsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsFindMany) OrderBy(params ...TeamsOrderByParam) teamsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsFindMany) Skip(count int) teamsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsFindMany) Take(count int) teamsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsFindMany) Cursor(cursor TeamsCursorParam) teamsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsFindMany) Exec(ctx context.Context) (
	[]TeamsModel,
	error,
) {
	var v []TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsFindMany) ExecInner(ctx context.Context) (
	[]InnerTeams,
	error,
) {
	var v []InnerTeams
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsFindMany) Update(params ...TeamsSetParam) teamsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "teams"

	r.query.Outputs = countOutput

	var v teamsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsUpdateMany struct {
	query builder.Query
}

func (r teamsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUpdateMany) teamsModel() {}

func (r teamsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUpdateMany) Tx() teamsManyTxResult {
	v := NewteamsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsFindMany) Delete() teamsDeleteMany {
	var v teamsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "teams"

	v.query.Outputs = countOutput

	return v
}

type teamsDeleteMany struct {
	query builder.Query
}

func (r teamsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsDeleteMany) teamsModel() {}

func (r teamsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsDeleteMany) Tx() teamsManyTxResult {
	v := NewteamsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsProjectsToProjectsFindUnique struct {
	query builder.Query
}

func (r teamsProjectsToProjectsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToProjectsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToProjectsFindUnique) with()                  {}
func (r teamsProjectsToProjectsFindUnique) teamsProjectsModel()    {}
func (r teamsProjectsToProjectsFindUnique) teamsProjectsRelation() {}

func (r teamsProjectsToProjectsFindUnique) With(params ...ProjectsRelationWith) teamsProjectsToProjectsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsProjectsToProjectsFindUnique) Exec(ctx context.Context) (
	*TeamsProjectsModel,
	error,
) {
	var v *TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsProjectsToProjectsFindUnique) ExecInner(ctx context.Context) (
	*InnerTeamsProjects,
	error,
) {
	var v *InnerTeamsProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsProjectsToProjectsFindUnique) Update(params ...TeamsProjectsSetParam) teamsProjectsToProjectsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "teams_projects"

	var v teamsProjectsToProjectsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsProjectsToProjectsUpdateUnique struct {
	query builder.Query
}

func (r teamsProjectsToProjectsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToProjectsUpdateUnique) teamsProjectsModel() {}

func (r teamsProjectsToProjectsUpdateUnique) Exec(ctx context.Context) (*TeamsProjectsModel, error) {
	var v TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsProjectsToProjectsUpdateUnique) Tx() teamsProjectsUniqueTxResult {
	v := NewteamsProjectsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsProjectsToProjectsFindUnique) Delete() teamsProjectsToProjectsDeleteUnique {
	var v teamsProjectsToProjectsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "teams_projects"

	return v
}

type teamsProjectsToProjectsDeleteUnique struct {
	query builder.Query
}

func (r teamsProjectsToProjectsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsProjectsToProjectsDeleteUnique) teamsProjectsModel() {}

func (r teamsProjectsToProjectsDeleteUnique) Exec(ctx context.Context) (*TeamsProjectsModel, error) {
	var v TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsProjectsToProjectsDeleteUnique) Tx() teamsProjectsUniqueTxResult {
	v := NewteamsProjectsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsProjectsToProjectsFindFirst struct {
	query builder.Query
}

func (r teamsProjectsToProjectsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToProjectsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToProjectsFindFirst) with()                  {}
func (r teamsProjectsToProjectsFindFirst) teamsProjectsModel()    {}
func (r teamsProjectsToProjectsFindFirst) teamsProjectsRelation() {}

func (r teamsProjectsToProjectsFindFirst) With(params ...ProjectsRelationWith) teamsProjectsToProjectsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsProjectsToProjectsFindFirst) OrderBy(params ...ProjectsOrderByParam) teamsProjectsToProjectsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsProjectsToProjectsFindFirst) Skip(count int) teamsProjectsToProjectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsProjectsToProjectsFindFirst) Take(count int) teamsProjectsToProjectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsProjectsToProjectsFindFirst) Cursor(cursor TeamsProjectsCursorParam) teamsProjectsToProjectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsProjectsToProjectsFindFirst) Exec(ctx context.Context) (
	*TeamsProjectsModel,
	error,
) {
	var v *TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsProjectsToProjectsFindFirst) ExecInner(ctx context.Context) (
	*InnerTeamsProjects,
	error,
) {
	var v *InnerTeamsProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type teamsProjectsToProjectsFindMany struct {
	query builder.Query
}

func (r teamsProjectsToProjectsFindMany) getQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToProjectsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToProjectsFindMany) with()                  {}
func (r teamsProjectsToProjectsFindMany) teamsProjectsModel()    {}
func (r teamsProjectsToProjectsFindMany) teamsProjectsRelation() {}

func (r teamsProjectsToProjectsFindMany) With(params ...ProjectsRelationWith) teamsProjectsToProjectsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsProjectsToProjectsFindMany) OrderBy(params ...ProjectsOrderByParam) teamsProjectsToProjectsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsProjectsToProjectsFindMany) Skip(count int) teamsProjectsToProjectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsProjectsToProjectsFindMany) Take(count int) teamsProjectsToProjectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsProjectsToProjectsFindMany) Cursor(cursor TeamsProjectsCursorParam) teamsProjectsToProjectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsProjectsToProjectsFindMany) Exec(ctx context.Context) (
	[]TeamsProjectsModel,
	error,
) {
	var v []TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsProjectsToProjectsFindMany) ExecInner(ctx context.Context) (
	[]InnerTeamsProjects,
	error,
) {
	var v []InnerTeamsProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsProjectsToProjectsFindMany) Update(params ...TeamsProjectsSetParam) teamsProjectsToProjectsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "teams_projects"

	r.query.Outputs = countOutput

	var v teamsProjectsToProjectsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsProjectsToProjectsUpdateMany struct {
	query builder.Query
}

func (r teamsProjectsToProjectsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToProjectsUpdateMany) teamsProjectsModel() {}

func (r teamsProjectsToProjectsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsProjectsToProjectsUpdateMany) Tx() teamsProjectsManyTxResult {
	v := NewteamsProjectsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsProjectsToProjectsFindMany) Delete() teamsProjectsToProjectsDeleteMany {
	var v teamsProjectsToProjectsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "teams_projects"

	v.query.Outputs = countOutput

	return v
}

type teamsProjectsToProjectsDeleteMany struct {
	query builder.Query
}

func (r teamsProjectsToProjectsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsProjectsToProjectsDeleteMany) teamsProjectsModel() {}

func (r teamsProjectsToProjectsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsProjectsToProjectsDeleteMany) Tx() teamsProjectsManyTxResult {
	v := NewteamsProjectsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsProjectsToTeamsFindUnique struct {
	query builder.Query
}

func (r teamsProjectsToTeamsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToTeamsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToTeamsFindUnique) with()                  {}
func (r teamsProjectsToTeamsFindUnique) teamsProjectsModel()    {}
func (r teamsProjectsToTeamsFindUnique) teamsProjectsRelation() {}

func (r teamsProjectsToTeamsFindUnique) With(params ...TeamsRelationWith) teamsProjectsToTeamsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsProjectsToTeamsFindUnique) Exec(ctx context.Context) (
	*TeamsProjectsModel,
	error,
) {
	var v *TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsProjectsToTeamsFindUnique) ExecInner(ctx context.Context) (
	*InnerTeamsProjects,
	error,
) {
	var v *InnerTeamsProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsProjectsToTeamsFindUnique) Update(params ...TeamsProjectsSetParam) teamsProjectsToTeamsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "teams_projects"

	var v teamsProjectsToTeamsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsProjectsToTeamsUpdateUnique struct {
	query builder.Query
}

func (r teamsProjectsToTeamsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToTeamsUpdateUnique) teamsProjectsModel() {}

func (r teamsProjectsToTeamsUpdateUnique) Exec(ctx context.Context) (*TeamsProjectsModel, error) {
	var v TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsProjectsToTeamsUpdateUnique) Tx() teamsProjectsUniqueTxResult {
	v := NewteamsProjectsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsProjectsToTeamsFindUnique) Delete() teamsProjectsToTeamsDeleteUnique {
	var v teamsProjectsToTeamsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "teams_projects"

	return v
}

type teamsProjectsToTeamsDeleteUnique struct {
	query builder.Query
}

func (r teamsProjectsToTeamsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsProjectsToTeamsDeleteUnique) teamsProjectsModel() {}

func (r teamsProjectsToTeamsDeleteUnique) Exec(ctx context.Context) (*TeamsProjectsModel, error) {
	var v TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsProjectsToTeamsDeleteUnique) Tx() teamsProjectsUniqueTxResult {
	v := NewteamsProjectsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsProjectsToTeamsFindFirst struct {
	query builder.Query
}

func (r teamsProjectsToTeamsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToTeamsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToTeamsFindFirst) with()                  {}
func (r teamsProjectsToTeamsFindFirst) teamsProjectsModel()    {}
func (r teamsProjectsToTeamsFindFirst) teamsProjectsRelation() {}

func (r teamsProjectsToTeamsFindFirst) With(params ...TeamsRelationWith) teamsProjectsToTeamsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsProjectsToTeamsFindFirst) OrderBy(params ...TeamsOrderByParam) teamsProjectsToTeamsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsProjectsToTeamsFindFirst) Skip(count int) teamsProjectsToTeamsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsProjectsToTeamsFindFirst) Take(count int) teamsProjectsToTeamsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsProjectsToTeamsFindFirst) Cursor(cursor TeamsProjectsCursorParam) teamsProjectsToTeamsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsProjectsToTeamsFindFirst) Exec(ctx context.Context) (
	*TeamsProjectsModel,
	error,
) {
	var v *TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsProjectsToTeamsFindFirst) ExecInner(ctx context.Context) (
	*InnerTeamsProjects,
	error,
) {
	var v *InnerTeamsProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type teamsProjectsToTeamsFindMany struct {
	query builder.Query
}

func (r teamsProjectsToTeamsFindMany) getQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToTeamsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToTeamsFindMany) with()                  {}
func (r teamsProjectsToTeamsFindMany) teamsProjectsModel()    {}
func (r teamsProjectsToTeamsFindMany) teamsProjectsRelation() {}

func (r teamsProjectsToTeamsFindMany) With(params ...TeamsRelationWith) teamsProjectsToTeamsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsProjectsToTeamsFindMany) OrderBy(params ...TeamsOrderByParam) teamsProjectsToTeamsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsProjectsToTeamsFindMany) Skip(count int) teamsProjectsToTeamsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsProjectsToTeamsFindMany) Take(count int) teamsProjectsToTeamsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsProjectsToTeamsFindMany) Cursor(cursor TeamsProjectsCursorParam) teamsProjectsToTeamsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsProjectsToTeamsFindMany) Exec(ctx context.Context) (
	[]TeamsProjectsModel,
	error,
) {
	var v []TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsProjectsToTeamsFindMany) ExecInner(ctx context.Context) (
	[]InnerTeamsProjects,
	error,
) {
	var v []InnerTeamsProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsProjectsToTeamsFindMany) Update(params ...TeamsProjectsSetParam) teamsProjectsToTeamsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "teams_projects"

	r.query.Outputs = countOutput

	var v teamsProjectsToTeamsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsProjectsToTeamsUpdateMany struct {
	query builder.Query
}

func (r teamsProjectsToTeamsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsToTeamsUpdateMany) teamsProjectsModel() {}

func (r teamsProjectsToTeamsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsProjectsToTeamsUpdateMany) Tx() teamsProjectsManyTxResult {
	v := NewteamsProjectsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsProjectsToTeamsFindMany) Delete() teamsProjectsToTeamsDeleteMany {
	var v teamsProjectsToTeamsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "teams_projects"

	v.query.Outputs = countOutput

	return v
}

type teamsProjectsToTeamsDeleteMany struct {
	query builder.Query
}

func (r teamsProjectsToTeamsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsProjectsToTeamsDeleteMany) teamsProjectsModel() {}

func (r teamsProjectsToTeamsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsProjectsToTeamsDeleteMany) Tx() teamsProjectsManyTxResult {
	v := NewteamsProjectsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsProjectsFindUnique struct {
	query builder.Query
}

func (r teamsProjectsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r teamsProjectsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsFindUnique) with()                  {}
func (r teamsProjectsFindUnique) teamsProjectsModel()    {}
func (r teamsProjectsFindUnique) teamsProjectsRelation() {}

func (r teamsProjectsActions) FindUnique(
	params TeamsProjectsEqualsUniqueWhereParam,
) teamsProjectsFindUnique {
	var v teamsProjectsFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "teams_projects"
	v.query.Outputs = teamsProjectsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r teamsProjectsFindUnique) With(params ...TeamsProjectsRelationWith) teamsProjectsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsProjectsFindUnique) Exec(ctx context.Context) (
	*TeamsProjectsModel,
	error,
) {
	var v *TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsProjectsFindUnique) ExecInner(ctx context.Context) (
	*InnerTeamsProjects,
	error,
) {
	var v *InnerTeamsProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsProjectsFindUnique) Update(params ...TeamsProjectsSetParam) teamsProjectsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "teams_projects"

	var v teamsProjectsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsProjectsUpdateUnique struct {
	query builder.Query
}

func (r teamsProjectsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsUpdateUnique) teamsProjectsModel() {}

func (r teamsProjectsUpdateUnique) Exec(ctx context.Context) (*TeamsProjectsModel, error) {
	var v TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsProjectsUpdateUnique) Tx() teamsProjectsUniqueTxResult {
	v := NewteamsProjectsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsProjectsFindUnique) Delete() teamsProjectsDeleteUnique {
	var v teamsProjectsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "teams_projects"

	return v
}

type teamsProjectsDeleteUnique struct {
	query builder.Query
}

func (r teamsProjectsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsProjectsDeleteUnique) teamsProjectsModel() {}

func (r teamsProjectsDeleteUnique) Exec(ctx context.Context) (*TeamsProjectsModel, error) {
	var v TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsProjectsDeleteUnique) Tx() teamsProjectsUniqueTxResult {
	v := NewteamsProjectsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsProjectsFindFirst struct {
	query builder.Query
}

func (r teamsProjectsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r teamsProjectsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsFindFirst) with()                  {}
func (r teamsProjectsFindFirst) teamsProjectsModel()    {}
func (r teamsProjectsFindFirst) teamsProjectsRelation() {}

func (r teamsProjectsActions) FindFirst(
	params ...TeamsProjectsWhereParam,
) teamsProjectsFindFirst {
	var v teamsProjectsFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "teams_projects"
	v.query.Outputs = teamsProjectsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r teamsProjectsFindFirst) With(params ...TeamsProjectsRelationWith) teamsProjectsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsProjectsFindFirst) OrderBy(params ...TeamsProjectsOrderByParam) teamsProjectsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsProjectsFindFirst) Skip(count int) teamsProjectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsProjectsFindFirst) Take(count int) teamsProjectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsProjectsFindFirst) Cursor(cursor TeamsProjectsCursorParam) teamsProjectsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsProjectsFindFirst) Exec(ctx context.Context) (
	*TeamsProjectsModel,
	error,
) {
	var v *TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsProjectsFindFirst) ExecInner(ctx context.Context) (
	*InnerTeamsProjects,
	error,
) {
	var v *InnerTeamsProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type teamsProjectsFindMany struct {
	query builder.Query
}

func (r teamsProjectsFindMany) getQuery() builder.Query {
	return r.query
}

func (r teamsProjectsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsFindMany) with()                  {}
func (r teamsProjectsFindMany) teamsProjectsModel()    {}
func (r teamsProjectsFindMany) teamsProjectsRelation() {}

func (r teamsProjectsActions) FindMany(
	params ...TeamsProjectsWhereParam,
) teamsProjectsFindMany {
	var v teamsProjectsFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "teams_projects"
	v.query.Outputs = teamsProjectsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r teamsProjectsFindMany) With(params ...TeamsProjectsRelationWith) teamsProjectsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsProjectsFindMany) OrderBy(params ...TeamsProjectsOrderByParam) teamsProjectsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsProjectsFindMany) Skip(count int) teamsProjectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsProjectsFindMany) Take(count int) teamsProjectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsProjectsFindMany) Cursor(cursor TeamsProjectsCursorParam) teamsProjectsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsProjectsFindMany) Exec(ctx context.Context) (
	[]TeamsProjectsModel,
	error,
) {
	var v []TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsProjectsFindMany) ExecInner(ctx context.Context) (
	[]InnerTeamsProjects,
	error,
) {
	var v []InnerTeamsProjects
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsProjectsFindMany) Update(params ...TeamsProjectsSetParam) teamsProjectsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "teams_projects"

	r.query.Outputs = countOutput

	var v teamsProjectsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsProjectsUpdateMany struct {
	query builder.Query
}

func (r teamsProjectsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsUpdateMany) teamsProjectsModel() {}

func (r teamsProjectsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsProjectsUpdateMany) Tx() teamsProjectsManyTxResult {
	v := NewteamsProjectsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsProjectsFindMany) Delete() teamsProjectsDeleteMany {
	var v teamsProjectsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "teams_projects"

	v.query.Outputs = countOutput

	return v
}

type teamsProjectsDeleteMany struct {
	query builder.Query
}

func (r teamsProjectsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsProjectsDeleteMany) teamsProjectsModel() {}

func (r teamsProjectsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsProjectsDeleteMany) Tx() teamsProjectsManyTxResult {
	v := NewteamsProjectsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsUsersToTeamsFindUnique struct {
	query builder.Query
}

func (r teamsUsersToTeamsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r teamsUsersToTeamsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersToTeamsFindUnique) with()               {}
func (r teamsUsersToTeamsFindUnique) teamsUsersModel()    {}
func (r teamsUsersToTeamsFindUnique) teamsUsersRelation() {}

func (r teamsUsersToTeamsFindUnique) With(params ...TeamsRelationWith) teamsUsersToTeamsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsUsersToTeamsFindUnique) Exec(ctx context.Context) (
	*TeamsUsersModel,
	error,
) {
	var v *TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsUsersToTeamsFindUnique) ExecInner(ctx context.Context) (
	*InnerTeamsUsers,
	error,
) {
	var v *InnerTeamsUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsUsersToTeamsFindUnique) Update(params ...TeamsUsersSetParam) teamsUsersToTeamsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "teams_users"

	var v teamsUsersToTeamsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsUsersToTeamsUpdateUnique struct {
	query builder.Query
}

func (r teamsUsersToTeamsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersToTeamsUpdateUnique) teamsUsersModel() {}

func (r teamsUsersToTeamsUpdateUnique) Exec(ctx context.Context) (*TeamsUsersModel, error) {
	var v TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUsersToTeamsUpdateUnique) Tx() teamsUsersUniqueTxResult {
	v := NewteamsUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsUsersToTeamsFindUnique) Delete() teamsUsersToTeamsDeleteUnique {
	var v teamsUsersToTeamsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "teams_users"

	return v
}

type teamsUsersToTeamsDeleteUnique struct {
	query builder.Query
}

func (r teamsUsersToTeamsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsUsersToTeamsDeleteUnique) teamsUsersModel() {}

func (r teamsUsersToTeamsDeleteUnique) Exec(ctx context.Context) (*TeamsUsersModel, error) {
	var v TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUsersToTeamsDeleteUnique) Tx() teamsUsersUniqueTxResult {
	v := NewteamsUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsUsersToTeamsFindFirst struct {
	query builder.Query
}

func (r teamsUsersToTeamsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r teamsUsersToTeamsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersToTeamsFindFirst) with()               {}
func (r teamsUsersToTeamsFindFirst) teamsUsersModel()    {}
func (r teamsUsersToTeamsFindFirst) teamsUsersRelation() {}

func (r teamsUsersToTeamsFindFirst) With(params ...TeamsRelationWith) teamsUsersToTeamsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsUsersToTeamsFindFirst) OrderBy(params ...TeamsOrderByParam) teamsUsersToTeamsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsUsersToTeamsFindFirst) Skip(count int) teamsUsersToTeamsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsUsersToTeamsFindFirst) Take(count int) teamsUsersToTeamsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsUsersToTeamsFindFirst) Cursor(cursor TeamsUsersCursorParam) teamsUsersToTeamsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsUsersToTeamsFindFirst) Exec(ctx context.Context) (
	*TeamsUsersModel,
	error,
) {
	var v *TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsUsersToTeamsFindFirst) ExecInner(ctx context.Context) (
	*InnerTeamsUsers,
	error,
) {
	var v *InnerTeamsUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type teamsUsersToTeamsFindMany struct {
	query builder.Query
}

func (r teamsUsersToTeamsFindMany) getQuery() builder.Query {
	return r.query
}

func (r teamsUsersToTeamsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersToTeamsFindMany) with()               {}
func (r teamsUsersToTeamsFindMany) teamsUsersModel()    {}
func (r teamsUsersToTeamsFindMany) teamsUsersRelation() {}

func (r teamsUsersToTeamsFindMany) With(params ...TeamsRelationWith) teamsUsersToTeamsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsUsersToTeamsFindMany) OrderBy(params ...TeamsOrderByParam) teamsUsersToTeamsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsUsersToTeamsFindMany) Skip(count int) teamsUsersToTeamsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsUsersToTeamsFindMany) Take(count int) teamsUsersToTeamsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsUsersToTeamsFindMany) Cursor(cursor TeamsUsersCursorParam) teamsUsersToTeamsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsUsersToTeamsFindMany) Exec(ctx context.Context) (
	[]TeamsUsersModel,
	error,
) {
	var v []TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsUsersToTeamsFindMany) ExecInner(ctx context.Context) (
	[]InnerTeamsUsers,
	error,
) {
	var v []InnerTeamsUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsUsersToTeamsFindMany) Update(params ...TeamsUsersSetParam) teamsUsersToTeamsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "teams_users"

	r.query.Outputs = countOutput

	var v teamsUsersToTeamsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsUsersToTeamsUpdateMany struct {
	query builder.Query
}

func (r teamsUsersToTeamsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersToTeamsUpdateMany) teamsUsersModel() {}

func (r teamsUsersToTeamsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUsersToTeamsUpdateMany) Tx() teamsUsersManyTxResult {
	v := NewteamsUsersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsUsersToTeamsFindMany) Delete() teamsUsersToTeamsDeleteMany {
	var v teamsUsersToTeamsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "teams_users"

	v.query.Outputs = countOutput

	return v
}

type teamsUsersToTeamsDeleteMany struct {
	query builder.Query
}

func (r teamsUsersToTeamsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsUsersToTeamsDeleteMany) teamsUsersModel() {}

func (r teamsUsersToTeamsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUsersToTeamsDeleteMany) Tx() teamsUsersManyTxResult {
	v := NewteamsUsersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsUsersToUsersFindUnique struct {
	query builder.Query
}

func (r teamsUsersToUsersFindUnique) getQuery() builder.Query {
	return r.query
}

func (r teamsUsersToUsersFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersToUsersFindUnique) with()               {}
func (r teamsUsersToUsersFindUnique) teamsUsersModel()    {}
func (r teamsUsersToUsersFindUnique) teamsUsersRelation() {}

func (r teamsUsersToUsersFindUnique) With(params ...UsersRelationWith) teamsUsersToUsersFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsUsersToUsersFindUnique) Exec(ctx context.Context) (
	*TeamsUsersModel,
	error,
) {
	var v *TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsUsersToUsersFindUnique) ExecInner(ctx context.Context) (
	*InnerTeamsUsers,
	error,
) {
	var v *InnerTeamsUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsUsersToUsersFindUnique) Update(params ...TeamsUsersSetParam) teamsUsersToUsersUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "teams_users"

	var v teamsUsersToUsersUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsUsersToUsersUpdateUnique struct {
	query builder.Query
}

func (r teamsUsersToUsersUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersToUsersUpdateUnique) teamsUsersModel() {}

func (r teamsUsersToUsersUpdateUnique) Exec(ctx context.Context) (*TeamsUsersModel, error) {
	var v TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUsersToUsersUpdateUnique) Tx() teamsUsersUniqueTxResult {
	v := NewteamsUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsUsersToUsersFindUnique) Delete() teamsUsersToUsersDeleteUnique {
	var v teamsUsersToUsersDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "teams_users"

	return v
}

type teamsUsersToUsersDeleteUnique struct {
	query builder.Query
}

func (r teamsUsersToUsersDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsUsersToUsersDeleteUnique) teamsUsersModel() {}

func (r teamsUsersToUsersDeleteUnique) Exec(ctx context.Context) (*TeamsUsersModel, error) {
	var v TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUsersToUsersDeleteUnique) Tx() teamsUsersUniqueTxResult {
	v := NewteamsUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsUsersToUsersFindFirst struct {
	query builder.Query
}

func (r teamsUsersToUsersFindFirst) getQuery() builder.Query {
	return r.query
}

func (r teamsUsersToUsersFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersToUsersFindFirst) with()               {}
func (r teamsUsersToUsersFindFirst) teamsUsersModel()    {}
func (r teamsUsersToUsersFindFirst) teamsUsersRelation() {}

func (r teamsUsersToUsersFindFirst) With(params ...UsersRelationWith) teamsUsersToUsersFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsUsersToUsersFindFirst) OrderBy(params ...UsersOrderByParam) teamsUsersToUsersFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsUsersToUsersFindFirst) Skip(count int) teamsUsersToUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsUsersToUsersFindFirst) Take(count int) teamsUsersToUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsUsersToUsersFindFirst) Cursor(cursor TeamsUsersCursorParam) teamsUsersToUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsUsersToUsersFindFirst) Exec(ctx context.Context) (
	*TeamsUsersModel,
	error,
) {
	var v *TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsUsersToUsersFindFirst) ExecInner(ctx context.Context) (
	*InnerTeamsUsers,
	error,
) {
	var v *InnerTeamsUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type teamsUsersToUsersFindMany struct {
	query builder.Query
}

func (r teamsUsersToUsersFindMany) getQuery() builder.Query {
	return r.query
}

func (r teamsUsersToUsersFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersToUsersFindMany) with()               {}
func (r teamsUsersToUsersFindMany) teamsUsersModel()    {}
func (r teamsUsersToUsersFindMany) teamsUsersRelation() {}

func (r teamsUsersToUsersFindMany) With(params ...UsersRelationWith) teamsUsersToUsersFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsUsersToUsersFindMany) OrderBy(params ...UsersOrderByParam) teamsUsersToUsersFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsUsersToUsersFindMany) Skip(count int) teamsUsersToUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsUsersToUsersFindMany) Take(count int) teamsUsersToUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsUsersToUsersFindMany) Cursor(cursor TeamsUsersCursorParam) teamsUsersToUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsUsersToUsersFindMany) Exec(ctx context.Context) (
	[]TeamsUsersModel,
	error,
) {
	var v []TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsUsersToUsersFindMany) ExecInner(ctx context.Context) (
	[]InnerTeamsUsers,
	error,
) {
	var v []InnerTeamsUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsUsersToUsersFindMany) Update(params ...TeamsUsersSetParam) teamsUsersToUsersUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "teams_users"

	r.query.Outputs = countOutput

	var v teamsUsersToUsersUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsUsersToUsersUpdateMany struct {
	query builder.Query
}

func (r teamsUsersToUsersUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersToUsersUpdateMany) teamsUsersModel() {}

func (r teamsUsersToUsersUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUsersToUsersUpdateMany) Tx() teamsUsersManyTxResult {
	v := NewteamsUsersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsUsersToUsersFindMany) Delete() teamsUsersToUsersDeleteMany {
	var v teamsUsersToUsersDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "teams_users"

	v.query.Outputs = countOutput

	return v
}

type teamsUsersToUsersDeleteMany struct {
	query builder.Query
}

func (r teamsUsersToUsersDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsUsersToUsersDeleteMany) teamsUsersModel() {}

func (r teamsUsersToUsersDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUsersToUsersDeleteMany) Tx() teamsUsersManyTxResult {
	v := NewteamsUsersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsUsersFindUnique struct {
	query builder.Query
}

func (r teamsUsersFindUnique) getQuery() builder.Query {
	return r.query
}

func (r teamsUsersFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersFindUnique) with()               {}
func (r teamsUsersFindUnique) teamsUsersModel()    {}
func (r teamsUsersFindUnique) teamsUsersRelation() {}

func (r teamsUsersActions) FindUnique(
	params TeamsUsersEqualsUniqueWhereParam,
) teamsUsersFindUnique {
	var v teamsUsersFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "teams_users"
	v.query.Outputs = teamsUsersOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r teamsUsersFindUnique) With(params ...TeamsUsersRelationWith) teamsUsersFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsUsersFindUnique) Exec(ctx context.Context) (
	*TeamsUsersModel,
	error,
) {
	var v *TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsUsersFindUnique) ExecInner(ctx context.Context) (
	*InnerTeamsUsers,
	error,
) {
	var v *InnerTeamsUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsUsersFindUnique) Update(params ...TeamsUsersSetParam) teamsUsersUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "teams_users"

	var v teamsUsersUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsUsersUpdateUnique struct {
	query builder.Query
}

func (r teamsUsersUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersUpdateUnique) teamsUsersModel() {}

func (r teamsUsersUpdateUnique) Exec(ctx context.Context) (*TeamsUsersModel, error) {
	var v TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUsersUpdateUnique) Tx() teamsUsersUniqueTxResult {
	v := NewteamsUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsUsersFindUnique) Delete() teamsUsersDeleteUnique {
	var v teamsUsersDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "teams_users"

	return v
}

type teamsUsersDeleteUnique struct {
	query builder.Query
}

func (r teamsUsersDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsUsersDeleteUnique) teamsUsersModel() {}

func (r teamsUsersDeleteUnique) Exec(ctx context.Context) (*TeamsUsersModel, error) {
	var v TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUsersDeleteUnique) Tx() teamsUsersUniqueTxResult {
	v := NewteamsUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsUsersFindFirst struct {
	query builder.Query
}

func (r teamsUsersFindFirst) getQuery() builder.Query {
	return r.query
}

func (r teamsUsersFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersFindFirst) with()               {}
func (r teamsUsersFindFirst) teamsUsersModel()    {}
func (r teamsUsersFindFirst) teamsUsersRelation() {}

func (r teamsUsersActions) FindFirst(
	params ...TeamsUsersWhereParam,
) teamsUsersFindFirst {
	var v teamsUsersFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "teams_users"
	v.query.Outputs = teamsUsersOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r teamsUsersFindFirst) With(params ...TeamsUsersRelationWith) teamsUsersFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsUsersFindFirst) OrderBy(params ...TeamsUsersOrderByParam) teamsUsersFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsUsersFindFirst) Skip(count int) teamsUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsUsersFindFirst) Take(count int) teamsUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsUsersFindFirst) Cursor(cursor TeamsUsersCursorParam) teamsUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsUsersFindFirst) Exec(ctx context.Context) (
	*TeamsUsersModel,
	error,
) {
	var v *TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r teamsUsersFindFirst) ExecInner(ctx context.Context) (
	*InnerTeamsUsers,
	error,
) {
	var v *InnerTeamsUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type teamsUsersFindMany struct {
	query builder.Query
}

func (r teamsUsersFindMany) getQuery() builder.Query {
	return r.query
}

func (r teamsUsersFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersFindMany) with()               {}
func (r teamsUsersFindMany) teamsUsersModel()    {}
func (r teamsUsersFindMany) teamsUsersRelation() {}

func (r teamsUsersActions) FindMany(
	params ...TeamsUsersWhereParam,
) teamsUsersFindMany {
	var v teamsUsersFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "teams_users"
	v.query.Outputs = teamsUsersOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r teamsUsersFindMany) With(params ...TeamsUsersRelationWith) teamsUsersFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r teamsUsersFindMany) OrderBy(params ...TeamsUsersOrderByParam) teamsUsersFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r teamsUsersFindMany) Skip(count int) teamsUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r teamsUsersFindMany) Take(count int) teamsUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r teamsUsersFindMany) Cursor(cursor TeamsUsersCursorParam) teamsUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r teamsUsersFindMany) Exec(ctx context.Context) (
	[]TeamsUsersModel,
	error,
) {
	var v []TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsUsersFindMany) ExecInner(ctx context.Context) (
	[]InnerTeamsUsers,
	error,
) {
	var v []InnerTeamsUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r teamsUsersFindMany) Update(params ...TeamsUsersSetParam) teamsUsersUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "teams_users"

	r.query.Outputs = countOutput

	var v teamsUsersUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type teamsUsersUpdateMany struct {
	query builder.Query
}

func (r teamsUsersUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersUpdateMany) teamsUsersModel() {}

func (r teamsUsersUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUsersUpdateMany) Tx() teamsUsersManyTxResult {
	v := NewteamsUsersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r teamsUsersFindMany) Delete() teamsUsersDeleteMany {
	var v teamsUsersDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "teams_users"

	v.query.Outputs = countOutput

	return v
}

type teamsUsersDeleteMany struct {
	query builder.Query
}

func (r teamsUsersDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p teamsUsersDeleteMany) teamsUsersModel() {}

func (r teamsUsersDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUsersDeleteMany) Tx() teamsUsersManyTxResult {
	v := NewteamsUsersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func NewcontactFormSubmissionsUniqueTxResult() contactFormSubmissionsUniqueTxResult {
	return contactFormSubmissionsUniqueTxResult{
		result: &transaction.Result{},
	}
}

type contactFormSubmissionsUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p contactFormSubmissionsUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsUniqueTxResult) IsTx() {}

func (r contactFormSubmissionsUniqueTxResult) Result() (v *ContactFormSubmissionsModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewcontactFormSubmissionsManyTxResult() contactFormSubmissionsManyTxResult {
	return contactFormSubmissionsManyTxResult{
		result: &transaction.Result{},
	}
}

type contactFormSubmissionsManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p contactFormSubmissionsManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsManyTxResult) IsTx() {}

func (r contactFormSubmissionsManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewusersUniqueTxResult() usersUniqueTxResult {
	return usersUniqueTxResult{
		result: &transaction.Result{},
	}
}

type usersUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p usersUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p usersUniqueTxResult) IsTx() {}

func (r usersUniqueTxResult) Result() (v *UsersModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewusersManyTxResult() usersManyTxResult {
	return usersManyTxResult{
		result: &transaction.Result{},
	}
}

type usersManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p usersManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p usersManyTxResult) IsTx() {}

func (r usersManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewinvitationsUniqueTxResult() invitationsUniqueTxResult {
	return invitationsUniqueTxResult{
		result: &transaction.Result{},
	}
}

type invitationsUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p invitationsUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p invitationsUniqueTxResult) IsTx() {}

func (r invitationsUniqueTxResult) Result() (v *InvitationsModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewinvitationsManyTxResult() invitationsManyTxResult {
	return invitationsManyTxResult{
		result: &transaction.Result{},
	}
}

type invitationsManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p invitationsManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p invitationsManyTxResult) IsTx() {}

func (r invitationsManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewprojectsUniqueTxResult() projectsUniqueTxResult {
	return projectsUniqueTxResult{
		result: &transaction.Result{},
	}
}

type projectsUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p projectsUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p projectsUniqueTxResult) IsTx() {}

func (r projectsUniqueTxResult) Result() (v *ProjectsModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewprojectsManyTxResult() projectsManyTxResult {
	return projectsManyTxResult{
		result: &transaction.Result{},
	}
}

type projectsManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p projectsManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p projectsManyTxResult) IsTx() {}

func (r projectsManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewteamsUniqueTxResult() teamsUniqueTxResult {
	return teamsUniqueTxResult{
		result: &transaction.Result{},
	}
}

type teamsUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p teamsUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p teamsUniqueTxResult) IsTx() {}

func (r teamsUniqueTxResult) Result() (v *TeamsModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewteamsManyTxResult() teamsManyTxResult {
	return teamsManyTxResult{
		result: &transaction.Result{},
	}
}

type teamsManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p teamsManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p teamsManyTxResult) IsTx() {}

func (r teamsManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewteamsProjectsUniqueTxResult() teamsProjectsUniqueTxResult {
	return teamsProjectsUniqueTxResult{
		result: &transaction.Result{},
	}
}

type teamsProjectsUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p teamsProjectsUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p teamsProjectsUniqueTxResult) IsTx() {}

func (r teamsProjectsUniqueTxResult) Result() (v *TeamsProjectsModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewteamsProjectsManyTxResult() teamsProjectsManyTxResult {
	return teamsProjectsManyTxResult{
		result: &transaction.Result{},
	}
}

type teamsProjectsManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p teamsProjectsManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p teamsProjectsManyTxResult) IsTx() {}

func (r teamsProjectsManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewteamsUsersUniqueTxResult() teamsUsersUniqueTxResult {
	return teamsUsersUniqueTxResult{
		result: &transaction.Result{},
	}
}

type teamsUsersUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p teamsUsersUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p teamsUsersUniqueTxResult) IsTx() {}

func (r teamsUsersUniqueTxResult) Result() (v *TeamsUsersModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewteamsUsersManyTxResult() teamsUsersManyTxResult {
	return teamsUsersManyTxResult{
		result: &transaction.Result{},
	}
}

type teamsUsersManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p teamsUsersManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p teamsUsersManyTxResult) IsTx() {}

func (r teamsUsersManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.ContactFormSubmissions = contactFormSubmissionsMock{
		mock: m,
	}

	m.Users = usersMock{
		mock: m,
	}

	m.Invitations = invitationsMock{
		mock: m,
	}

	m.Projects = projectsMock{
		mock: m,
	}

	m.Teams = teamsMock{
		mock: m,
	}

	m.TeamsProjects = teamsProjectsMock{
		mock: m,
	}

	m.TeamsUsers = teamsUsersMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	ContactFormSubmissions contactFormSubmissionsMock

	Users usersMock

	Invitations invitationsMock

	Projects projectsMock

	Teams teamsMock

	TeamsProjects teamsProjectsMock

	TeamsUsers teamsUsersMock
}

type contactFormSubmissionsMock struct {
	mock *Mock
}

type ContactFormSubmissionsMockExpectParam interface {
	ExtractQuery() builder.Query
	contactFormSubmissionsModel()
}

func (m *contactFormSubmissionsMock) Expect(query ContactFormSubmissionsMockExpectParam) *contactFormSubmissionsMockExec {
	return &contactFormSubmissionsMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type contactFormSubmissionsMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *contactFormSubmissionsMockExec) Returns(v ContactFormSubmissionsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *contactFormSubmissionsMockExec) ReturnsMany(v []ContactFormSubmissionsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *contactFormSubmissionsMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type usersMock struct {
	mock *Mock
}

type UsersMockExpectParam interface {
	ExtractQuery() builder.Query
	usersModel()
}

func (m *usersMock) Expect(query UsersMockExpectParam) *usersMockExec {
	return &usersMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type usersMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *usersMockExec) Returns(v UsersModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *usersMockExec) ReturnsMany(v []UsersModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *usersMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type invitationsMock struct {
	mock *Mock
}

type InvitationsMockExpectParam interface {
	ExtractQuery() builder.Query
	invitationsModel()
}

func (m *invitationsMock) Expect(query InvitationsMockExpectParam) *invitationsMockExec {
	return &invitationsMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type invitationsMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *invitationsMockExec) Returns(v InvitationsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *invitationsMockExec) ReturnsMany(v []InvitationsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *invitationsMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type projectsMock struct {
	mock *Mock
}

type ProjectsMockExpectParam interface {
	ExtractQuery() builder.Query
	projectsModel()
}

func (m *projectsMock) Expect(query ProjectsMockExpectParam) *projectsMockExec {
	return &projectsMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type projectsMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *projectsMockExec) Returns(v ProjectsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *projectsMockExec) ReturnsMany(v []ProjectsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *projectsMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type teamsMock struct {
	mock *Mock
}

type TeamsMockExpectParam interface {
	ExtractQuery() builder.Query
	teamsModel()
}

func (m *teamsMock) Expect(query TeamsMockExpectParam) *teamsMockExec {
	return &teamsMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type teamsMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *teamsMockExec) Returns(v TeamsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *teamsMockExec) ReturnsMany(v []TeamsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *teamsMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type teamsProjectsMock struct {
	mock *Mock
}

type TeamsProjectsMockExpectParam interface {
	ExtractQuery() builder.Query
	teamsProjectsModel()
}

func (m *teamsProjectsMock) Expect(query TeamsProjectsMockExpectParam) *teamsProjectsMockExec {
	return &teamsProjectsMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type teamsProjectsMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *teamsProjectsMockExec) Returns(v TeamsProjectsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *teamsProjectsMockExec) ReturnsMany(v []TeamsProjectsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *teamsProjectsMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type teamsUsersMock struct {
	mock *Mock
}

type TeamsUsersMockExpectParam interface {
	ExtractQuery() builder.Query
	teamsUsersModel()
}

func (m *teamsUsersMock) Expect(query TeamsUsersMockExpectParam) *teamsUsersMockExec {
	return &teamsUsersMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type teamsUsersMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *teamsUsersMockExec) Returns(v TeamsUsersModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *teamsUsersMockExec) ReturnsMany(v []TeamsUsersModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *teamsUsersMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// ContactFormSubmissionsModel represents the contact_form_submissions model and is a wrapper for accessing fields and methods
type ContactFormSubmissionsModel struct {
	InnerContactFormSubmissions
	RelationsContactFormSubmissions
}

// InnerContactFormSubmissions holds the actual data
type InnerContactFormSubmissions struct {
	ID        string   `json:"id"`
	Name      *string  `json:"name,omitempty"`
	Email     string   `json:"email"`
	Message   string   `json:"message"`
	UserID    *string  `json:"user_id,omitempty"`
	CreatedAt DateTime `json:"created_at"`
	UpdatedAt DateTime `json:"updated_at"`
}

// RawContactFormSubmissionsModel is a struct for contact_form_submissions when used in raw queries
type RawContactFormSubmissionsModel struct {
	ID        RawString   `json:"id"`
	Name      *RawString  `json:"name,omitempty"`
	Email     RawString   `json:"email"`
	Message   RawString   `json:"message"`
	UserID    *RawString  `json:"user_id,omitempty"`
	CreatedAt RawDateTime `json:"created_at"`
	UpdatedAt RawDateTime `json:"updated_at"`
}

// RelationsContactFormSubmissions holds the relation data separately
type RelationsContactFormSubmissions struct {
	Users *UsersModel `json:"users,omitempty"`
}

func (r ContactFormSubmissionsModel) Name() (value string, ok bool) {
	if r.InnerContactFormSubmissions.Name == nil {
		return value, false
	}
	return *r.InnerContactFormSubmissions.Name, true
}

func (r ContactFormSubmissionsModel) UserID() (value string, ok bool) {
	if r.InnerContactFormSubmissions.UserID == nil {
		return value, false
	}
	return *r.InnerContactFormSubmissions.UserID, true
}

func (r ContactFormSubmissionsModel) Users() (value *UsersModel, ok bool) {
	if r.RelationsContactFormSubmissions.Users == nil {
		return value, false
	}
	return r.RelationsContactFormSubmissions.Users, true
}

// UsersModel represents the users model and is a wrapper for accessing fields and methods
type UsersModel struct {
	InnerUsers
	RelationsUsers
}

// InnerUsers holds the actual data
type InnerUsers struct {
	ID                    string   `json:"id"`
	Email                 string   `json:"email"`
	HashedPassword        string   `json:"hashed_password"`
	CreatedAt             DateTime `json:"created_at"`
	UpdatedAt             DateTime `json:"updated_at"`
	EmailVerified         bool     `json:"email_verified"`
	EmailVerificationCode *string  `json:"email_verification_code,omitempty"`
	PasswordResetCode     *string  `json:"password_reset_code,omitempty"`
	PasswordAt            DateTime `json:"password_at"`
	DisplayName           *string  `json:"display_name,omitempty"`
	AvatarFileKey         *string  `json:"avatar_file_key,omitempty"`
}

// RawUsersModel is a struct for users when used in raw queries
type RawUsersModel struct {
	ID                    RawString   `json:"id"`
	Email                 RawString   `json:"email"`
	HashedPassword        RawString   `json:"hashed_password"`
	CreatedAt             RawDateTime `json:"created_at"`
	UpdatedAt             RawDateTime `json:"updated_at"`
	EmailVerified         RawBoolean  `json:"email_verified"`
	EmailVerificationCode *RawString  `json:"email_verification_code,omitempty"`
	PasswordResetCode     *RawString  `json:"password_reset_code,omitempty"`
	PasswordAt            RawDateTime `json:"password_at"`
	DisplayName           *RawString  `json:"display_name,omitempty"`
	AvatarFileKey         *RawString  `json:"avatar_file_key,omitempty"`
}

// RelationsUsers holds the relation data separately
type RelationsUsers struct {
	ContactFormSubmissions []ContactFormSubmissionsModel `json:"contact_form_submissions,omitempty"`
	TeamsUsers             []TeamsUsersModel             `json:"teams_users,omitempty"`
}

func (r UsersModel) EmailVerificationCode() (value string, ok bool) {
	if r.InnerUsers.EmailVerificationCode == nil {
		return value, false
	}
	return *r.InnerUsers.EmailVerificationCode, true
}

func (r UsersModel) PasswordResetCode() (value string, ok bool) {
	if r.InnerUsers.PasswordResetCode == nil {
		return value, false
	}
	return *r.InnerUsers.PasswordResetCode, true
}

func (r UsersModel) DisplayName() (value string, ok bool) {
	if r.InnerUsers.DisplayName == nil {
		return value, false
	}
	return *r.InnerUsers.DisplayName, true
}

func (r UsersModel) AvatarFileKey() (value string, ok bool) {
	if r.InnerUsers.AvatarFileKey == nil {
		return value, false
	}
	return *r.InnerUsers.AvatarFileKey, true
}

func (r UsersModel) ContactFormSubmissions() (value []ContactFormSubmissionsModel) {
	if r.RelationsUsers.ContactFormSubmissions == nil {
		panic("attempted to access contactFormSubmissions but did not fetch it using the .With() syntax")
	}
	return r.RelationsUsers.ContactFormSubmissions
}

func (r UsersModel) TeamsUsers() (value []TeamsUsersModel) {
	if r.RelationsUsers.TeamsUsers == nil {
		panic("attempted to access teamsUsers but did not fetch it using the .With() syntax")
	}
	return r.RelationsUsers.TeamsUsers
}

// InvitationsModel represents the invitations model and is a wrapper for accessing fields and methods
type InvitationsModel struct {
	InnerInvitations
	RelationsInvitations
}

// InnerInvitations holds the actual data
type InnerInvitations struct {
	TeamID    string   `json:"team_id"`
	Email     string   `json:"email"`
	CreatedAt DateTime `json:"created_at"`
}

// RawInvitationsModel is a struct for invitations when used in raw queries
type RawInvitationsModel struct {
	TeamID    RawString   `json:"team_id"`
	Email     RawString   `json:"email"`
	CreatedAt RawDateTime `json:"created_at"`
}

// RelationsInvitations holds the relation data separately
type RelationsInvitations struct {
	Teams *TeamsModel `json:"teams,omitempty"`
}

func (r InvitationsModel) Teams() (value *TeamsModel) {
	if r.RelationsInvitations.Teams == nil {
		panic("attempted to access teams but did not fetch it using the .With() syntax")
	}
	return r.RelationsInvitations.Teams
}

// ProjectsModel represents the projects model and is a wrapper for accessing fields and methods
type ProjectsModel struct {
	InnerProjects
	RelationsProjects
}

// InnerProjects holds the actual data
type InnerProjects struct {
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	CreatedAt DateTime `json:"created_at"`
	UpdatedAt DateTime `json:"updated_at"`
}

// RawProjectsModel is a struct for projects when used in raw queries
type RawProjectsModel struct {
	ID        RawString   `json:"id"`
	Name      RawString   `json:"name"`
	CreatedAt RawDateTime `json:"created_at"`
	UpdatedAt RawDateTime `json:"updated_at"`
}

// RelationsProjects holds the relation data separately
type RelationsProjects struct {
	TeamsProjects []TeamsProjectsModel `json:"teams_projects,omitempty"`
}

func (r ProjectsModel) TeamsProjects() (value []TeamsProjectsModel) {
	if r.RelationsProjects.TeamsProjects == nil {
		panic("attempted to access teamsProjects but did not fetch it using the .With() syntax")
	}
	return r.RelationsProjects.TeamsProjects
}

// TeamsModel represents the teams model and is a wrapper for accessing fields and methods
type TeamsModel struct {
	InnerTeams
	RelationsTeams
}

// InnerTeams holds the actual data
type InnerTeams struct {
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	CreatedAt DateTime `json:"created_at"`
	UpdatedAt DateTime `json:"updated_at"`
}

// RawTeamsModel is a struct for teams when used in raw queries
type RawTeamsModel struct {
	ID        RawString   `json:"id"`
	Name      RawString   `json:"name"`
	CreatedAt RawDateTime `json:"created_at"`
	UpdatedAt RawDateTime `json:"updated_at"`
}

// RelationsTeams holds the relation data separately
type RelationsTeams struct {
	Invitations   []InvitationsModel   `json:"invitations,omitempty"`
	TeamsProjects []TeamsProjectsModel `json:"teams_projects,omitempty"`
	TeamsUsers    []TeamsUsersModel    `json:"teams_users,omitempty"`
}

func (r TeamsModel) Invitations() (value []InvitationsModel) {
	if r.RelationsTeams.Invitations == nil {
		panic("attempted to access invitations but did not fetch it using the .With() syntax")
	}
	return r.RelationsTeams.Invitations
}

func (r TeamsModel) TeamsProjects() (value []TeamsProjectsModel) {
	if r.RelationsTeams.TeamsProjects == nil {
		panic("attempted to access teamsProjects but did not fetch it using the .With() syntax")
	}
	return r.RelationsTeams.TeamsProjects
}

func (r TeamsModel) TeamsUsers() (value []TeamsUsersModel) {
	if r.RelationsTeams.TeamsUsers == nil {
		panic("attempted to access teamsUsers but did not fetch it using the .With() syntax")
	}
	return r.RelationsTeams.TeamsUsers
}

// TeamsProjectsModel represents the teams_projects model and is a wrapper for accessing fields and methods
type TeamsProjectsModel struct {
	InnerTeamsProjects
	RelationsTeamsProjects
}

// InnerTeamsProjects holds the actual data
type InnerTeamsProjects struct {
	ProjectID string   `json:"project_id"`
	TeamID    string   `json:"team_id"`
	CreatedAt DateTime `json:"created_at"`
}

// RawTeamsProjectsModel is a struct for teams_projects when used in raw queries
type RawTeamsProjectsModel struct {
	ProjectID RawString   `json:"project_id"`
	TeamID    RawString   `json:"team_id"`
	CreatedAt RawDateTime `json:"created_at"`
}

// RelationsTeamsProjects holds the relation data separately
type RelationsTeamsProjects struct {
	Projects *ProjectsModel `json:"projects,omitempty"`
	Teams    *TeamsModel    `json:"teams,omitempty"`
}

func (r TeamsProjectsModel) Projects() (value *ProjectsModel) {
	if r.RelationsTeamsProjects.Projects == nil {
		panic("attempted to access projects but did not fetch it using the .With() syntax")
	}
	return r.RelationsTeamsProjects.Projects
}

func (r TeamsProjectsModel) Teams() (value *TeamsModel) {
	if r.RelationsTeamsProjects.Teams == nil {
		panic("attempted to access teams but did not fetch it using the .With() syntax")
	}
	return r.RelationsTeamsProjects.Teams
}

// TeamsUsersModel represents the teams_users model and is a wrapper for accessing fields and methods
type TeamsUsersModel struct {
	InnerTeamsUsers
	RelationsTeamsUsers
}

// InnerTeamsUsers holds the actual data
type InnerTeamsUsers struct {
	TeamID    string   `json:"team_id"`
	UserID    string   `json:"user_id"`
	CreatedAt DateTime `json:"created_at"`
}

// RawTeamsUsersModel is a struct for teams_users when used in raw queries
type RawTeamsUsersModel struct {
	TeamID    RawString   `json:"team_id"`
	UserID    RawString   `json:"user_id"`
	CreatedAt RawDateTime `json:"created_at"`
}

// RelationsTeamsUsers holds the relation data separately
type RelationsTeamsUsers struct {
	Teams *TeamsModel `json:"teams,omitempty"`
	Users *UsersModel `json:"users,omitempty"`
}

func (r TeamsUsersModel) Teams() (value *TeamsModel) {
	if r.RelationsTeamsUsers.Teams == nil {
		panic("attempted to access teams but did not fetch it using the .With() syntax")
	}
	return r.RelationsTeamsUsers.Teams
}

func (r TeamsUsersModel) Users() (value *UsersModel) {
	if r.RelationsTeamsUsers.Users == nil {
		panic("attempted to access users but did not fetch it using the .With() syntax")
	}
	return r.RelationsTeamsUsers.Users
}

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type contactFormSubmissionsActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var contactFormSubmissionsOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "email"},
	{Name: "message"},
	{Name: "user_id"},
	{Name: "created_at"},
	{Name: "updated_at"},
}

type ContactFormSubmissionsRelationWith interface {
	getQuery() builder.Query
	with()
	contactFormSubmissionsRelation()
}

type ContactFormSubmissionsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
}

type contactFormSubmissionsDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsDefaultParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsDefaultParam) contactFormSubmissionsModel() {}

type ContactFormSubmissionsOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
}

type contactFormSubmissionsOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsOrderByParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsOrderByParam) contactFormSubmissionsModel() {}

type ContactFormSubmissionsCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	isCursor()
}

type contactFormSubmissionsCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsCursorParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsCursorParam) isCursor() {}

func (p contactFormSubmissionsCursorParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsCursorParam) contactFormSubmissionsModel() {}

type ContactFormSubmissionsParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	contactFormSubmissionsModel()
}

type contactFormSubmissionsParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsParamUnique) contactFormSubmissionsModel() {}

func (contactFormSubmissionsParamUnique) unique() {}

func (p contactFormSubmissionsParamUnique) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsParamUnique) getQuery() builder.Query {
	return p.query
}

type ContactFormSubmissionsEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	contactFormSubmissionsModel()
}

type contactFormSubmissionsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsEqualsParam) contactFormSubmissionsModel() {}

func (contactFormSubmissionsEqualsParam) equals() {}

func (p contactFormSubmissionsEqualsParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsEqualsParam) getQuery() builder.Query {
	return p.query
}

type ContactFormSubmissionsEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	contactFormSubmissionsModel()
}

type contactFormSubmissionsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsEqualsUniqueParam) contactFormSubmissionsModel() {}

func (contactFormSubmissionsEqualsUniqueParam) unique() {}
func (contactFormSubmissionsEqualsUniqueParam) equals() {}

func (p contactFormSubmissionsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type ContactFormSubmissionsSetParam interface {
	field() builder.Field
	settable()
	contactFormSubmissionsModel()
}

type contactFormSubmissionsSetParam struct {
	data builder.Field
}

func (contactFormSubmissionsSetParam) settable() {}

func (p contactFormSubmissionsSetParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsSetParam) contactFormSubmissionsModel() {}

type ContactFormSubmissionsWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	contactFormSubmissionsModel()
	idField()
}

type ContactFormSubmissionsWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	idField()
}

type contactFormSubmissionsWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaIDSetParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaIDSetParam) idField() {}

type ContactFormSubmissionsWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	idField()
}

type contactFormSubmissionsWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaIDEqualsParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaIDEqualsParam) idField() {}

func (contactFormSubmissionsWithPrismaIDSetParam) settable()  {}
func (contactFormSubmissionsWithPrismaIDEqualsParam) equals() {}

type contactFormSubmissionsWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaIDEqualsUniqueParam) contactFormSubmissionsModel() {}
func (p contactFormSubmissionsWithPrismaIDEqualsUniqueParam) idField()                     {}

func (contactFormSubmissionsWithPrismaIDEqualsUniqueParam) unique() {}
func (contactFormSubmissionsWithPrismaIDEqualsUniqueParam) equals() {}

type ContactFormSubmissionsWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	contactFormSubmissionsModel()
	nameField()
}

type ContactFormSubmissionsWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	nameField()
}

type contactFormSubmissionsWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaNameSetParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaNameSetParam) nameField() {}

type ContactFormSubmissionsWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	nameField()
}

type contactFormSubmissionsWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaNameEqualsParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaNameEqualsParam) nameField() {}

func (contactFormSubmissionsWithPrismaNameSetParam) settable()  {}
func (contactFormSubmissionsWithPrismaNameEqualsParam) equals() {}

type contactFormSubmissionsWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaNameEqualsUniqueParam) contactFormSubmissionsModel() {}
func (p contactFormSubmissionsWithPrismaNameEqualsUniqueParam) nameField()                   {}

func (contactFormSubmissionsWithPrismaNameEqualsUniqueParam) unique() {}
func (contactFormSubmissionsWithPrismaNameEqualsUniqueParam) equals() {}

type ContactFormSubmissionsWithPrismaEmailEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	contactFormSubmissionsModel()
	emailField()
}

type ContactFormSubmissionsWithPrismaEmailSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	emailField()
}

type contactFormSubmissionsWithPrismaEmailSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaEmailSetParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaEmailSetParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaEmailSetParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaEmailSetParam) emailField() {}

type ContactFormSubmissionsWithPrismaEmailWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	emailField()
}

type contactFormSubmissionsWithPrismaEmailEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaEmailEqualsParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaEmailEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaEmailEqualsParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaEmailEqualsParam) emailField() {}

func (contactFormSubmissionsWithPrismaEmailSetParam) settable()  {}
func (contactFormSubmissionsWithPrismaEmailEqualsParam) equals() {}

type contactFormSubmissionsWithPrismaEmailEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaEmailEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaEmailEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaEmailEqualsUniqueParam) contactFormSubmissionsModel() {}
func (p contactFormSubmissionsWithPrismaEmailEqualsUniqueParam) emailField()                  {}

func (contactFormSubmissionsWithPrismaEmailEqualsUniqueParam) unique() {}
func (contactFormSubmissionsWithPrismaEmailEqualsUniqueParam) equals() {}

type ContactFormSubmissionsWithPrismaMessageEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	contactFormSubmissionsModel()
	messageField()
}

type ContactFormSubmissionsWithPrismaMessageSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	messageField()
}

type contactFormSubmissionsWithPrismaMessageSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaMessageSetParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaMessageSetParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaMessageSetParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaMessageSetParam) messageField() {}

type ContactFormSubmissionsWithPrismaMessageWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	messageField()
}

type contactFormSubmissionsWithPrismaMessageEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaMessageEqualsParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaMessageEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaMessageEqualsParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaMessageEqualsParam) messageField() {}

func (contactFormSubmissionsWithPrismaMessageSetParam) settable()  {}
func (contactFormSubmissionsWithPrismaMessageEqualsParam) equals() {}

type contactFormSubmissionsWithPrismaMessageEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaMessageEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaMessageEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaMessageEqualsUniqueParam) contactFormSubmissionsModel() {}
func (p contactFormSubmissionsWithPrismaMessageEqualsUniqueParam) messageField()                {}

func (contactFormSubmissionsWithPrismaMessageEqualsUniqueParam) unique() {}
func (contactFormSubmissionsWithPrismaMessageEqualsUniqueParam) equals() {}

type ContactFormSubmissionsWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	contactFormSubmissionsModel()
	userIDField()
}

type ContactFormSubmissionsWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	userIDField()
}

type contactFormSubmissionsWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaUserIDSetParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaUserIDSetParam) userIDField() {}

type ContactFormSubmissionsWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	userIDField()
}

type contactFormSubmissionsWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaUserIDEqualsParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaUserIDEqualsParam) userIDField() {}

func (contactFormSubmissionsWithPrismaUserIDSetParam) settable()  {}
func (contactFormSubmissionsWithPrismaUserIDEqualsParam) equals() {}

type contactFormSubmissionsWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaUserIDEqualsUniqueParam) contactFormSubmissionsModel() {}
func (p contactFormSubmissionsWithPrismaUserIDEqualsUniqueParam) userIDField()                 {}

func (contactFormSubmissionsWithPrismaUserIDEqualsUniqueParam) unique() {}
func (contactFormSubmissionsWithPrismaUserIDEqualsUniqueParam) equals() {}

type ContactFormSubmissionsWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	contactFormSubmissionsModel()
	createdAtField()
}

type ContactFormSubmissionsWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	createdAtField()
}

type contactFormSubmissionsWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaCreatedAtSetParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaCreatedAtSetParam) createdAtField() {}

type ContactFormSubmissionsWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	createdAtField()
}

type contactFormSubmissionsWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaCreatedAtEqualsParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (contactFormSubmissionsWithPrismaCreatedAtSetParam) settable()  {}
func (contactFormSubmissionsWithPrismaCreatedAtEqualsParam) equals() {}

type contactFormSubmissionsWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaCreatedAtEqualsUniqueParam) contactFormSubmissionsModel() {}
func (p contactFormSubmissionsWithPrismaCreatedAtEqualsUniqueParam) createdAtField()              {}

func (contactFormSubmissionsWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (contactFormSubmissionsWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type ContactFormSubmissionsWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	contactFormSubmissionsModel()
	updatedAtField()
}

type ContactFormSubmissionsWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	updatedAtField()
}

type contactFormSubmissionsWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaUpdatedAtSetParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaUpdatedAtSetParam) updatedAtField() {}

type ContactFormSubmissionsWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	updatedAtField()
}

type contactFormSubmissionsWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaUpdatedAtEqualsParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (contactFormSubmissionsWithPrismaUpdatedAtSetParam) settable()  {}
func (contactFormSubmissionsWithPrismaUpdatedAtEqualsParam) equals() {}

type contactFormSubmissionsWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaUpdatedAtEqualsUniqueParam) contactFormSubmissionsModel() {}
func (p contactFormSubmissionsWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField()              {}

func (contactFormSubmissionsWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (contactFormSubmissionsWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type ContactFormSubmissionsWithPrismaUsersEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	contactFormSubmissionsModel()
	usersField()
}

type ContactFormSubmissionsWithPrismaUsersSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	usersField()
}

type contactFormSubmissionsWithPrismaUsersSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaUsersSetParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaUsersSetParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaUsersSetParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaUsersSetParam) usersField() {}

type ContactFormSubmissionsWithPrismaUsersWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	contactFormSubmissionsModel()
	usersField()
}

type contactFormSubmissionsWithPrismaUsersEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaUsersEqualsParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaUsersEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaUsersEqualsParam) contactFormSubmissionsModel() {}

func (p contactFormSubmissionsWithPrismaUsersEqualsParam) usersField() {}

func (contactFormSubmissionsWithPrismaUsersSetParam) settable()  {}
func (contactFormSubmissionsWithPrismaUsersEqualsParam) equals() {}

type contactFormSubmissionsWithPrismaUsersEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p contactFormSubmissionsWithPrismaUsersEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p contactFormSubmissionsWithPrismaUsersEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p contactFormSubmissionsWithPrismaUsersEqualsUniqueParam) contactFormSubmissionsModel() {}
func (p contactFormSubmissionsWithPrismaUsersEqualsUniqueParam) usersField()                  {}

func (contactFormSubmissionsWithPrismaUsersEqualsUniqueParam) unique() {}
func (contactFormSubmissionsWithPrismaUsersEqualsUniqueParam) equals() {}

type usersActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var usersOutput = []builder.Output{
	{Name: "id"},
	{Name: "email"},
	{Name: "hashed_password"},
	{Name: "created_at"},
	{Name: "updated_at"},
	{Name: "email_verified"},
	{Name: "email_verification_code"},
	{Name: "password_reset_code"},
	{Name: "password_at"},
	{Name: "display_name"},
	{Name: "avatar_file_key"},
}

type UsersRelationWith interface {
	getQuery() builder.Query
	with()
	usersRelation()
}

type UsersWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
}

type usersDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersDefaultParam) field() builder.Field {
	return p.data
}

func (p usersDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p usersDefaultParam) usersModel() {}

type UsersOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
}

type usersOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersOrderByParam) field() builder.Field {
	return p.data
}

func (p usersOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p usersOrderByParam) usersModel() {}

type UsersCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	isCursor()
}

type usersCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersCursorParam) field() builder.Field {
	return p.data
}

func (p usersCursorParam) isCursor() {}

func (p usersCursorParam) getQuery() builder.Query {
	return p.query
}

func (p usersCursorParam) usersModel() {}

type UsersParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	usersModel()
}

type usersParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p usersParamUnique) usersModel() {}

func (usersParamUnique) unique() {}

func (p usersParamUnique) field() builder.Field {
	return p.data
}

func (p usersParamUnique) getQuery() builder.Query {
	return p.query
}

type UsersEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
}

type usersEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersEqualsParam) usersModel() {}

func (usersEqualsParam) equals() {}

func (p usersEqualsParam) field() builder.Field {
	return p.data
}

func (p usersEqualsParam) getQuery() builder.Query {
	return p.query
}

type UsersEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	usersModel()
}

type usersEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersEqualsUniqueParam) usersModel() {}

func (usersEqualsUniqueParam) unique() {}
func (usersEqualsUniqueParam) equals() {}

func (p usersEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UsersSetParam interface {
	field() builder.Field
	settable()
	usersModel()
}

type usersSetParam struct {
	data builder.Field
}

func (usersSetParam) settable() {}

func (p usersSetParam) field() builder.Field {
	return p.data
}

func (p usersSetParam) usersModel() {}

type UsersWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	idField()
}

type UsersWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	idField()
}

type usersWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIDSetParam) usersModel() {}

func (p usersWithPrismaIDSetParam) idField() {}

type UsersWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	idField()
}

type usersWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIDEqualsParam) usersModel() {}

func (p usersWithPrismaIDEqualsParam) idField() {}

func (usersWithPrismaIDSetParam) settable()  {}
func (usersWithPrismaIDEqualsParam) equals() {}

type usersWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIDEqualsUniqueParam) usersModel() {}
func (p usersWithPrismaIDEqualsUniqueParam) idField()    {}

func (usersWithPrismaIDEqualsUniqueParam) unique() {}
func (usersWithPrismaIDEqualsUniqueParam) equals() {}

type UsersWithPrismaEmailEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	emailField()
}

type UsersWithPrismaEmailSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	emailField()
}

type usersWithPrismaEmailSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailSetParam) usersModel() {}

func (p usersWithPrismaEmailSetParam) emailField() {}

type UsersWithPrismaEmailWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	emailField()
}

type usersWithPrismaEmailEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailEqualsParam) usersModel() {}

func (p usersWithPrismaEmailEqualsParam) emailField() {}

func (usersWithPrismaEmailSetParam) settable()  {}
func (usersWithPrismaEmailEqualsParam) equals() {}

type usersWithPrismaEmailEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailEqualsUniqueParam) usersModel() {}
func (p usersWithPrismaEmailEqualsUniqueParam) emailField() {}

func (usersWithPrismaEmailEqualsUniqueParam) unique() {}
func (usersWithPrismaEmailEqualsUniqueParam) equals() {}

type UsersWithPrismaHashedPasswordEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	hashedPasswordField()
}

type UsersWithPrismaHashedPasswordSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	hashedPasswordField()
}

type usersWithPrismaHashedPasswordSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaHashedPasswordSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaHashedPasswordSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaHashedPasswordSetParam) usersModel() {}

func (p usersWithPrismaHashedPasswordSetParam) hashedPasswordField() {}

type UsersWithPrismaHashedPasswordWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	hashedPasswordField()
}

type usersWithPrismaHashedPasswordEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaHashedPasswordEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaHashedPasswordEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaHashedPasswordEqualsParam) usersModel() {}

func (p usersWithPrismaHashedPasswordEqualsParam) hashedPasswordField() {}

func (usersWithPrismaHashedPasswordSetParam) settable()  {}
func (usersWithPrismaHashedPasswordEqualsParam) equals() {}

type usersWithPrismaHashedPasswordEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaHashedPasswordEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaHashedPasswordEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaHashedPasswordEqualsUniqueParam) usersModel()          {}
func (p usersWithPrismaHashedPasswordEqualsUniqueParam) hashedPasswordField() {}

func (usersWithPrismaHashedPasswordEqualsUniqueParam) unique() {}
func (usersWithPrismaHashedPasswordEqualsUniqueParam) equals() {}

type UsersWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	createdAtField()
}

type UsersWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	createdAtField()
}

type usersWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaCreatedAtSetParam) usersModel() {}

func (p usersWithPrismaCreatedAtSetParam) createdAtField() {}

type UsersWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	createdAtField()
}

type usersWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaCreatedAtEqualsParam) usersModel() {}

func (p usersWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (usersWithPrismaCreatedAtSetParam) settable()  {}
func (usersWithPrismaCreatedAtEqualsParam) equals() {}

type usersWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaCreatedAtEqualsUniqueParam) usersModel()     {}
func (p usersWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (usersWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (usersWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type UsersWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	updatedAtField()
}

type UsersWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	updatedAtField()
}

type usersWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUpdatedAtSetParam) usersModel() {}

func (p usersWithPrismaUpdatedAtSetParam) updatedAtField() {}

type UsersWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	updatedAtField()
}

type usersWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUpdatedAtEqualsParam) usersModel() {}

func (p usersWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (usersWithPrismaUpdatedAtSetParam) settable()  {}
func (usersWithPrismaUpdatedAtEqualsParam) equals() {}

type usersWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUpdatedAtEqualsUniqueParam) usersModel()     {}
func (p usersWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (usersWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (usersWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type UsersWithPrismaEmailVerifiedEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	emailVerifiedField()
}

type UsersWithPrismaEmailVerifiedSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	emailVerifiedField()
}

type usersWithPrismaEmailVerifiedSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailVerifiedSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailVerifiedSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailVerifiedSetParam) usersModel() {}

func (p usersWithPrismaEmailVerifiedSetParam) emailVerifiedField() {}

type UsersWithPrismaEmailVerifiedWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	emailVerifiedField()
}

type usersWithPrismaEmailVerifiedEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailVerifiedEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailVerifiedEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailVerifiedEqualsParam) usersModel() {}

func (p usersWithPrismaEmailVerifiedEqualsParam) emailVerifiedField() {}

func (usersWithPrismaEmailVerifiedSetParam) settable()  {}
func (usersWithPrismaEmailVerifiedEqualsParam) equals() {}

type usersWithPrismaEmailVerifiedEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailVerifiedEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailVerifiedEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailVerifiedEqualsUniqueParam) usersModel()         {}
func (p usersWithPrismaEmailVerifiedEqualsUniqueParam) emailVerifiedField() {}

func (usersWithPrismaEmailVerifiedEqualsUniqueParam) unique() {}
func (usersWithPrismaEmailVerifiedEqualsUniqueParam) equals() {}

type UsersWithPrismaEmailVerificationCodeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	emailVerificationCodeField()
}

type UsersWithPrismaEmailVerificationCodeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	emailVerificationCodeField()
}

type usersWithPrismaEmailVerificationCodeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailVerificationCodeSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailVerificationCodeSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailVerificationCodeSetParam) usersModel() {}

func (p usersWithPrismaEmailVerificationCodeSetParam) emailVerificationCodeField() {}

type UsersWithPrismaEmailVerificationCodeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	emailVerificationCodeField()
}

type usersWithPrismaEmailVerificationCodeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailVerificationCodeEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailVerificationCodeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailVerificationCodeEqualsParam) usersModel() {}

func (p usersWithPrismaEmailVerificationCodeEqualsParam) emailVerificationCodeField() {}

func (usersWithPrismaEmailVerificationCodeSetParam) settable()  {}
func (usersWithPrismaEmailVerificationCodeEqualsParam) equals() {}

type usersWithPrismaEmailVerificationCodeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailVerificationCodeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailVerificationCodeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailVerificationCodeEqualsUniqueParam) usersModel()                 {}
func (p usersWithPrismaEmailVerificationCodeEqualsUniqueParam) emailVerificationCodeField() {}

func (usersWithPrismaEmailVerificationCodeEqualsUniqueParam) unique() {}
func (usersWithPrismaEmailVerificationCodeEqualsUniqueParam) equals() {}

type UsersWithPrismaPasswordResetCodeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	passwordResetCodeField()
}

type UsersWithPrismaPasswordResetCodeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	passwordResetCodeField()
}

type usersWithPrismaPasswordResetCodeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaPasswordResetCodeSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaPasswordResetCodeSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaPasswordResetCodeSetParam) usersModel() {}

func (p usersWithPrismaPasswordResetCodeSetParam) passwordResetCodeField() {}

type UsersWithPrismaPasswordResetCodeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	passwordResetCodeField()
}

type usersWithPrismaPasswordResetCodeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaPasswordResetCodeEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaPasswordResetCodeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaPasswordResetCodeEqualsParam) usersModel() {}

func (p usersWithPrismaPasswordResetCodeEqualsParam) passwordResetCodeField() {}

func (usersWithPrismaPasswordResetCodeSetParam) settable()  {}
func (usersWithPrismaPasswordResetCodeEqualsParam) equals() {}

type usersWithPrismaPasswordResetCodeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaPasswordResetCodeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaPasswordResetCodeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaPasswordResetCodeEqualsUniqueParam) usersModel()             {}
func (p usersWithPrismaPasswordResetCodeEqualsUniqueParam) passwordResetCodeField() {}

func (usersWithPrismaPasswordResetCodeEqualsUniqueParam) unique() {}
func (usersWithPrismaPasswordResetCodeEqualsUniqueParam) equals() {}

type UsersWithPrismaPasswordAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	passwordAtField()
}

type UsersWithPrismaPasswordAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	passwordAtField()
}

type usersWithPrismaPasswordAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaPasswordAtSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaPasswordAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaPasswordAtSetParam) usersModel() {}

func (p usersWithPrismaPasswordAtSetParam) passwordAtField() {}

type UsersWithPrismaPasswordAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	passwordAtField()
}

type usersWithPrismaPasswordAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaPasswordAtEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaPasswordAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaPasswordAtEqualsParam) usersModel() {}

func (p usersWithPrismaPasswordAtEqualsParam) passwordAtField() {}

func (usersWithPrismaPasswordAtSetParam) settable()  {}
func (usersWithPrismaPasswordAtEqualsParam) equals() {}

type usersWithPrismaPasswordAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaPasswordAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaPasswordAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaPasswordAtEqualsUniqueParam) usersModel()      {}
func (p usersWithPrismaPasswordAtEqualsUniqueParam) passwordAtField() {}

func (usersWithPrismaPasswordAtEqualsUniqueParam) unique() {}
func (usersWithPrismaPasswordAtEqualsUniqueParam) equals() {}

type UsersWithPrismaDisplayNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	displayNameField()
}

type UsersWithPrismaDisplayNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	displayNameField()
}

type usersWithPrismaDisplayNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaDisplayNameSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaDisplayNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaDisplayNameSetParam) usersModel() {}

func (p usersWithPrismaDisplayNameSetParam) displayNameField() {}

type UsersWithPrismaDisplayNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	displayNameField()
}

type usersWithPrismaDisplayNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaDisplayNameEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaDisplayNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaDisplayNameEqualsParam) usersModel() {}

func (p usersWithPrismaDisplayNameEqualsParam) displayNameField() {}

func (usersWithPrismaDisplayNameSetParam) settable()  {}
func (usersWithPrismaDisplayNameEqualsParam) equals() {}

type usersWithPrismaDisplayNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaDisplayNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaDisplayNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaDisplayNameEqualsUniqueParam) usersModel()       {}
func (p usersWithPrismaDisplayNameEqualsUniqueParam) displayNameField() {}

func (usersWithPrismaDisplayNameEqualsUniqueParam) unique() {}
func (usersWithPrismaDisplayNameEqualsUniqueParam) equals() {}

type UsersWithPrismaAvatarFileKeyEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	avatarFileKeyField()
}

type UsersWithPrismaAvatarFileKeySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	avatarFileKeyField()
}

type usersWithPrismaAvatarFileKeySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaAvatarFileKeySetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaAvatarFileKeySetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaAvatarFileKeySetParam) usersModel() {}

func (p usersWithPrismaAvatarFileKeySetParam) avatarFileKeyField() {}

type UsersWithPrismaAvatarFileKeyWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	avatarFileKeyField()
}

type usersWithPrismaAvatarFileKeyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaAvatarFileKeyEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaAvatarFileKeyEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaAvatarFileKeyEqualsParam) usersModel() {}

func (p usersWithPrismaAvatarFileKeyEqualsParam) avatarFileKeyField() {}

func (usersWithPrismaAvatarFileKeySetParam) settable()  {}
func (usersWithPrismaAvatarFileKeyEqualsParam) equals() {}

type usersWithPrismaAvatarFileKeyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaAvatarFileKeyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaAvatarFileKeyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaAvatarFileKeyEqualsUniqueParam) usersModel()         {}
func (p usersWithPrismaAvatarFileKeyEqualsUniqueParam) avatarFileKeyField() {}

func (usersWithPrismaAvatarFileKeyEqualsUniqueParam) unique() {}
func (usersWithPrismaAvatarFileKeyEqualsUniqueParam) equals() {}

type UsersWithPrismaContactFormSubmissionsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	contactFormSubmissionsField()
}

type UsersWithPrismaContactFormSubmissionsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	contactFormSubmissionsField()
}

type usersWithPrismaContactFormSubmissionsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaContactFormSubmissionsSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaContactFormSubmissionsSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaContactFormSubmissionsSetParam) usersModel() {}

func (p usersWithPrismaContactFormSubmissionsSetParam) contactFormSubmissionsField() {}

type UsersWithPrismaContactFormSubmissionsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	contactFormSubmissionsField()
}

type usersWithPrismaContactFormSubmissionsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaContactFormSubmissionsEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaContactFormSubmissionsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaContactFormSubmissionsEqualsParam) usersModel() {}

func (p usersWithPrismaContactFormSubmissionsEqualsParam) contactFormSubmissionsField() {}

func (usersWithPrismaContactFormSubmissionsSetParam) settable()  {}
func (usersWithPrismaContactFormSubmissionsEqualsParam) equals() {}

type usersWithPrismaContactFormSubmissionsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaContactFormSubmissionsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaContactFormSubmissionsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaContactFormSubmissionsEqualsUniqueParam) usersModel()                  {}
func (p usersWithPrismaContactFormSubmissionsEqualsUniqueParam) contactFormSubmissionsField() {}

func (usersWithPrismaContactFormSubmissionsEqualsUniqueParam) unique() {}
func (usersWithPrismaContactFormSubmissionsEqualsUniqueParam) equals() {}

type UsersWithPrismaTeamsUsersEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	teamsUsersField()
}

type UsersWithPrismaTeamsUsersSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	teamsUsersField()
}

type usersWithPrismaTeamsUsersSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaTeamsUsersSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaTeamsUsersSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaTeamsUsersSetParam) usersModel() {}

func (p usersWithPrismaTeamsUsersSetParam) teamsUsersField() {}

type UsersWithPrismaTeamsUsersWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	teamsUsersField()
}

type usersWithPrismaTeamsUsersEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaTeamsUsersEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaTeamsUsersEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaTeamsUsersEqualsParam) usersModel() {}

func (p usersWithPrismaTeamsUsersEqualsParam) teamsUsersField() {}

func (usersWithPrismaTeamsUsersSetParam) settable()  {}
func (usersWithPrismaTeamsUsersEqualsParam) equals() {}

type usersWithPrismaTeamsUsersEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaTeamsUsersEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaTeamsUsersEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaTeamsUsersEqualsUniqueParam) usersModel()      {}
func (p usersWithPrismaTeamsUsersEqualsUniqueParam) teamsUsersField() {}

func (usersWithPrismaTeamsUsersEqualsUniqueParam) unique() {}
func (usersWithPrismaTeamsUsersEqualsUniqueParam) equals() {}

type invitationsActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var invitationsOutput = []builder.Output{
	{Name: "team_id"},
	{Name: "email"},
	{Name: "created_at"},
}

type InvitationsRelationWith interface {
	getQuery() builder.Query
	with()
	invitationsRelation()
}

type InvitationsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	invitationsModel()
}

type invitationsDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsDefaultParam) field() builder.Field {
	return p.data
}

func (p invitationsDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsDefaultParam) invitationsModel() {}

type InvitationsOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	invitationsModel()
}

type invitationsOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsOrderByParam) field() builder.Field {
	return p.data
}

func (p invitationsOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsOrderByParam) invitationsModel() {}

type InvitationsCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	invitationsModel()
	isCursor()
}

type invitationsCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsCursorParam) field() builder.Field {
	return p.data
}

func (p invitationsCursorParam) isCursor() {}

func (p invitationsCursorParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsCursorParam) invitationsModel() {}

type InvitationsParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	invitationsModel()
}

type invitationsParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsParamUnique) invitationsModel() {}

func (invitationsParamUnique) unique() {}

func (p invitationsParamUnique) field() builder.Field {
	return p.data
}

func (p invitationsParamUnique) getQuery() builder.Query {
	return p.query
}

type InvitationsEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	invitationsModel()
}

type invitationsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsEqualsParam) invitationsModel() {}

func (invitationsEqualsParam) equals() {}

func (p invitationsEqualsParam) field() builder.Field {
	return p.data
}

func (p invitationsEqualsParam) getQuery() builder.Query {
	return p.query
}

type InvitationsEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	invitationsModel()
}

type invitationsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsEqualsUniqueParam) invitationsModel() {}

func (invitationsEqualsUniqueParam) unique() {}
func (invitationsEqualsUniqueParam) equals() {}

func (p invitationsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p invitationsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type InvitationsSetParam interface {
	field() builder.Field
	settable()
	invitationsModel()
}

type invitationsSetParam struct {
	data builder.Field
}

func (invitationsSetParam) settable() {}

func (p invitationsSetParam) field() builder.Field {
	return p.data
}

func (p invitationsSetParam) invitationsModel() {}

type InvitationsWithPrismaTeamIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	invitationsModel()
	teamIDField()
}

type InvitationsWithPrismaTeamIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	invitationsModel()
	teamIDField()
}

type invitationsWithPrismaTeamIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsWithPrismaTeamIDSetParam) field() builder.Field {
	return p.data
}

func (p invitationsWithPrismaTeamIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsWithPrismaTeamIDSetParam) invitationsModel() {}

func (p invitationsWithPrismaTeamIDSetParam) teamIDField() {}

type InvitationsWithPrismaTeamIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	invitationsModel()
	teamIDField()
}

type invitationsWithPrismaTeamIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsWithPrismaTeamIDEqualsParam) field() builder.Field {
	return p.data
}

func (p invitationsWithPrismaTeamIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsWithPrismaTeamIDEqualsParam) invitationsModel() {}

func (p invitationsWithPrismaTeamIDEqualsParam) teamIDField() {}

func (invitationsWithPrismaTeamIDSetParam) settable()  {}
func (invitationsWithPrismaTeamIDEqualsParam) equals() {}

type invitationsWithPrismaTeamIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsWithPrismaTeamIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p invitationsWithPrismaTeamIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsWithPrismaTeamIDEqualsUniqueParam) invitationsModel() {}
func (p invitationsWithPrismaTeamIDEqualsUniqueParam) teamIDField()      {}

func (invitationsWithPrismaTeamIDEqualsUniqueParam) unique() {}
func (invitationsWithPrismaTeamIDEqualsUniqueParam) equals() {}

type InvitationsWithPrismaEmailEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	invitationsModel()
	emailField()
}

type InvitationsWithPrismaEmailSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	invitationsModel()
	emailField()
}

type invitationsWithPrismaEmailSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsWithPrismaEmailSetParam) field() builder.Field {
	return p.data
}

func (p invitationsWithPrismaEmailSetParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsWithPrismaEmailSetParam) invitationsModel() {}

func (p invitationsWithPrismaEmailSetParam) emailField() {}

type InvitationsWithPrismaEmailWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	invitationsModel()
	emailField()
}

type invitationsWithPrismaEmailEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsWithPrismaEmailEqualsParam) field() builder.Field {
	return p.data
}

func (p invitationsWithPrismaEmailEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsWithPrismaEmailEqualsParam) invitationsModel() {}

func (p invitationsWithPrismaEmailEqualsParam) emailField() {}

func (invitationsWithPrismaEmailSetParam) settable()  {}
func (invitationsWithPrismaEmailEqualsParam) equals() {}

type invitationsWithPrismaEmailEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsWithPrismaEmailEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p invitationsWithPrismaEmailEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsWithPrismaEmailEqualsUniqueParam) invitationsModel() {}
func (p invitationsWithPrismaEmailEqualsUniqueParam) emailField()       {}

func (invitationsWithPrismaEmailEqualsUniqueParam) unique() {}
func (invitationsWithPrismaEmailEqualsUniqueParam) equals() {}

type InvitationsWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	invitationsModel()
	createdAtField()
}

type InvitationsWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	invitationsModel()
	createdAtField()
}

type invitationsWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p invitationsWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsWithPrismaCreatedAtSetParam) invitationsModel() {}

func (p invitationsWithPrismaCreatedAtSetParam) createdAtField() {}

type InvitationsWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	invitationsModel()
	createdAtField()
}

type invitationsWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p invitationsWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsWithPrismaCreatedAtEqualsParam) invitationsModel() {}

func (p invitationsWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (invitationsWithPrismaCreatedAtSetParam) settable()  {}
func (invitationsWithPrismaCreatedAtEqualsParam) equals() {}

type invitationsWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p invitationsWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsWithPrismaCreatedAtEqualsUniqueParam) invitationsModel() {}
func (p invitationsWithPrismaCreatedAtEqualsUniqueParam) createdAtField()   {}

func (invitationsWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (invitationsWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type InvitationsWithPrismaTeamsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	invitationsModel()
	teamsField()
}

type InvitationsWithPrismaTeamsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	invitationsModel()
	teamsField()
}

type invitationsWithPrismaTeamsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsWithPrismaTeamsSetParam) field() builder.Field {
	return p.data
}

func (p invitationsWithPrismaTeamsSetParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsWithPrismaTeamsSetParam) invitationsModel() {}

func (p invitationsWithPrismaTeamsSetParam) teamsField() {}

type InvitationsWithPrismaTeamsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	invitationsModel()
	teamsField()
}

type invitationsWithPrismaTeamsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsWithPrismaTeamsEqualsParam) field() builder.Field {
	return p.data
}

func (p invitationsWithPrismaTeamsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsWithPrismaTeamsEqualsParam) invitationsModel() {}

func (p invitationsWithPrismaTeamsEqualsParam) teamsField() {}

func (invitationsWithPrismaTeamsSetParam) settable()  {}
func (invitationsWithPrismaTeamsEqualsParam) equals() {}

type invitationsWithPrismaTeamsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p invitationsWithPrismaTeamsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p invitationsWithPrismaTeamsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p invitationsWithPrismaTeamsEqualsUniqueParam) invitationsModel() {}
func (p invitationsWithPrismaTeamsEqualsUniqueParam) teamsField()       {}

func (invitationsWithPrismaTeamsEqualsUniqueParam) unique() {}
func (invitationsWithPrismaTeamsEqualsUniqueParam) equals() {}

type projectsActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var projectsOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "created_at"},
	{Name: "updated_at"},
}

type ProjectsRelationWith interface {
	getQuery() builder.Query
	with()
	projectsRelation()
}

type ProjectsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	projectsModel()
}

type projectsDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsDefaultParam) field() builder.Field {
	return p.data
}

func (p projectsDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p projectsDefaultParam) projectsModel() {}

type ProjectsOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	projectsModel()
}

type projectsOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsOrderByParam) field() builder.Field {
	return p.data
}

func (p projectsOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p projectsOrderByParam) projectsModel() {}

type ProjectsCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	projectsModel()
	isCursor()
}

type projectsCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsCursorParam) field() builder.Field {
	return p.data
}

func (p projectsCursorParam) isCursor() {}

func (p projectsCursorParam) getQuery() builder.Query {
	return p.query
}

func (p projectsCursorParam) projectsModel() {}

type ProjectsParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	projectsModel()
}

type projectsParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p projectsParamUnique) projectsModel() {}

func (projectsParamUnique) unique() {}

func (p projectsParamUnique) field() builder.Field {
	return p.data
}

func (p projectsParamUnique) getQuery() builder.Query {
	return p.query
}

type ProjectsEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	projectsModel()
}

type projectsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsEqualsParam) projectsModel() {}

func (projectsEqualsParam) equals() {}

func (p projectsEqualsParam) field() builder.Field {
	return p.data
}

func (p projectsEqualsParam) getQuery() builder.Query {
	return p.query
}

type ProjectsEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	projectsModel()
}

type projectsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsEqualsUniqueParam) projectsModel() {}

func (projectsEqualsUniqueParam) unique() {}
func (projectsEqualsUniqueParam) equals() {}

func (p projectsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p projectsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type ProjectsSetParam interface {
	field() builder.Field
	settable()
	projectsModel()
}

type projectsSetParam struct {
	data builder.Field
}

func (projectsSetParam) settable() {}

func (p projectsSetParam) field() builder.Field {
	return p.data
}

func (p projectsSetParam) projectsModel() {}

type ProjectsWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	projectsModel()
	idField()
}

type ProjectsWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	projectsModel()
	idField()
}

type projectsWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaIDSetParam) projectsModel() {}

func (p projectsWithPrismaIDSetParam) idField() {}

type ProjectsWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	projectsModel()
	idField()
}

type projectsWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaIDEqualsParam) projectsModel() {}

func (p projectsWithPrismaIDEqualsParam) idField() {}

func (projectsWithPrismaIDSetParam) settable()  {}
func (projectsWithPrismaIDEqualsParam) equals() {}

type projectsWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaIDEqualsUniqueParam) projectsModel() {}
func (p projectsWithPrismaIDEqualsUniqueParam) idField()       {}

func (projectsWithPrismaIDEqualsUniqueParam) unique() {}
func (projectsWithPrismaIDEqualsUniqueParam) equals() {}

type ProjectsWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	projectsModel()
	nameField()
}

type ProjectsWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	projectsModel()
	nameField()
}

type projectsWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaNameSetParam) projectsModel() {}

func (p projectsWithPrismaNameSetParam) nameField() {}

type ProjectsWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	projectsModel()
	nameField()
}

type projectsWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaNameEqualsParam) projectsModel() {}

func (p projectsWithPrismaNameEqualsParam) nameField() {}

func (projectsWithPrismaNameSetParam) settable()  {}
func (projectsWithPrismaNameEqualsParam) equals() {}

type projectsWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaNameEqualsUniqueParam) projectsModel() {}
func (p projectsWithPrismaNameEqualsUniqueParam) nameField()     {}

func (projectsWithPrismaNameEqualsUniqueParam) unique() {}
func (projectsWithPrismaNameEqualsUniqueParam) equals() {}

type ProjectsWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	projectsModel()
	createdAtField()
}

type ProjectsWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	projectsModel()
	createdAtField()
}

type projectsWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaCreatedAtSetParam) projectsModel() {}

func (p projectsWithPrismaCreatedAtSetParam) createdAtField() {}

type ProjectsWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	projectsModel()
	createdAtField()
}

type projectsWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaCreatedAtEqualsParam) projectsModel() {}

func (p projectsWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (projectsWithPrismaCreatedAtSetParam) settable()  {}
func (projectsWithPrismaCreatedAtEqualsParam) equals() {}

type projectsWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaCreatedAtEqualsUniqueParam) projectsModel()  {}
func (p projectsWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (projectsWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (projectsWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type ProjectsWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	projectsModel()
	updatedAtField()
}

type ProjectsWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	projectsModel()
	updatedAtField()
}

type projectsWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaUpdatedAtSetParam) projectsModel() {}

func (p projectsWithPrismaUpdatedAtSetParam) updatedAtField() {}

type ProjectsWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	projectsModel()
	updatedAtField()
}

type projectsWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaUpdatedAtEqualsParam) projectsModel() {}

func (p projectsWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (projectsWithPrismaUpdatedAtSetParam) settable()  {}
func (projectsWithPrismaUpdatedAtEqualsParam) equals() {}

type projectsWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaUpdatedAtEqualsUniqueParam) projectsModel()  {}
func (p projectsWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (projectsWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (projectsWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type ProjectsWithPrismaTeamsProjectsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	projectsModel()
	teamsProjectsField()
}

type ProjectsWithPrismaTeamsProjectsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	projectsModel()
	teamsProjectsField()
}

type projectsWithPrismaTeamsProjectsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaTeamsProjectsSetParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaTeamsProjectsSetParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaTeamsProjectsSetParam) projectsModel() {}

func (p projectsWithPrismaTeamsProjectsSetParam) teamsProjectsField() {}

type ProjectsWithPrismaTeamsProjectsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	projectsModel()
	teamsProjectsField()
}

type projectsWithPrismaTeamsProjectsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaTeamsProjectsEqualsParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaTeamsProjectsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaTeamsProjectsEqualsParam) projectsModel() {}

func (p projectsWithPrismaTeamsProjectsEqualsParam) teamsProjectsField() {}

func (projectsWithPrismaTeamsProjectsSetParam) settable()  {}
func (projectsWithPrismaTeamsProjectsEqualsParam) equals() {}

type projectsWithPrismaTeamsProjectsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p projectsWithPrismaTeamsProjectsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p projectsWithPrismaTeamsProjectsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p projectsWithPrismaTeamsProjectsEqualsUniqueParam) projectsModel()      {}
func (p projectsWithPrismaTeamsProjectsEqualsUniqueParam) teamsProjectsField() {}

func (projectsWithPrismaTeamsProjectsEqualsUniqueParam) unique() {}
func (projectsWithPrismaTeamsProjectsEqualsUniqueParam) equals() {}

type teamsActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var teamsOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "created_at"},
	{Name: "updated_at"},
}

type TeamsRelationWith interface {
	getQuery() builder.Query
	with()
	teamsRelation()
}

type TeamsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
}

type teamsDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsDefaultParam) field() builder.Field {
	return p.data
}

func (p teamsDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p teamsDefaultParam) teamsModel() {}

type TeamsOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
}

type teamsOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsOrderByParam) field() builder.Field {
	return p.data
}

func (p teamsOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p teamsOrderByParam) teamsModel() {}

type TeamsCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	isCursor()
}

type teamsCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsCursorParam) field() builder.Field {
	return p.data
}

func (p teamsCursorParam) isCursor() {}

func (p teamsCursorParam) getQuery() builder.Query {
	return p.query
}

func (p teamsCursorParam) teamsModel() {}

type TeamsParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	teamsModel()
}

type teamsParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p teamsParamUnique) teamsModel() {}

func (teamsParamUnique) unique() {}

func (p teamsParamUnique) field() builder.Field {
	return p.data
}

func (p teamsParamUnique) getQuery() builder.Query {
	return p.query
}

type TeamsEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsModel()
}

type teamsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsEqualsParam) teamsModel() {}

func (teamsEqualsParam) equals() {}

func (p teamsEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsEqualsParam) getQuery() builder.Query {
	return p.query
}

type TeamsEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	teamsModel()
}

type teamsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsEqualsUniqueParam) teamsModel() {}

func (teamsEqualsUniqueParam) unique() {}
func (teamsEqualsUniqueParam) equals() {}

func (p teamsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type TeamsSetParam interface {
	field() builder.Field
	settable()
	teamsModel()
}

type teamsSetParam struct {
	data builder.Field
}

func (teamsSetParam) settable() {}

func (p teamsSetParam) field() builder.Field {
	return p.data
}

func (p teamsSetParam) teamsModel() {}

type TeamsWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsModel()
	idField()
}

type TeamsWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	idField()
}

type teamsWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaIDSetParam) teamsModel() {}

func (p teamsWithPrismaIDSetParam) idField() {}

type TeamsWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	idField()
}

type teamsWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaIDEqualsParam) teamsModel() {}

func (p teamsWithPrismaIDEqualsParam) idField() {}

func (teamsWithPrismaIDSetParam) settable()  {}
func (teamsWithPrismaIDEqualsParam) equals() {}

type teamsWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaIDEqualsUniqueParam) teamsModel() {}
func (p teamsWithPrismaIDEqualsUniqueParam) idField()    {}

func (teamsWithPrismaIDEqualsUniqueParam) unique() {}
func (teamsWithPrismaIDEqualsUniqueParam) equals() {}

type TeamsWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsModel()
	nameField()
}

type TeamsWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	nameField()
}

type teamsWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaNameSetParam) teamsModel() {}

func (p teamsWithPrismaNameSetParam) nameField() {}

type TeamsWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	nameField()
}

type teamsWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaNameEqualsParam) teamsModel() {}

func (p teamsWithPrismaNameEqualsParam) nameField() {}

func (teamsWithPrismaNameSetParam) settable()  {}
func (teamsWithPrismaNameEqualsParam) equals() {}

type teamsWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaNameEqualsUniqueParam) teamsModel() {}
func (p teamsWithPrismaNameEqualsUniqueParam) nameField()  {}

func (teamsWithPrismaNameEqualsUniqueParam) unique() {}
func (teamsWithPrismaNameEqualsUniqueParam) equals() {}

type TeamsWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsModel()
	createdAtField()
}

type TeamsWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	createdAtField()
}

type teamsWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaCreatedAtSetParam) teamsModel() {}

func (p teamsWithPrismaCreatedAtSetParam) createdAtField() {}

type TeamsWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	createdAtField()
}

type teamsWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaCreatedAtEqualsParam) teamsModel() {}

func (p teamsWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (teamsWithPrismaCreatedAtSetParam) settable()  {}
func (teamsWithPrismaCreatedAtEqualsParam) equals() {}

type teamsWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaCreatedAtEqualsUniqueParam) teamsModel()     {}
func (p teamsWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (teamsWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (teamsWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type TeamsWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsModel()
	updatedAtField()
}

type TeamsWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	updatedAtField()
}

type teamsWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaUpdatedAtSetParam) teamsModel() {}

func (p teamsWithPrismaUpdatedAtSetParam) updatedAtField() {}

type TeamsWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	updatedAtField()
}

type teamsWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaUpdatedAtEqualsParam) teamsModel() {}

func (p teamsWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (teamsWithPrismaUpdatedAtSetParam) settable()  {}
func (teamsWithPrismaUpdatedAtEqualsParam) equals() {}

type teamsWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaUpdatedAtEqualsUniqueParam) teamsModel()     {}
func (p teamsWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (teamsWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (teamsWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type TeamsWithPrismaInvitationsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsModel()
	invitationsField()
}

type TeamsWithPrismaInvitationsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	invitationsField()
}

type teamsWithPrismaInvitationsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaInvitationsSetParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaInvitationsSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaInvitationsSetParam) teamsModel() {}

func (p teamsWithPrismaInvitationsSetParam) invitationsField() {}

type TeamsWithPrismaInvitationsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	invitationsField()
}

type teamsWithPrismaInvitationsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaInvitationsEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaInvitationsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaInvitationsEqualsParam) teamsModel() {}

func (p teamsWithPrismaInvitationsEqualsParam) invitationsField() {}

func (teamsWithPrismaInvitationsSetParam) settable()  {}
func (teamsWithPrismaInvitationsEqualsParam) equals() {}

type teamsWithPrismaInvitationsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaInvitationsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaInvitationsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaInvitationsEqualsUniqueParam) teamsModel()       {}
func (p teamsWithPrismaInvitationsEqualsUniqueParam) invitationsField() {}

func (teamsWithPrismaInvitationsEqualsUniqueParam) unique() {}
func (teamsWithPrismaInvitationsEqualsUniqueParam) equals() {}

type TeamsWithPrismaTeamsProjectsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsModel()
	teamsProjectsField()
}

type TeamsWithPrismaTeamsProjectsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	teamsProjectsField()
}

type teamsWithPrismaTeamsProjectsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaTeamsProjectsSetParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaTeamsProjectsSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaTeamsProjectsSetParam) teamsModel() {}

func (p teamsWithPrismaTeamsProjectsSetParam) teamsProjectsField() {}

type TeamsWithPrismaTeamsProjectsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	teamsProjectsField()
}

type teamsWithPrismaTeamsProjectsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaTeamsProjectsEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaTeamsProjectsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaTeamsProjectsEqualsParam) teamsModel() {}

func (p teamsWithPrismaTeamsProjectsEqualsParam) teamsProjectsField() {}

func (teamsWithPrismaTeamsProjectsSetParam) settable()  {}
func (teamsWithPrismaTeamsProjectsEqualsParam) equals() {}

type teamsWithPrismaTeamsProjectsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaTeamsProjectsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaTeamsProjectsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaTeamsProjectsEqualsUniqueParam) teamsModel()         {}
func (p teamsWithPrismaTeamsProjectsEqualsUniqueParam) teamsProjectsField() {}

func (teamsWithPrismaTeamsProjectsEqualsUniqueParam) unique() {}
func (teamsWithPrismaTeamsProjectsEqualsUniqueParam) equals() {}

type TeamsWithPrismaTeamsUsersEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsModel()
	teamsUsersField()
}

type TeamsWithPrismaTeamsUsersSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	teamsUsersField()
}

type teamsWithPrismaTeamsUsersSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaTeamsUsersSetParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaTeamsUsersSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaTeamsUsersSetParam) teamsModel() {}

func (p teamsWithPrismaTeamsUsersSetParam) teamsUsersField() {}

type TeamsWithPrismaTeamsUsersWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsModel()
	teamsUsersField()
}

type teamsWithPrismaTeamsUsersEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaTeamsUsersEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaTeamsUsersEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaTeamsUsersEqualsParam) teamsModel() {}

func (p teamsWithPrismaTeamsUsersEqualsParam) teamsUsersField() {}

func (teamsWithPrismaTeamsUsersSetParam) settable()  {}
func (teamsWithPrismaTeamsUsersEqualsParam) equals() {}

type teamsWithPrismaTeamsUsersEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsWithPrismaTeamsUsersEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsWithPrismaTeamsUsersEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsWithPrismaTeamsUsersEqualsUniqueParam) teamsModel()      {}
func (p teamsWithPrismaTeamsUsersEqualsUniqueParam) teamsUsersField() {}

func (teamsWithPrismaTeamsUsersEqualsUniqueParam) unique() {}
func (teamsWithPrismaTeamsUsersEqualsUniqueParam) equals() {}

type teamsProjectsActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var teamsProjectsOutput = []builder.Output{
	{Name: "project_id"},
	{Name: "team_id"},
	{Name: "created_at"},
}

type TeamsProjectsRelationWith interface {
	getQuery() builder.Query
	with()
	teamsProjectsRelation()
}

type TeamsProjectsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsProjectsModel()
}

type teamsProjectsDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsDefaultParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsDefaultParam) teamsProjectsModel() {}

type TeamsProjectsOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsProjectsModel()
}

type teamsProjectsOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsOrderByParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsOrderByParam) teamsProjectsModel() {}

type TeamsProjectsCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsProjectsModel()
	isCursor()
}

type teamsProjectsCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsCursorParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsCursorParam) isCursor() {}

func (p teamsProjectsCursorParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsCursorParam) teamsProjectsModel() {}

type TeamsProjectsParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	teamsProjectsModel()
}

type teamsProjectsParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsParamUnique) teamsProjectsModel() {}

func (teamsProjectsParamUnique) unique() {}

func (p teamsProjectsParamUnique) field() builder.Field {
	return p.data
}

func (p teamsProjectsParamUnique) getQuery() builder.Query {
	return p.query
}

type TeamsProjectsEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsProjectsModel()
}

type teamsProjectsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsEqualsParam) teamsProjectsModel() {}

func (teamsProjectsEqualsParam) equals() {}

func (p teamsProjectsEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsEqualsParam) getQuery() builder.Query {
	return p.query
}

type TeamsProjectsEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	teamsProjectsModel()
}

type teamsProjectsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsEqualsUniqueParam) teamsProjectsModel() {}

func (teamsProjectsEqualsUniqueParam) unique() {}
func (teamsProjectsEqualsUniqueParam) equals() {}

func (p teamsProjectsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type TeamsProjectsSetParam interface {
	field() builder.Field
	settable()
	teamsProjectsModel()
}

type teamsProjectsSetParam struct {
	data builder.Field
}

// teamsField implements TeamsProjectsWithPrismaTeamsSetParam.
func (teamsProjectsSetParam) teamsField() {
	panic("unimplemented")
}

// getQuery implements TeamsProjectsWithPrismaProjectsSetParam.
func (teamsProjectsSetParam) getQuery() builder.Query {
	panic("unimplemented")
}

// projectsField implements TeamsProjectsWithPrismaProjectsSetParam.
func (teamsProjectsSetParam) projectsField() {
	panic("unimplemented")
}

func (teamsProjectsSetParam) settable() {}

func (p teamsProjectsSetParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsSetParam) teamsProjectsModel() {}

type TeamsProjectsWithPrismaProjectIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsProjectsModel()
	projectIDField()
}

type TeamsProjectsWithPrismaProjectIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsProjectsModel()
	projectIDField()
}

type teamsProjectsWithPrismaProjectIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaProjectIDSetParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaProjectIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaProjectIDSetParam) teamsProjectsModel() {}

func (p teamsProjectsWithPrismaProjectIDSetParam) projectIDField() {}

type TeamsProjectsWithPrismaProjectIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsProjectsModel()
	projectIDField()
}

type teamsProjectsWithPrismaProjectIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaProjectIDEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaProjectIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaProjectIDEqualsParam) teamsProjectsModel() {}

func (p teamsProjectsWithPrismaProjectIDEqualsParam) projectIDField() {}

func (teamsProjectsWithPrismaProjectIDSetParam) settable()  {}
func (teamsProjectsWithPrismaProjectIDEqualsParam) equals() {}

type teamsProjectsWithPrismaProjectIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaProjectIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaProjectIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaProjectIDEqualsUniqueParam) teamsProjectsModel() {}
func (p teamsProjectsWithPrismaProjectIDEqualsUniqueParam) projectIDField()     {}

func (teamsProjectsWithPrismaProjectIDEqualsUniqueParam) unique() {}
func (teamsProjectsWithPrismaProjectIDEqualsUniqueParam) equals() {}

type TeamsProjectsWithPrismaTeamIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsProjectsModel()
	teamIDField()
}

type TeamsProjectsWithPrismaTeamIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsProjectsModel()
	teamIDField()
}

type teamsProjectsWithPrismaTeamIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaTeamIDSetParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaTeamIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaTeamIDSetParam) teamsProjectsModel() {}

func (p teamsProjectsWithPrismaTeamIDSetParam) teamIDField() {}

type TeamsProjectsWithPrismaTeamIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsProjectsModel()
	teamIDField()
}

type teamsProjectsWithPrismaTeamIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaTeamIDEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaTeamIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaTeamIDEqualsParam) teamsProjectsModel() {}

func (p teamsProjectsWithPrismaTeamIDEqualsParam) teamIDField() {}

func (teamsProjectsWithPrismaTeamIDSetParam) settable()  {}
func (teamsProjectsWithPrismaTeamIDEqualsParam) equals() {}

type teamsProjectsWithPrismaTeamIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaTeamIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaTeamIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaTeamIDEqualsUniqueParam) teamsProjectsModel() {}
func (p teamsProjectsWithPrismaTeamIDEqualsUniqueParam) teamIDField()        {}

func (teamsProjectsWithPrismaTeamIDEqualsUniqueParam) unique() {}
func (teamsProjectsWithPrismaTeamIDEqualsUniqueParam) equals() {}

type TeamsProjectsWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsProjectsModel()
	createdAtField()
}

type TeamsProjectsWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsProjectsModel()
	createdAtField()
}

type teamsProjectsWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaCreatedAtSetParam) teamsProjectsModel() {}

func (p teamsProjectsWithPrismaCreatedAtSetParam) createdAtField() {}

type TeamsProjectsWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsProjectsModel()
	createdAtField()
}

type teamsProjectsWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaCreatedAtEqualsParam) teamsProjectsModel() {}

func (p teamsProjectsWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (teamsProjectsWithPrismaCreatedAtSetParam) settable()  {}
func (teamsProjectsWithPrismaCreatedAtEqualsParam) equals() {}

type teamsProjectsWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaCreatedAtEqualsUniqueParam) teamsProjectsModel() {}
func (p teamsProjectsWithPrismaCreatedAtEqualsUniqueParam) createdAtField()     {}

func (teamsProjectsWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (teamsProjectsWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type TeamsProjectsWithPrismaProjectsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsProjectsModel()
	projectsField()
}

type TeamsProjectsWithPrismaProjectsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsProjectsModel()
	projectsField()
}

type teamsProjectsWithPrismaProjectsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaProjectsSetParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaProjectsSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaProjectsSetParam) teamsProjectsModel() {}

func (p teamsProjectsWithPrismaProjectsSetParam) projectsField() {}

type TeamsProjectsWithPrismaProjectsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsProjectsModel()
	projectsField()
}

type teamsProjectsWithPrismaProjectsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaProjectsEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaProjectsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaProjectsEqualsParam) teamsProjectsModel() {}

func (p teamsProjectsWithPrismaProjectsEqualsParam) projectsField() {}

func (teamsProjectsWithPrismaProjectsSetParam) settable()  {}
func (teamsProjectsWithPrismaProjectsEqualsParam) equals() {}

type teamsProjectsWithPrismaProjectsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaProjectsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaProjectsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaProjectsEqualsUniqueParam) teamsProjectsModel() {}
func (p teamsProjectsWithPrismaProjectsEqualsUniqueParam) projectsField()      {}

func (teamsProjectsWithPrismaProjectsEqualsUniqueParam) unique() {}
func (teamsProjectsWithPrismaProjectsEqualsUniqueParam) equals() {}

type TeamsProjectsWithPrismaTeamsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsProjectsModel()
	teamsField()
}

type TeamsProjectsWithPrismaTeamsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsProjectsModel()
	teamsField()
}

type teamsProjectsWithPrismaTeamsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaTeamsSetParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaTeamsSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaTeamsSetParam) teamsProjectsModel() {}

func (p teamsProjectsWithPrismaTeamsSetParam) teamsField() {}

type TeamsProjectsWithPrismaTeamsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsProjectsModel()
	teamsField()
}

type teamsProjectsWithPrismaTeamsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaTeamsEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaTeamsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaTeamsEqualsParam) teamsProjectsModel() {}

func (p teamsProjectsWithPrismaTeamsEqualsParam) teamsField() {}

func (teamsProjectsWithPrismaTeamsSetParam) settable()  {}
func (teamsProjectsWithPrismaTeamsEqualsParam) equals() {}

type teamsProjectsWithPrismaTeamsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsProjectsWithPrismaTeamsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsProjectsWithPrismaTeamsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsProjectsWithPrismaTeamsEqualsUniqueParam) teamsProjectsModel() {}
func (p teamsProjectsWithPrismaTeamsEqualsUniqueParam) teamsField()         {}

func (teamsProjectsWithPrismaTeamsEqualsUniqueParam) unique() {}
func (teamsProjectsWithPrismaTeamsEqualsUniqueParam) equals() {}

type teamsUsersActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var teamsUsersOutput = []builder.Output{
	{Name: "team_id"},
	{Name: "user_id"},
	{Name: "created_at"},
}

type TeamsUsersRelationWith interface {
	getQuery() builder.Query
	with()
	teamsUsersRelation()
}

type TeamsUsersWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsUsersModel()
}

type teamsUsersDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersDefaultParam) field() builder.Field {
	return p.data
}

func (p teamsUsersDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersDefaultParam) teamsUsersModel() {}

type TeamsUsersOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsUsersModel()
}

type teamsUsersOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersOrderByParam) field() builder.Field {
	return p.data
}

func (p teamsUsersOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersOrderByParam) teamsUsersModel() {}

type TeamsUsersCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsUsersModel()
	isCursor()
}

type teamsUsersCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersCursorParam) field() builder.Field {
	return p.data
}

func (p teamsUsersCursorParam) isCursor() {}

func (p teamsUsersCursorParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersCursorParam) teamsUsersModel() {}

type TeamsUsersParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	teamsUsersModel()
}

type teamsUsersParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersParamUnique) teamsUsersModel() {}

func (teamsUsersParamUnique) unique() {}

func (p teamsUsersParamUnique) field() builder.Field {
	return p.data
}

func (p teamsUsersParamUnique) getQuery() builder.Query {
	return p.query
}

type TeamsUsersEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsUsersModel()
}

type teamsUsersEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersEqualsParam) teamsUsersModel() {}

func (teamsUsersEqualsParam) equals() {}

func (p teamsUsersEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsUsersEqualsParam) getQuery() builder.Query {
	return p.query
}

type TeamsUsersEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	teamsUsersModel()
}

type teamsUsersEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersEqualsUniqueParam) teamsUsersModel() {}

func (teamsUsersEqualsUniqueParam) unique() {}
func (teamsUsersEqualsUniqueParam) equals() {}

func (p teamsUsersEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsUsersEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type TeamsUsersSetParam interface {
	field() builder.Field
	settable()
	teamsUsersModel()
}

type teamsUsersSetParam struct {
	data builder.Field
}

func (teamsUsersSetParam) settable() {}

func (p teamsUsersSetParam) field() builder.Field {
	return p.data
}

func (p teamsUsersSetParam) teamsUsersModel() {}

type TeamsUsersWithPrismaTeamIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsUsersModel()
	teamIDField()
}

type TeamsUsersWithPrismaTeamIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsUsersModel()
	teamIDField()
}

type teamsUsersWithPrismaTeamIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaTeamIDSetParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaTeamIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaTeamIDSetParam) teamsUsersModel() {}

func (p teamsUsersWithPrismaTeamIDSetParam) teamIDField() {}

type TeamsUsersWithPrismaTeamIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsUsersModel()
	teamIDField()
}

type teamsUsersWithPrismaTeamIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaTeamIDEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaTeamIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaTeamIDEqualsParam) teamsUsersModel() {}

func (p teamsUsersWithPrismaTeamIDEqualsParam) teamIDField() {}

func (teamsUsersWithPrismaTeamIDSetParam) settable()  {}
func (teamsUsersWithPrismaTeamIDEqualsParam) equals() {}

type teamsUsersWithPrismaTeamIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaTeamIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaTeamIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaTeamIDEqualsUniqueParam) teamsUsersModel() {}
func (p teamsUsersWithPrismaTeamIDEqualsUniqueParam) teamIDField()     {}

func (teamsUsersWithPrismaTeamIDEqualsUniqueParam) unique() {}
func (teamsUsersWithPrismaTeamIDEqualsUniqueParam) equals() {}

type TeamsUsersWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsUsersModel()
	userIDField()
}

type TeamsUsersWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsUsersModel()
	userIDField()
}

type teamsUsersWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaUserIDSetParam) teamsUsersModel() {}

func (p teamsUsersWithPrismaUserIDSetParam) userIDField() {}

type TeamsUsersWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsUsersModel()
	userIDField()
}

type teamsUsersWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaUserIDEqualsParam) teamsUsersModel() {}

func (p teamsUsersWithPrismaUserIDEqualsParam) userIDField() {}

func (teamsUsersWithPrismaUserIDSetParam) settable()  {}
func (teamsUsersWithPrismaUserIDEqualsParam) equals() {}

type teamsUsersWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaUserIDEqualsUniqueParam) teamsUsersModel() {}
func (p teamsUsersWithPrismaUserIDEqualsUniqueParam) userIDField()     {}

func (teamsUsersWithPrismaUserIDEqualsUniqueParam) unique() {}
func (teamsUsersWithPrismaUserIDEqualsUniqueParam) equals() {}

type TeamsUsersWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsUsersModel()
	createdAtField()
}

type TeamsUsersWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsUsersModel()
	createdAtField()
}

type teamsUsersWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaCreatedAtSetParam) teamsUsersModel() {}

func (p teamsUsersWithPrismaCreatedAtSetParam) createdAtField() {}

type TeamsUsersWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsUsersModel()
	createdAtField()
}

type teamsUsersWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaCreatedAtEqualsParam) teamsUsersModel() {}

func (p teamsUsersWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (teamsUsersWithPrismaCreatedAtSetParam) settable()  {}
func (teamsUsersWithPrismaCreatedAtEqualsParam) equals() {}

type teamsUsersWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaCreatedAtEqualsUniqueParam) teamsUsersModel() {}
func (p teamsUsersWithPrismaCreatedAtEqualsUniqueParam) createdAtField()  {}

func (teamsUsersWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (teamsUsersWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type TeamsUsersWithPrismaTeamsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsUsersModel()
	teamsField()
}

type TeamsUsersWithPrismaTeamsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsUsersModel()
	teamsField()
}

type teamsUsersWithPrismaTeamsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaTeamsSetParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaTeamsSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaTeamsSetParam) teamsUsersModel() {}

func (p teamsUsersWithPrismaTeamsSetParam) teamsField() {}

type TeamsUsersWithPrismaTeamsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsUsersModel()
	teamsField()
}

type teamsUsersWithPrismaTeamsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaTeamsEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaTeamsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaTeamsEqualsParam) teamsUsersModel() {}

func (p teamsUsersWithPrismaTeamsEqualsParam) teamsField() {}

func (teamsUsersWithPrismaTeamsSetParam) settable()  {}
func (teamsUsersWithPrismaTeamsEqualsParam) equals() {}

type teamsUsersWithPrismaTeamsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaTeamsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaTeamsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaTeamsEqualsUniqueParam) teamsUsersModel() {}
func (p teamsUsersWithPrismaTeamsEqualsUniqueParam) teamsField()      {}

func (teamsUsersWithPrismaTeamsEqualsUniqueParam) unique() {}
func (teamsUsersWithPrismaTeamsEqualsUniqueParam) equals() {}

type TeamsUsersWithPrismaUsersEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	teamsUsersModel()
	usersField()
}

type TeamsUsersWithPrismaUsersSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsUsersModel()
	usersField()
}

type teamsUsersWithPrismaUsersSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaUsersSetParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaUsersSetParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaUsersSetParam) teamsUsersModel() {}

func (p teamsUsersWithPrismaUsersSetParam) usersField() {}

type TeamsUsersWithPrismaUsersWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	teamsUsersModel()
	usersField()
}

type teamsUsersWithPrismaUsersEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaUsersEqualsParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaUsersEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaUsersEqualsParam) teamsUsersModel() {}

func (p teamsUsersWithPrismaUsersEqualsParam) usersField() {}

func (teamsUsersWithPrismaUsersSetParam) settable()  {}
func (teamsUsersWithPrismaUsersEqualsParam) equals() {}

type teamsUsersWithPrismaUsersEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p teamsUsersWithPrismaUsersEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p teamsUsersWithPrismaUsersEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p teamsUsersWithPrismaUsersEqualsUniqueParam) teamsUsersModel() {}
func (p teamsUsersWithPrismaUsersEqualsUniqueParam) usersField()      {}

func (teamsUsersWithPrismaUsersEqualsUniqueParam) unique() {}
func (teamsUsersWithPrismaUsersEqualsUniqueParam) equals() {}

// --- template client.gotpl ---
const schema = `generator db {
  provider = "go run github.com/steebchen/prisma-client-go"
}

datasource db {
  provider = "postgresql"
  url      = "postgres://postgres:pgadmin@localhost:5432/postgres?schema=public"
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
model contact_form_submissions {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name       String?
  email      String
  message    String
  user_id    String?  @db.Uuid
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @db.Timestamptz(6)
  users      users?   @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
model users {
  id                       String                     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email                    String                     @unique
  hashed_password          String
  created_at               DateTime                   @default(now()) @db.Timestamptz(6)
  updated_at               DateTime                   @default(now()) @db.Timestamptz(6)
  email_verified           Boolean                    @default(false)
  email_verification_code  String?
  password_reset_code      String?
  password_at              DateTime                   @default(now()) @db.Timestamptz(6)
  display_name             String?
  avatar_file_key          String?
  contact_form_submissions contact_form_submissions[]
  teams_users              teams_users[]
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
model invitations {
  team_id    String   @db.Uuid
  email      String
  created_at DateTime @default(now()) @db.Timestamptz(6)
  teams      teams    @relation(fields: [team_id], references: [id], onDelete: Cascade)

  @@id([team_id, email])
}

model projects {
  id             String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name           String
  created_at     DateTime         @default(now()) @db.Timestamptz(6)
  updated_at     DateTime         @default(now()) @db.Timestamptz(6)
  teams_projects teams_projects[]
}

model teams {
  id             String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name           String
  created_at     DateTime         @default(now()) @db.Timestamptz(6)
  updated_at     DateTime         @default(now()) @db.Timestamptz(6)
  invitations    invitations[]
  teams_projects teams_projects[]
  teams_users    teams_users[]
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
model teams_projects {
  project_id String   @db.Uuid
  team_id    String   @db.Uuid
  created_at DateTime @default(now()) @db.Timestamptz(6)
  projects   projects @relation(fields: [project_id], references: [id], onDelete: Cascade)
  teams      teams    @relation(fields: [team_id], references: [id], onDelete: Cascade)

  @@id([project_id, team_id])
}

model teams_users {
  team_id    String   @db.Uuid
  user_id    String   @db.Uuid
  created_at DateTime @default(now()) @db.Timestamptz(6)
  teams      teams    @relation(fields: [team_id], references: [id], onDelete: Cascade)
  users      users    @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@id([team_id, user_id])
}
`
const schemaConnectionURL = "postgres://postgres:pgadmin@localhost:5432/postgres?schema=public"
const schemaEnvVarName = ""

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = true

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//	client := db.NewClient()
//	if err := client.Prisma.Connect(); err != nil {
//	  handle(err)
//	}
//
//	defer func() {
//	  if err := client.Prisma.Disconnect(); err != nil {
//	    panic(fmt.Errorf("could not disconnect: %w", err))
//	  }
//	}()
func NewClient() *PrismaClient {
	c := newClient()

	c.Engine = engine.NewQueryEngine(schema, hasBinaryTargets)

	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.ContactFormSubmissions = contactFormSubmissionsActions{client: c}
	c.Users = usersActions{client: c}
	c.Invitations = invitationsActions{client: c}
	c.Projects = projectsActions{client: c}
	c.Teams = teamsActions{client: c}
	c.TeamsProjects = teamsProjectsActions{client: c}
	c.TeamsUsers = teamsUsersActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// ContactFormSubmissions provides access to CRUD methods.
	ContactFormSubmissions contactFormSubmissionsActions
	// Users provides access to CRUD methods.
	Users usersActions
	// Invitations provides access to CRUD methods.
	Invitations invitationsActions
	// Projects provides access to CRUD methods.
	Projects projectsActions
	// Teams provides access to CRUD methods.
	Teams teamsActions
	// TeamsProjects provides access to CRUD methods.
	TeamsProjects teamsProjectsActions
	// TeamsUsers provides access to CRUD methods.
	TeamsUsers teamsUsersActions
}

// --- template enums.gotpl ---

type TransactionIsolationLevel string

const (
	TransactionIsolationLevelReadUncommitted TransactionIsolationLevel = "ReadUncommitted"
	TransactionIsolationLevelReadCommitted   TransactionIsolationLevel = "ReadCommitted"
	TransactionIsolationLevelRepeatableRead  TransactionIsolationLevel = "RepeatableRead"
	TransactionIsolationLevelSerializable    TransactionIsolationLevel = "Serializable"
)

type ContactFormSubmissionsScalarFieldEnum string

const (
	ContactFormSubmissionsScalarFieldEnumID        ContactFormSubmissionsScalarFieldEnum = "id"
	ContactFormSubmissionsScalarFieldEnumName      ContactFormSubmissionsScalarFieldEnum = "name"
	ContactFormSubmissionsScalarFieldEnumEmail     ContactFormSubmissionsScalarFieldEnum = "email"
	ContactFormSubmissionsScalarFieldEnumMessage   ContactFormSubmissionsScalarFieldEnum = "message"
	ContactFormSubmissionsScalarFieldEnumUserID    ContactFormSubmissionsScalarFieldEnum = "user_id"
	ContactFormSubmissionsScalarFieldEnumCreatedAt ContactFormSubmissionsScalarFieldEnum = "created_at"
	ContactFormSubmissionsScalarFieldEnumUpdatedAt ContactFormSubmissionsScalarFieldEnum = "updated_at"
)

type UsersScalarFieldEnum string

const (
	UsersScalarFieldEnumID                    UsersScalarFieldEnum = "id"
	UsersScalarFieldEnumEmail                 UsersScalarFieldEnum = "email"
	UsersScalarFieldEnumHashedPassword        UsersScalarFieldEnum = "hashed_password"
	UsersScalarFieldEnumCreatedAt             UsersScalarFieldEnum = "created_at"
	UsersScalarFieldEnumUpdatedAt             UsersScalarFieldEnum = "updated_at"
	UsersScalarFieldEnumEmailVerified         UsersScalarFieldEnum = "email_verified"
	UsersScalarFieldEnumEmailVerificationCode UsersScalarFieldEnum = "email_verification_code"
	UsersScalarFieldEnumPasswordResetCode     UsersScalarFieldEnum = "password_reset_code"
	UsersScalarFieldEnumPasswordAt            UsersScalarFieldEnum = "password_at"
	UsersScalarFieldEnumDisplayName           UsersScalarFieldEnum = "display_name"
	UsersScalarFieldEnumAvatarFileKey         UsersScalarFieldEnum = "avatar_file_key"
)

type InvitationsScalarFieldEnum string

const (
	InvitationsScalarFieldEnumTeamID    InvitationsScalarFieldEnum = "team_id"
	InvitationsScalarFieldEnumEmail     InvitationsScalarFieldEnum = "email"
	InvitationsScalarFieldEnumCreatedAt InvitationsScalarFieldEnum = "created_at"
)

type ProjectsScalarFieldEnum string

const (
	ProjectsScalarFieldEnumID        ProjectsScalarFieldEnum = "id"
	ProjectsScalarFieldEnumName      ProjectsScalarFieldEnum = "name"
	ProjectsScalarFieldEnumCreatedAt ProjectsScalarFieldEnum = "created_at"
	ProjectsScalarFieldEnumUpdatedAt ProjectsScalarFieldEnum = "updated_at"
)

type TeamsScalarFieldEnum string

const (
	TeamsScalarFieldEnumID        TeamsScalarFieldEnum = "id"
	TeamsScalarFieldEnumName      TeamsScalarFieldEnum = "name"
	TeamsScalarFieldEnumCreatedAt TeamsScalarFieldEnum = "created_at"
	TeamsScalarFieldEnumUpdatedAt TeamsScalarFieldEnum = "updated_at"
)

type TeamsProjectsScalarFieldEnum string

const (
	TeamsProjectsScalarFieldEnumProjectID TeamsProjectsScalarFieldEnum = "project_id"
	TeamsProjectsScalarFieldEnumTeamID    TeamsProjectsScalarFieldEnum = "team_id"
	TeamsProjectsScalarFieldEnumCreatedAt TeamsProjectsScalarFieldEnum = "created_at"
)

type TeamsUsersScalarFieldEnum string

const (
	TeamsUsersScalarFieldEnumTeamID    TeamsUsersScalarFieldEnum = "team_id"
	TeamsUsersScalarFieldEnumUserID    TeamsUsersScalarFieldEnum = "user_id"
	TeamsUsersScalarFieldEnumCreatedAt TeamsUsersScalarFieldEnum = "created_at"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type QueryMode string

const (
	QueryModeDefault     QueryMode = "default"
	QueryModeInsensitive QueryMode = "insensitive"
)

type NullsOrder string

const (
	NullsOrderFirst NullsOrder = "first"
	NullsOrderLast  NullsOrder = "last"
)

// --- template query.gotpl ---

// ContactFormSubmissions acts as a namespaces to access query methods for the ContactFormSubmissions model
var ContactFormSubmissions = contactFormSubmissionsQuery{}

// contactFormSubmissionsQuery exposes query functions for the contactFormSubmissions model
type contactFormSubmissionsQuery struct {

	// ID
	//
	// @required
	ID contactFormSubmissionsQueryIDString

	// Name
	//
	// @optional
	Name contactFormSubmissionsQueryNameString

	// Email
	//
	// @required
	Email contactFormSubmissionsQueryEmailString

	// Message
	//
	// @required
	Message contactFormSubmissionsQueryMessageString

	// UserID
	//
	// @optional
	UserID contactFormSubmissionsQueryUserIDString

	// CreatedAt
	//
	// @required
	CreatedAt contactFormSubmissionsQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt contactFormSubmissionsQueryUpdatedAtDateTime

	Users contactFormSubmissionsQueryUsersRelations
}

func (contactFormSubmissionsQuery) Not(params ...ContactFormSubmissionsWhereParam) contactFormSubmissionsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (contactFormSubmissionsQuery) Or(params ...ContactFormSubmissionsWhereParam) contactFormSubmissionsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (contactFormSubmissionsQuery) And(params ...ContactFormSubmissionsWhereParam) contactFormSubmissionsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type contactFormSubmissionsQueryIDString struct{}

// Set the required value of ID
func (r contactFormSubmissionsQueryIDString) Set(value string) contactFormSubmissionsSetParam {

	return contactFormSubmissionsSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r contactFormSubmissionsQueryIDString) SetIfPresent(value *string) contactFormSubmissionsSetParam {
	if value == nil {
		return contactFormSubmissionsSetParam{}
	}

	return r.Set(*value)
}

func (r contactFormSubmissionsQueryIDString) Equals(value string) contactFormSubmissionsWithPrismaIDEqualsUniqueParam {

	return contactFormSubmissionsWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryIDString) EqualsIfPresent(value *string) contactFormSubmissionsWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return contactFormSubmissionsWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r contactFormSubmissionsQueryIDString) Order(direction SortOrder) contactFormSubmissionsDefaultParam {
	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r contactFormSubmissionsQueryIDString) Cursor(cursor string) contactFormSubmissionsCursorParam {
	return contactFormSubmissionsCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r contactFormSubmissionsQueryIDString) In(value []string) contactFormSubmissionsParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return contactFormSubmissionsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryIDString) InIfPresent(value []string) contactFormSubmissionsParamUnique {
	if value == nil {
		return contactFormSubmissionsParamUnique{}
	}
	return r.In(value)
}

func (r contactFormSubmissionsQueryIDString) NotIn(value []string) contactFormSubmissionsParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return contactFormSubmissionsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryIDString) NotInIfPresent(value []string) contactFormSubmissionsParamUnique {
	if value == nil {
		return contactFormSubmissionsParamUnique{}
	}
	return r.NotIn(value)
}

func (r contactFormSubmissionsQueryIDString) Lt(value string) contactFormSubmissionsParamUnique {

	return contactFormSubmissionsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryIDString) LtIfPresent(value *string) contactFormSubmissionsParamUnique {
	if value == nil {
		return contactFormSubmissionsParamUnique{}
	}
	return r.Lt(*value)
}

func (r contactFormSubmissionsQueryIDString) Lte(value string) contactFormSubmissionsParamUnique {

	return contactFormSubmissionsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryIDString) LteIfPresent(value *string) contactFormSubmissionsParamUnique {
	if value == nil {
		return contactFormSubmissionsParamUnique{}
	}
	return r.Lte(*value)
}

func (r contactFormSubmissionsQueryIDString) Gt(value string) contactFormSubmissionsParamUnique {

	return contactFormSubmissionsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryIDString) GtIfPresent(value *string) contactFormSubmissionsParamUnique {
	if value == nil {
		return contactFormSubmissionsParamUnique{}
	}
	return r.Gt(*value)
}

func (r contactFormSubmissionsQueryIDString) Gte(value string) contactFormSubmissionsParamUnique {

	return contactFormSubmissionsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryIDString) GteIfPresent(value *string) contactFormSubmissionsParamUnique {
	if value == nil {
		return contactFormSubmissionsParamUnique{}
	}
	return r.Gte(*value)
}

func (r contactFormSubmissionsQueryIDString) Contains(value string) contactFormSubmissionsParamUnique {

	return contactFormSubmissionsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryIDString) ContainsIfPresent(value *string) contactFormSubmissionsParamUnique {
	if value == nil {
		return contactFormSubmissionsParamUnique{}
	}
	return r.Contains(*value)
}

func (r contactFormSubmissionsQueryIDString) StartsWith(value string) contactFormSubmissionsParamUnique {

	return contactFormSubmissionsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryIDString) StartsWithIfPresent(value *string) contactFormSubmissionsParamUnique {
	if value == nil {
		return contactFormSubmissionsParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r contactFormSubmissionsQueryIDString) EndsWith(value string) contactFormSubmissionsParamUnique {

	return contactFormSubmissionsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryIDString) EndsWithIfPresent(value *string) contactFormSubmissionsParamUnique {
	if value == nil {
		return contactFormSubmissionsParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r contactFormSubmissionsQueryIDString) Mode(value QueryMode) contactFormSubmissionsParamUnique {

	return contactFormSubmissionsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryIDString) ModeIfPresent(value *QueryMode) contactFormSubmissionsParamUnique {
	if value == nil {
		return contactFormSubmissionsParamUnique{}
	}
	return r.Mode(*value)
}

func (r contactFormSubmissionsQueryIDString) Not(value string) contactFormSubmissionsParamUnique {

	return contactFormSubmissionsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryIDString) NotIfPresent(value *string) contactFormSubmissionsParamUnique {
	if value == nil {
		return contactFormSubmissionsParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r contactFormSubmissionsQueryIDString) HasPrefix(value string) contactFormSubmissionsParamUnique {

	return contactFormSubmissionsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r contactFormSubmissionsQueryIDString) HasPrefixIfPresent(value *string) contactFormSubmissionsParamUnique {
	if value == nil {
		return contactFormSubmissionsParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r contactFormSubmissionsQueryIDString) HasSuffix(value string) contactFormSubmissionsParamUnique {

	return contactFormSubmissionsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r contactFormSubmissionsQueryIDString) HasSuffixIfPresent(value *string) contactFormSubmissionsParamUnique {
	if value == nil {
		return contactFormSubmissionsParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type contactFormSubmissionsQueryNameString struct{}

// Set the optional value of Name
func (r contactFormSubmissionsQueryNameString) Set(value string) contactFormSubmissionsSetParam {

	return contactFormSubmissionsSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r contactFormSubmissionsQueryNameString) SetIfPresent(value *string) contactFormSubmissionsSetParam {
	if value == nil {
		return contactFormSubmissionsSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Name dynamically
func (r contactFormSubmissionsQueryNameString) SetOptional(value *string) contactFormSubmissionsSetParam {
	if value == nil {

		var v *string
		return contactFormSubmissionsSetParam{
			data: builder.Field{
				Name:  "name",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r contactFormSubmissionsQueryNameString) Equals(value string) contactFormSubmissionsWithPrismaNameEqualsParam {

	return contactFormSubmissionsWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryNameString) EqualsIfPresent(value *string) contactFormSubmissionsWithPrismaNameEqualsParam {
	if value == nil {
		return contactFormSubmissionsWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r contactFormSubmissionsQueryNameString) EqualsOptional(value *string) contactFormSubmissionsDefaultParam {
	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryNameString) IsNull() contactFormSubmissionsDefaultParam {
	var str *string = nil
	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryNameString) Order(direction SortOrder) contactFormSubmissionsDefaultParam {
	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r contactFormSubmissionsQueryNameString) Cursor(cursor string) contactFormSubmissionsCursorParam {
	return contactFormSubmissionsCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r contactFormSubmissionsQueryNameString) In(value []string) contactFormSubmissionsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryNameString) InIfPresent(value []string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.In(value)
}

func (r contactFormSubmissionsQueryNameString) NotIn(value []string) contactFormSubmissionsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryNameString) NotInIfPresent(value []string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r contactFormSubmissionsQueryNameString) Lt(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryNameString) LtIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r contactFormSubmissionsQueryNameString) Lte(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryNameString) LteIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r contactFormSubmissionsQueryNameString) Gt(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryNameString) GtIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r contactFormSubmissionsQueryNameString) Gte(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryNameString) GteIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r contactFormSubmissionsQueryNameString) Contains(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryNameString) ContainsIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r contactFormSubmissionsQueryNameString) StartsWith(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryNameString) StartsWithIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r contactFormSubmissionsQueryNameString) EndsWith(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryNameString) EndsWithIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r contactFormSubmissionsQueryNameString) Mode(value QueryMode) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryNameString) ModeIfPresent(value *QueryMode) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r contactFormSubmissionsQueryNameString) Not(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryNameString) NotIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r contactFormSubmissionsQueryNameString) HasPrefix(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r contactFormSubmissionsQueryNameString) HasPrefixIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r contactFormSubmissionsQueryNameString) HasSuffix(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r contactFormSubmissionsQueryNameString) HasSuffixIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type contactFormSubmissionsQueryEmailString struct{}

// Set the required value of Email
func (r contactFormSubmissionsQueryEmailString) Set(value string) contactFormSubmissionsWithPrismaEmailSetParam {

	return contactFormSubmissionsWithPrismaEmailSetParam{
		data: builder.Field{
			Name:  "email",
			Value: value,
		},
	}

}

// Set the optional value of Email dynamically
func (r contactFormSubmissionsQueryEmailString) SetIfPresent(value *string) contactFormSubmissionsWithPrismaEmailSetParam {
	if value == nil {
		return contactFormSubmissionsWithPrismaEmailSetParam{}
	}

	return r.Set(*value)
}

func (r contactFormSubmissionsQueryEmailString) Equals(value string) contactFormSubmissionsWithPrismaEmailEqualsParam {

	return contactFormSubmissionsWithPrismaEmailEqualsParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryEmailString) EqualsIfPresent(value *string) contactFormSubmissionsWithPrismaEmailEqualsParam {
	if value == nil {
		return contactFormSubmissionsWithPrismaEmailEqualsParam{}
	}
	return r.Equals(*value)
}

func (r contactFormSubmissionsQueryEmailString) Order(direction SortOrder) contactFormSubmissionsDefaultParam {
	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name:  "email",
			Value: direction,
		},
	}
}

func (r contactFormSubmissionsQueryEmailString) Cursor(cursor string) contactFormSubmissionsCursorParam {
	return contactFormSubmissionsCursorParam{
		data: builder.Field{
			Name:  "email",
			Value: cursor,
		},
	}
}

func (r contactFormSubmissionsQueryEmailString) In(value []string) contactFormSubmissionsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryEmailString) InIfPresent(value []string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.In(value)
}

func (r contactFormSubmissionsQueryEmailString) NotIn(value []string) contactFormSubmissionsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryEmailString) NotInIfPresent(value []string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r contactFormSubmissionsQueryEmailString) Lt(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryEmailString) LtIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r contactFormSubmissionsQueryEmailString) Lte(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryEmailString) LteIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r contactFormSubmissionsQueryEmailString) Gt(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryEmailString) GtIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r contactFormSubmissionsQueryEmailString) Gte(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryEmailString) GteIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r contactFormSubmissionsQueryEmailString) Contains(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryEmailString) ContainsIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r contactFormSubmissionsQueryEmailString) StartsWith(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryEmailString) StartsWithIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r contactFormSubmissionsQueryEmailString) EndsWith(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryEmailString) EndsWithIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r contactFormSubmissionsQueryEmailString) Mode(value QueryMode) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryEmailString) ModeIfPresent(value *QueryMode) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r contactFormSubmissionsQueryEmailString) Not(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryEmailString) NotIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r contactFormSubmissionsQueryEmailString) HasPrefix(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r contactFormSubmissionsQueryEmailString) HasPrefixIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r contactFormSubmissionsQueryEmailString) HasSuffix(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r contactFormSubmissionsQueryEmailString) HasSuffixIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type contactFormSubmissionsQueryMessageString struct{}

// Set the required value of Message
func (r contactFormSubmissionsQueryMessageString) Set(value string) contactFormSubmissionsWithPrismaMessageSetParam {

	return contactFormSubmissionsWithPrismaMessageSetParam{
		data: builder.Field{
			Name:  "message",
			Value: value,
		},
	}

}

// Set the optional value of Message dynamically
func (r contactFormSubmissionsQueryMessageString) SetIfPresent(value *string) contactFormSubmissionsWithPrismaMessageSetParam {
	if value == nil {
		return contactFormSubmissionsWithPrismaMessageSetParam{}
	}

	return r.Set(*value)
}

func (r contactFormSubmissionsQueryMessageString) Equals(value string) contactFormSubmissionsWithPrismaMessageEqualsParam {

	return contactFormSubmissionsWithPrismaMessageEqualsParam{
		data: builder.Field{
			Name: "message",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryMessageString) EqualsIfPresent(value *string) contactFormSubmissionsWithPrismaMessageEqualsParam {
	if value == nil {
		return contactFormSubmissionsWithPrismaMessageEqualsParam{}
	}
	return r.Equals(*value)
}

func (r contactFormSubmissionsQueryMessageString) Order(direction SortOrder) contactFormSubmissionsDefaultParam {
	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name:  "message",
			Value: direction,
		},
	}
}

func (r contactFormSubmissionsQueryMessageString) Cursor(cursor string) contactFormSubmissionsCursorParam {
	return contactFormSubmissionsCursorParam{
		data: builder.Field{
			Name:  "message",
			Value: cursor,
		},
	}
}

func (r contactFormSubmissionsQueryMessageString) In(value []string) contactFormSubmissionsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "message",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryMessageString) InIfPresent(value []string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.In(value)
}

func (r contactFormSubmissionsQueryMessageString) NotIn(value []string) contactFormSubmissionsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "message",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryMessageString) NotInIfPresent(value []string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r contactFormSubmissionsQueryMessageString) Lt(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "message",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryMessageString) LtIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r contactFormSubmissionsQueryMessageString) Lte(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "message",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryMessageString) LteIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r contactFormSubmissionsQueryMessageString) Gt(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "message",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryMessageString) GtIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r contactFormSubmissionsQueryMessageString) Gte(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "message",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryMessageString) GteIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r contactFormSubmissionsQueryMessageString) Contains(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "message",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryMessageString) ContainsIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r contactFormSubmissionsQueryMessageString) StartsWith(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "message",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryMessageString) StartsWithIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r contactFormSubmissionsQueryMessageString) EndsWith(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "message",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryMessageString) EndsWithIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r contactFormSubmissionsQueryMessageString) Mode(value QueryMode) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "message",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryMessageString) ModeIfPresent(value *QueryMode) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r contactFormSubmissionsQueryMessageString) Not(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "message",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryMessageString) NotIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r contactFormSubmissionsQueryMessageString) HasPrefix(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "message",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r contactFormSubmissionsQueryMessageString) HasPrefixIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r contactFormSubmissionsQueryMessageString) HasSuffix(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "message",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r contactFormSubmissionsQueryMessageString) HasSuffixIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type contactFormSubmissionsQueryUserIDString struct{}

// Set the optional value of UserID
func (r contactFormSubmissionsQueryUserIDString) Set(value string) contactFormSubmissionsSetParam {

	return contactFormSubmissionsSetParam{
		data: builder.Field{
			Name:  "user_id",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r contactFormSubmissionsQueryUserIDString) SetIfPresent(value *string) contactFormSubmissionsSetParam {
	if value == nil {
		return contactFormSubmissionsSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of UserID dynamically
func (r contactFormSubmissionsQueryUserIDString) SetOptional(value *string) contactFormSubmissionsSetParam {
	if value == nil {

		var v *string
		return contactFormSubmissionsSetParam{
			data: builder.Field{
				Name:  "user_id",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r contactFormSubmissionsQueryUserIDString) Equals(value string) contactFormSubmissionsWithPrismaUserIDEqualsParam {

	return contactFormSubmissionsWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) EqualsIfPresent(value *string) contactFormSubmissionsWithPrismaUserIDEqualsParam {
	if value == nil {
		return contactFormSubmissionsWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r contactFormSubmissionsQueryUserIDString) EqualsOptional(value *string) contactFormSubmissionsDefaultParam {
	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) IsNull() contactFormSubmissionsDefaultParam {
	var str *string = nil
	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) Order(direction SortOrder) contactFormSubmissionsDefaultParam {
	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name:  "user_id",
			Value: direction,
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) Cursor(cursor string) contactFormSubmissionsCursorParam {
	return contactFormSubmissionsCursorParam{
		data: builder.Field{
			Name:  "user_id",
			Value: cursor,
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) In(value []string) contactFormSubmissionsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) InIfPresent(value []string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.In(value)
}

func (r contactFormSubmissionsQueryUserIDString) NotIn(value []string) contactFormSubmissionsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) NotInIfPresent(value []string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r contactFormSubmissionsQueryUserIDString) Lt(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) LtIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r contactFormSubmissionsQueryUserIDString) Lte(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) LteIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r contactFormSubmissionsQueryUserIDString) Gt(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) GtIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r contactFormSubmissionsQueryUserIDString) Gte(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) GteIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r contactFormSubmissionsQueryUserIDString) Contains(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) ContainsIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r contactFormSubmissionsQueryUserIDString) StartsWith(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) StartsWithIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r contactFormSubmissionsQueryUserIDString) EndsWith(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) EndsWithIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r contactFormSubmissionsQueryUserIDString) Mode(value QueryMode) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) ModeIfPresent(value *QueryMode) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r contactFormSubmissionsQueryUserIDString) Not(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUserIDString) NotIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r contactFormSubmissionsQueryUserIDString) HasPrefix(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r contactFormSubmissionsQueryUserIDString) HasPrefixIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r contactFormSubmissionsQueryUserIDString) HasSuffix(value string) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r contactFormSubmissionsQueryUserIDString) HasSuffixIfPresent(value *string) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type contactFormSubmissionsQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r contactFormSubmissionsQueryCreatedAtDateTime) Set(value DateTime) contactFormSubmissionsSetParam {

	return contactFormSubmissionsSetParam{
		data: builder.Field{
			Name:  "created_at",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r contactFormSubmissionsQueryCreatedAtDateTime) SetIfPresent(value *DateTime) contactFormSubmissionsSetParam {
	if value == nil {
		return contactFormSubmissionsSetParam{}
	}

	return r.Set(*value)
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) Equals(value DateTime) contactFormSubmissionsWithPrismaCreatedAtEqualsParam {

	return contactFormSubmissionsWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) contactFormSubmissionsWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return contactFormSubmissionsWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) Order(direction SortOrder) contactFormSubmissionsDefaultParam {
	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name:  "created_at",
			Value: direction,
		},
	}
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) Cursor(cursor DateTime) contactFormSubmissionsCursorParam {
	return contactFormSubmissionsCursorParam{
		data: builder.Field{
			Name:  "created_at",
			Value: cursor,
		},
	}
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) In(value []DateTime) contactFormSubmissionsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) InIfPresent(value []DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.In(value)
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) NotIn(value []DateTime) contactFormSubmissionsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) Lt(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) LtIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) Lte(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) LteIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) Gt(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) GtIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) Gte(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) GteIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) Not(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryCreatedAtDateTime) NotIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r contactFormSubmissionsQueryCreatedAtDateTime) Before(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r contactFormSubmissionsQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r contactFormSubmissionsQueryCreatedAtDateTime) After(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r contactFormSubmissionsQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r contactFormSubmissionsQueryCreatedAtDateTime) BeforeEquals(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r contactFormSubmissionsQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r contactFormSubmissionsQueryCreatedAtDateTime) AfterEquals(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r contactFormSubmissionsQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type contactFormSubmissionsQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r contactFormSubmissionsQueryUpdatedAtDateTime) Set(value DateTime) contactFormSubmissionsSetParam {

	return contactFormSubmissionsSetParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r contactFormSubmissionsQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) contactFormSubmissionsSetParam {
	if value == nil {
		return contactFormSubmissionsSetParam{}
	}

	return r.Set(*value)
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) Equals(value DateTime) contactFormSubmissionsWithPrismaUpdatedAtEqualsParam {

	return contactFormSubmissionsWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) contactFormSubmissionsWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return contactFormSubmissionsWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) Order(direction SortOrder) contactFormSubmissionsDefaultParam {
	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: direction,
		},
	}
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) Cursor(cursor DateTime) contactFormSubmissionsCursorParam {
	return contactFormSubmissionsCursorParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: cursor,
		},
	}
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) In(value []DateTime) contactFormSubmissionsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) InIfPresent(value []DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.In(value)
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) NotIn(value []DateTime) contactFormSubmissionsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) Lt(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) Lte(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) Gt(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) Gte(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) Not(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r contactFormSubmissionsQueryUpdatedAtDateTime) Before(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r contactFormSubmissionsQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r contactFormSubmissionsQueryUpdatedAtDateTime) After(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r contactFormSubmissionsQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r contactFormSubmissionsQueryUpdatedAtDateTime) BeforeEquals(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r contactFormSubmissionsQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r contactFormSubmissionsQueryUpdatedAtDateTime) AfterEquals(value DateTime) contactFormSubmissionsDefaultParam {

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r contactFormSubmissionsQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) contactFormSubmissionsDefaultParam {
	if value == nil {
		return contactFormSubmissionsDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type contactFormSubmissionsQueryUsersusers struct{}

type contactFormSubmissionsQueryUsersRelations struct{}

// ContactFormSubmissions -> Users
//
// @relation
// @optional
func (contactFormSubmissionsQueryUsersRelations) Where(
	params ...UsersWhereParam,
) contactFormSubmissionsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return contactFormSubmissionsDefaultParam{
		data: builder.Field{
			Name: "users",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (contactFormSubmissionsQueryUsersRelations) Fetch() contactFormSubmissionsToUsersFindUnique {
	var v contactFormSubmissionsToUsersFindUnique

	v.query.Operation = "query"
	v.query.Method = "users"
	v.query.Outputs = usersOutput

	return v
}

func (r contactFormSubmissionsQueryUsersRelations) Link(
	params UsersWhereParam,
) contactFormSubmissionsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return contactFormSubmissionsSetParam{}
	}

	fields = append(fields, f)

	return contactFormSubmissionsSetParam{
		data: builder.Field{
			Name: "users",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r contactFormSubmissionsQueryUsersRelations) Unlink() contactFormSubmissionsSetParam {
	var v contactFormSubmissionsSetParam

	v = contactFormSubmissionsSetParam{
		data: builder.Field{
			Name: "users",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// Users acts as a namespaces to access query methods for the Users model
var Users = usersQuery{}

// usersQuery exposes query functions for the users model
type usersQuery struct {

	// ID
	//
	// @required
	ID usersQueryIDString

	// Email
	//
	// @required
	// @unique
	Email usersQueryEmailString

	// HashedPassword
	//
	// @required
	HashedPassword usersQueryHashedPasswordString

	// CreatedAt
	//
	// @required
	CreatedAt usersQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt usersQueryUpdatedAtDateTime

	// EmailVerified
	//
	// @required
	EmailVerified usersQueryEmailVerifiedBoolean

	// EmailVerificationCode
	//
	// @optional
	EmailVerificationCode usersQueryEmailVerificationCodeString

	// PasswordResetCode
	//
	// @optional
	PasswordResetCode usersQueryPasswordResetCodeString

	// PasswordAt
	//
	// @required
	PasswordAt usersQueryPasswordAtDateTime

	// DisplayName
	//
	// @optional
	DisplayName usersQueryDisplayNameString

	// AvatarFileKey
	//
	// @optional
	AvatarFileKey usersQueryAvatarFileKeyString

	ContactFormSubmissions usersQueryContactFormSubmissionsRelations

	TeamsUsers usersQueryTeamsUsersRelations
}

func (usersQuery) Not(params ...UsersWhereParam) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (usersQuery) Or(params ...UsersWhereParam) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (usersQuery) And(params ...UsersWhereParam) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type usersQueryIDString struct{}

// Set the required value of ID
func (r usersQueryIDString) Set(value string) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r usersQueryIDString) SetIfPresent(value *string) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryIDString) Equals(value string) usersWithPrismaIDEqualsUniqueParam {

	return usersWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) EqualsIfPresent(value *string) usersWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return usersWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryIDString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r usersQueryIDString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r usersQueryIDString) In(value []string) usersParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryIDString) InIfPresent(value []string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.In(value)
}

func (r usersQueryIDString) NotIn(value []string) usersParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryIDString) NotInIfPresent(value []string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.NotIn(value)
}

func (r usersQueryIDString) Lt(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) LtIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Lt(*value)
}

func (r usersQueryIDString) Lte(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) LteIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Lte(*value)
}

func (r usersQueryIDString) Gt(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) GtIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Gt(*value)
}

func (r usersQueryIDString) Gte(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) GteIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Gte(*value)
}

func (r usersQueryIDString) Contains(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) ContainsIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Contains(*value)
}

func (r usersQueryIDString) StartsWith(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) StartsWithIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryIDString) EndsWith(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) EndsWithIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryIDString) Mode(value QueryMode) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) ModeIfPresent(value *QueryMode) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Mode(*value)
}

func (r usersQueryIDString) Not(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) NotIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryIDString) HasPrefix(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryIDString) HasPrefixIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryIDString) HasSuffix(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryIDString) HasSuffixIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type usersQueryEmailString struct{}

// Set the required value of Email
func (r usersQueryEmailString) Set(value string) usersWithPrismaEmailSetParam {

	return usersWithPrismaEmailSetParam{
		data: builder.Field{
			Name:  "email",
			Value: value,
		},
	}

}

// Set the optional value of Email dynamically
func (r usersQueryEmailString) SetIfPresent(value *string) usersWithPrismaEmailSetParam {
	if value == nil {
		return usersWithPrismaEmailSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryEmailString) Equals(value string) usersWithPrismaEmailEqualsUniqueParam {

	return usersWithPrismaEmailEqualsUniqueParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) EqualsIfPresent(value *string) usersWithPrismaEmailEqualsUniqueParam {
	if value == nil {
		return usersWithPrismaEmailEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryEmailString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "email",
			Value: direction,
		},
	}
}

func (r usersQueryEmailString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "email",
			Value: cursor,
		},
	}
}

func (r usersQueryEmailString) In(value []string) usersParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryEmailString) InIfPresent(value []string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.In(value)
}

func (r usersQueryEmailString) NotIn(value []string) usersParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryEmailString) NotInIfPresent(value []string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.NotIn(value)
}

func (r usersQueryEmailString) Lt(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) LtIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Lt(*value)
}

func (r usersQueryEmailString) Lte(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) LteIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Lte(*value)
}

func (r usersQueryEmailString) Gt(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) GtIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Gt(*value)
}

func (r usersQueryEmailString) Gte(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) GteIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Gte(*value)
}

func (r usersQueryEmailString) Contains(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) ContainsIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Contains(*value)
}

func (r usersQueryEmailString) StartsWith(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) StartsWithIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryEmailString) EndsWith(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) EndsWithIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryEmailString) Mode(value QueryMode) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) ModeIfPresent(value *QueryMode) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Mode(*value)
}

func (r usersQueryEmailString) Not(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) NotIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryEmailString) HasPrefix(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryEmailString) HasPrefixIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryEmailString) HasSuffix(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryEmailString) HasSuffixIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type usersQueryHashedPasswordString struct{}

// Set the required value of HashedPassword
func (r usersQueryHashedPasswordString) Set(value string) usersWithPrismaHashedPasswordSetParam {

	return usersWithPrismaHashedPasswordSetParam{
		data: builder.Field{
			Name:  "hashed_password",
			Value: value,
		},
	}

}

// Set the optional value of HashedPassword dynamically
func (r usersQueryHashedPasswordString) SetIfPresent(value *string) usersWithPrismaHashedPasswordSetParam {
	if value == nil {
		return usersWithPrismaHashedPasswordSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryHashedPasswordString) Equals(value string) usersWithPrismaHashedPasswordEqualsParam {

	return usersWithPrismaHashedPasswordEqualsParam{
		data: builder.Field{
			Name: "hashed_password",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryHashedPasswordString) EqualsIfPresent(value *string) usersWithPrismaHashedPasswordEqualsParam {
	if value == nil {
		return usersWithPrismaHashedPasswordEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryHashedPasswordString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "hashed_password",
			Value: direction,
		},
	}
}

func (r usersQueryHashedPasswordString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "hashed_password",
			Value: cursor,
		},
	}
}

func (r usersQueryHashedPasswordString) In(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "hashed_password",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryHashedPasswordString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryHashedPasswordString) NotIn(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "hashed_password",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryHashedPasswordString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryHashedPasswordString) Lt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "hashed_password",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryHashedPasswordString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryHashedPasswordString) Lte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "hashed_password",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryHashedPasswordString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryHashedPasswordString) Gt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "hashed_password",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryHashedPasswordString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryHashedPasswordString) Gte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "hashed_password",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryHashedPasswordString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryHashedPasswordString) Contains(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "hashed_password",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryHashedPasswordString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQueryHashedPasswordString) StartsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "hashed_password",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryHashedPasswordString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryHashedPasswordString) EndsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "hashed_password",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryHashedPasswordString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryHashedPasswordString) Mode(value QueryMode) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "hashed_password",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryHashedPasswordString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQueryHashedPasswordString) Not(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "hashed_password",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryHashedPasswordString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryHashedPasswordString) HasPrefix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "hashed_password",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryHashedPasswordString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryHashedPasswordString) HasSuffix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "hashed_password",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryHashedPasswordString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type usersQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r usersQueryCreatedAtDateTime) Set(value DateTime) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "created_at",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r usersQueryCreatedAtDateTime) SetIfPresent(value *DateTime) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryCreatedAtDateTime) Equals(value DateTime) usersWithPrismaCreatedAtEqualsParam {

	return usersWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) usersWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return usersWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryCreatedAtDateTime) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "created_at",
			Value: direction,
		},
	}
}

func (r usersQueryCreatedAtDateTime) Cursor(cursor DateTime) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "created_at",
			Value: cursor,
		},
	}
}

func (r usersQueryCreatedAtDateTime) In(value []DateTime) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) InIfPresent(value []DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryCreatedAtDateTime) NotIn(value []DateTime) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryCreatedAtDateTime) Lt(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) LtIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryCreatedAtDateTime) Lte(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) LteIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryCreatedAtDateTime) Gt(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) GtIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryCreatedAtDateTime) Gte(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) GteIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryCreatedAtDateTime) Not(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) NotIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r usersQueryCreatedAtDateTime) Before(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r usersQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r usersQueryCreatedAtDateTime) After(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r usersQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r usersQueryCreatedAtDateTime) BeforeEquals(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r usersQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r usersQueryCreatedAtDateTime) AfterEquals(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r usersQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type usersQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r usersQueryUpdatedAtDateTime) Set(value DateTime) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r usersQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryUpdatedAtDateTime) Equals(value DateTime) usersWithPrismaUpdatedAtEqualsParam {

	return usersWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) usersWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return usersWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryUpdatedAtDateTime) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: direction,
		},
	}
}

func (r usersQueryUpdatedAtDateTime) Cursor(cursor DateTime) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: cursor,
		},
	}
}

func (r usersQueryUpdatedAtDateTime) In(value []DateTime) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) InIfPresent(value []DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryUpdatedAtDateTime) NotIn(value []DateTime) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryUpdatedAtDateTime) Lt(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryUpdatedAtDateTime) Lte(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryUpdatedAtDateTime) Gt(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryUpdatedAtDateTime) Gte(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryUpdatedAtDateTime) Not(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r usersQueryUpdatedAtDateTime) Before(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r usersQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r usersQueryUpdatedAtDateTime) After(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r usersQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r usersQueryUpdatedAtDateTime) BeforeEquals(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r usersQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r usersQueryUpdatedAtDateTime) AfterEquals(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r usersQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type usersQueryEmailVerifiedBoolean struct{}

// Set the required value of EmailVerified
func (r usersQueryEmailVerifiedBoolean) Set(value bool) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "email_verified",
			Value: value,
		},
	}

}

// Set the optional value of EmailVerified dynamically
func (r usersQueryEmailVerifiedBoolean) SetIfPresent(value *bool) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryEmailVerifiedBoolean) Equals(value bool) usersWithPrismaEmailVerifiedEqualsParam {

	return usersWithPrismaEmailVerifiedEqualsParam{
		data: builder.Field{
			Name: "email_verified",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailVerifiedBoolean) EqualsIfPresent(value *bool) usersWithPrismaEmailVerifiedEqualsParam {
	if value == nil {
		return usersWithPrismaEmailVerifiedEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryEmailVerifiedBoolean) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "email_verified",
			Value: direction,
		},
	}
}

func (r usersQueryEmailVerifiedBoolean) Cursor(cursor bool) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "email_verified",
			Value: cursor,
		},
	}
}

// base struct
type usersQueryEmailVerificationCodeString struct{}

// Set the optional value of EmailVerificationCode
func (r usersQueryEmailVerificationCodeString) Set(value string) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "email_verification_code",
			Value: value,
		},
	}

}

// Set the optional value of EmailVerificationCode dynamically
func (r usersQueryEmailVerificationCodeString) SetIfPresent(value *string) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of EmailVerificationCode dynamically
func (r usersQueryEmailVerificationCodeString) SetOptional(value *string) usersSetParam {
	if value == nil {

		var v *string
		return usersSetParam{
			data: builder.Field{
				Name:  "email_verification_code",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r usersQueryEmailVerificationCodeString) Equals(value string) usersWithPrismaEmailVerificationCodeEqualsParam {

	return usersWithPrismaEmailVerificationCodeEqualsParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailVerificationCodeString) EqualsIfPresent(value *string) usersWithPrismaEmailVerificationCodeEqualsParam {
	if value == nil {
		return usersWithPrismaEmailVerificationCodeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryEmailVerificationCodeString) EqualsOptional(value *string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailVerificationCodeString) IsNull() usersDefaultParam {
	var str *string = nil
	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r usersQueryEmailVerificationCodeString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "email_verification_code",
			Value: direction,
		},
	}
}

func (r usersQueryEmailVerificationCodeString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "email_verification_code",
			Value: cursor,
		},
	}
}

func (r usersQueryEmailVerificationCodeString) In(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryEmailVerificationCodeString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryEmailVerificationCodeString) NotIn(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryEmailVerificationCodeString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryEmailVerificationCodeString) Lt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailVerificationCodeString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryEmailVerificationCodeString) Lte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailVerificationCodeString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryEmailVerificationCodeString) Gt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailVerificationCodeString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryEmailVerificationCodeString) Gte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailVerificationCodeString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryEmailVerificationCodeString) Contains(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailVerificationCodeString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQueryEmailVerificationCodeString) StartsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailVerificationCodeString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryEmailVerificationCodeString) EndsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailVerificationCodeString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryEmailVerificationCodeString) Mode(value QueryMode) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailVerificationCodeString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQueryEmailVerificationCodeString) Not(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailVerificationCodeString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryEmailVerificationCodeString) HasPrefix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryEmailVerificationCodeString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryEmailVerificationCodeString) HasSuffix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email_verification_code",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryEmailVerificationCodeString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type usersQueryPasswordResetCodeString struct{}

// Set the optional value of PasswordResetCode
func (r usersQueryPasswordResetCodeString) Set(value string) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "password_reset_code",
			Value: value,
		},
	}

}

// Set the optional value of PasswordResetCode dynamically
func (r usersQueryPasswordResetCodeString) SetIfPresent(value *string) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of PasswordResetCode dynamically
func (r usersQueryPasswordResetCodeString) SetOptional(value *string) usersSetParam {
	if value == nil {

		var v *string
		return usersSetParam{
			data: builder.Field{
				Name:  "password_reset_code",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r usersQueryPasswordResetCodeString) Equals(value string) usersWithPrismaPasswordResetCodeEqualsParam {

	return usersWithPrismaPasswordResetCodeEqualsParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordResetCodeString) EqualsIfPresent(value *string) usersWithPrismaPasswordResetCodeEqualsParam {
	if value == nil {
		return usersWithPrismaPasswordResetCodeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryPasswordResetCodeString) EqualsOptional(value *string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordResetCodeString) IsNull() usersDefaultParam {
	var str *string = nil
	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r usersQueryPasswordResetCodeString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "password_reset_code",
			Value: direction,
		},
	}
}

func (r usersQueryPasswordResetCodeString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "password_reset_code",
			Value: cursor,
		},
	}
}

func (r usersQueryPasswordResetCodeString) In(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryPasswordResetCodeString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryPasswordResetCodeString) NotIn(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryPasswordResetCodeString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryPasswordResetCodeString) Lt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordResetCodeString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryPasswordResetCodeString) Lte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordResetCodeString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryPasswordResetCodeString) Gt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordResetCodeString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryPasswordResetCodeString) Gte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordResetCodeString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryPasswordResetCodeString) Contains(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordResetCodeString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQueryPasswordResetCodeString) StartsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordResetCodeString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryPasswordResetCodeString) EndsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordResetCodeString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryPasswordResetCodeString) Mode(value QueryMode) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordResetCodeString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQueryPasswordResetCodeString) Not(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordResetCodeString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryPasswordResetCodeString) HasPrefix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryPasswordResetCodeString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryPasswordResetCodeString) HasSuffix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_reset_code",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryPasswordResetCodeString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type usersQueryPasswordAtDateTime struct{}

// Set the required value of PasswordAt
func (r usersQueryPasswordAtDateTime) Set(value DateTime) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "password_at",
			Value: value,
		},
	}

}

// Set the optional value of PasswordAt dynamically
func (r usersQueryPasswordAtDateTime) SetIfPresent(value *DateTime) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryPasswordAtDateTime) Equals(value DateTime) usersWithPrismaPasswordAtEqualsParam {

	return usersWithPrismaPasswordAtEqualsParam{
		data: builder.Field{
			Name: "password_at",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordAtDateTime) EqualsIfPresent(value *DateTime) usersWithPrismaPasswordAtEqualsParam {
	if value == nil {
		return usersWithPrismaPasswordAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryPasswordAtDateTime) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "password_at",
			Value: direction,
		},
	}
}

func (r usersQueryPasswordAtDateTime) Cursor(cursor DateTime) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "password_at",
			Value: cursor,
		},
	}
}

func (r usersQueryPasswordAtDateTime) In(value []DateTime) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_at",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryPasswordAtDateTime) InIfPresent(value []DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryPasswordAtDateTime) NotIn(value []DateTime) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_at",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryPasswordAtDateTime) NotInIfPresent(value []DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryPasswordAtDateTime) Lt(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordAtDateTime) LtIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryPasswordAtDateTime) Lte(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordAtDateTime) LteIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryPasswordAtDateTime) Gt(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordAtDateTime) GtIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryPasswordAtDateTime) Gte(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordAtDateTime) GteIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryPasswordAtDateTime) Not(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_at",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordAtDateTime) NotIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r usersQueryPasswordAtDateTime) Before(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r usersQueryPasswordAtDateTime) BeforeIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r usersQueryPasswordAtDateTime) After(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r usersQueryPasswordAtDateTime) AfterIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r usersQueryPasswordAtDateTime) BeforeEquals(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r usersQueryPasswordAtDateTime) BeforeEqualsIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r usersQueryPasswordAtDateTime) AfterEquals(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r usersQueryPasswordAtDateTime) AfterEqualsIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type usersQueryDisplayNameString struct{}

// Set the optional value of DisplayName
func (r usersQueryDisplayNameString) Set(value string) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "display_name",
			Value: value,
		},
	}

}

// Set the optional value of DisplayName dynamically
func (r usersQueryDisplayNameString) SetIfPresent(value *string) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of DisplayName dynamically
func (r usersQueryDisplayNameString) SetOptional(value *string) usersSetParam {
	if value == nil {

		var v *string
		return usersSetParam{
			data: builder.Field{
				Name:  "display_name",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r usersQueryDisplayNameString) Equals(value string) usersWithPrismaDisplayNameEqualsParam {

	return usersWithPrismaDisplayNameEqualsParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryDisplayNameString) EqualsIfPresent(value *string) usersWithPrismaDisplayNameEqualsParam {
	if value == nil {
		return usersWithPrismaDisplayNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryDisplayNameString) EqualsOptional(value *string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryDisplayNameString) IsNull() usersDefaultParam {
	var str *string = nil
	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r usersQueryDisplayNameString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "display_name",
			Value: direction,
		},
	}
}

func (r usersQueryDisplayNameString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "display_name",
			Value: cursor,
		},
	}
}

func (r usersQueryDisplayNameString) In(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryDisplayNameString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryDisplayNameString) NotIn(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryDisplayNameString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryDisplayNameString) Lt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryDisplayNameString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryDisplayNameString) Lte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryDisplayNameString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryDisplayNameString) Gt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryDisplayNameString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryDisplayNameString) Gte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryDisplayNameString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryDisplayNameString) Contains(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryDisplayNameString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQueryDisplayNameString) StartsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryDisplayNameString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryDisplayNameString) EndsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryDisplayNameString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryDisplayNameString) Mode(value QueryMode) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryDisplayNameString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQueryDisplayNameString) Not(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryDisplayNameString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryDisplayNameString) HasPrefix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryDisplayNameString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryDisplayNameString) HasSuffix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "display_name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryDisplayNameString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type usersQueryAvatarFileKeyString struct{}

// Set the optional value of AvatarFileKey
func (r usersQueryAvatarFileKeyString) Set(value string) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "avatar_file_key",
			Value: value,
		},
	}

}

// Set the optional value of AvatarFileKey dynamically
func (r usersQueryAvatarFileKeyString) SetIfPresent(value *string) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of AvatarFileKey dynamically
func (r usersQueryAvatarFileKeyString) SetOptional(value *string) usersSetParam {
	if value == nil {

		var v *string
		return usersSetParam{
			data: builder.Field{
				Name:  "avatar_file_key",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r usersQueryAvatarFileKeyString) Equals(value string) usersWithPrismaAvatarFileKeyEqualsParam {

	return usersWithPrismaAvatarFileKeyEqualsParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAvatarFileKeyString) EqualsIfPresent(value *string) usersWithPrismaAvatarFileKeyEqualsParam {
	if value == nil {
		return usersWithPrismaAvatarFileKeyEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryAvatarFileKeyString) EqualsOptional(value *string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAvatarFileKeyString) IsNull() usersDefaultParam {
	var str *string = nil
	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r usersQueryAvatarFileKeyString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "avatar_file_key",
			Value: direction,
		},
	}
}

func (r usersQueryAvatarFileKeyString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "avatar_file_key",
			Value: cursor,
		},
	}
}

func (r usersQueryAvatarFileKeyString) In(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryAvatarFileKeyString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryAvatarFileKeyString) NotIn(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryAvatarFileKeyString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryAvatarFileKeyString) Lt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAvatarFileKeyString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryAvatarFileKeyString) Lte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAvatarFileKeyString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryAvatarFileKeyString) Gt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAvatarFileKeyString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryAvatarFileKeyString) Gte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAvatarFileKeyString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryAvatarFileKeyString) Contains(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAvatarFileKeyString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQueryAvatarFileKeyString) StartsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAvatarFileKeyString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryAvatarFileKeyString) EndsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAvatarFileKeyString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryAvatarFileKeyString) Mode(value QueryMode) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAvatarFileKeyString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQueryAvatarFileKeyString) Not(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAvatarFileKeyString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryAvatarFileKeyString) HasPrefix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryAvatarFileKeyString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryAvatarFileKeyString) HasSuffix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "avatar_file_key",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryAvatarFileKeyString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type usersQueryContactFormSubmissionscontact_form_submissions struct{}

type usersQueryContactFormSubmissionsRelations struct{}

// Users -> ContactFormSubmissions
//
// @relation
// @required
func (usersQueryContactFormSubmissionsRelations) Some(
	params ...ContactFormSubmissionsWhereParam,
) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "contact_form_submissions",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Users -> ContactFormSubmissions
//
// @relation
// @required
func (usersQueryContactFormSubmissionsRelations) Every(
	params ...ContactFormSubmissionsWhereParam,
) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "contact_form_submissions",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (usersQueryContactFormSubmissionsRelations) Fetch(

	params ...ContactFormSubmissionsWhereParam,

) usersToContactFormSubmissionsFindMany {
	var v usersToContactFormSubmissionsFindMany

	v.query.Operation = "query"
	v.query.Method = "contact_form_submissions"
	v.query.Outputs = contactFormSubmissionsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r usersQueryContactFormSubmissionsRelations) Link(
	params ...ContactFormSubmissionsWhereParam,
) usersSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersSetParam{
		data: builder.Field{
			Name: "contact_form_submissions",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r usersQueryContactFormSubmissionsRelations) Unlink(
	params ...ContactFormSubmissionsWhereParam,
) usersSetParam {
	var v usersSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = usersSetParam{
		data: builder.Field{
			Name: "contact_form_submissions",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type usersQueryTeamsUsersteams_users struct{}

type usersQueryTeamsUsersRelations struct{}

// Users -> TeamsUsers
//
// @relation
// @required
func (usersQueryTeamsUsersRelations) Some(
	params ...TeamsUsersWhereParam,
) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "teams_users",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Users -> TeamsUsers
//
// @relation
// @required
func (usersQueryTeamsUsersRelations) Every(
	params ...TeamsUsersWhereParam,
) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "teams_users",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (usersQueryTeamsUsersRelations) Fetch(

	params ...TeamsUsersWhereParam,

) usersToTeamsUsersFindMany {
	var v usersToTeamsUsersFindMany

	v.query.Operation = "query"
	v.query.Method = "teams_users"
	v.query.Outputs = teamsUsersOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r usersQueryTeamsUsersRelations) Link(
	params ...TeamsUsersWhereParam,
) usersSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersSetParam{
		data: builder.Field{
			Name: "teams_users",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r usersQueryTeamsUsersRelations) Unlink(
	params ...TeamsUsersWhereParam,
) usersSetParam {
	var v usersSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = usersSetParam{
		data: builder.Field{
			Name: "teams_users",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// Invitations acts as a namespaces to access query methods for the Invitations model
var Invitations = invitationsQuery{}

// invitationsQuery exposes query functions for the invitations model
type invitationsQuery struct {

	// TeamID
	//
	// @required
	TeamID invitationsQueryTeamIDString

	// Email
	//
	// @required
	Email invitationsQueryEmailString

	// CreatedAt
	//
	// @required
	CreatedAt invitationsQueryCreatedAtDateTime

	Teams invitationsQueryTeamsRelations
}

func (invitationsQuery) Not(params ...InvitationsWhereParam) invitationsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return invitationsDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (invitationsQuery) Or(params ...InvitationsWhereParam) invitationsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return invitationsDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (invitationsQuery) And(params ...InvitationsWhereParam) invitationsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return invitationsDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (invitationsQuery) TeamIDEmail(
	_teamID InvitationsWithPrismaTeamIDWhereParam,

	_email InvitationsWithPrismaEmailWhereParam,
) InvitationsEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _teamID.field())
	fields = append(fields, _email.field())

	return invitationsEqualsUniqueParam{
		data: builder.Field{
			Name:   "team_id_email",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type invitationsQueryTeamIDString struct{}

// Set the required value of TeamID
func (r invitationsQueryTeamIDString) Set(value string) invitationsSetParam {

	return invitationsSetParam{
		data: builder.Field{
			Name:  "team_id",
			Value: value,
		},
	}

}

// Set the optional value of TeamID dynamically
func (r invitationsQueryTeamIDString) SetIfPresent(value *string) invitationsSetParam {
	if value == nil {
		return invitationsSetParam{}
	}

	return r.Set(*value)
}

func (r invitationsQueryTeamIDString) Equals(value string) invitationsWithPrismaTeamIDEqualsParam {

	return invitationsWithPrismaTeamIDEqualsParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryTeamIDString) EqualsIfPresent(value *string) invitationsWithPrismaTeamIDEqualsParam {
	if value == nil {
		return invitationsWithPrismaTeamIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r invitationsQueryTeamIDString) Order(direction SortOrder) invitationsDefaultParam {
	return invitationsDefaultParam{
		data: builder.Field{
			Name:  "team_id",
			Value: direction,
		},
	}
}

func (r invitationsQueryTeamIDString) Cursor(cursor string) invitationsCursorParam {
	return invitationsCursorParam{
		data: builder.Field{
			Name:  "team_id",
			Value: cursor,
		},
	}
}

func (r invitationsQueryTeamIDString) In(value []string) invitationsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r invitationsQueryTeamIDString) InIfPresent(value []string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.In(value)
}

func (r invitationsQueryTeamIDString) NotIn(value []string) invitationsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r invitationsQueryTeamIDString) NotInIfPresent(value []string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r invitationsQueryTeamIDString) Lt(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryTeamIDString) LtIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r invitationsQueryTeamIDString) Lte(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryTeamIDString) LteIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r invitationsQueryTeamIDString) Gt(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryTeamIDString) GtIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r invitationsQueryTeamIDString) Gte(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryTeamIDString) GteIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r invitationsQueryTeamIDString) Contains(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryTeamIDString) ContainsIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r invitationsQueryTeamIDString) StartsWith(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryTeamIDString) StartsWithIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r invitationsQueryTeamIDString) EndsWith(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryTeamIDString) EndsWithIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r invitationsQueryTeamIDString) Mode(value QueryMode) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryTeamIDString) ModeIfPresent(value *QueryMode) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r invitationsQueryTeamIDString) Not(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryTeamIDString) NotIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r invitationsQueryTeamIDString) HasPrefix(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r invitationsQueryTeamIDString) HasPrefixIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r invitationsQueryTeamIDString) HasSuffix(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r invitationsQueryTeamIDString) HasSuffixIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type invitationsQueryEmailString struct{}

// Set the required value of Email
func (r invitationsQueryEmailString) Set(value string) invitationsWithPrismaEmailSetParam {

	return invitationsWithPrismaEmailSetParam{
		data: builder.Field{
			Name:  "email",
			Value: value,
		},
	}

}

// Set the optional value of Email dynamically
func (r invitationsQueryEmailString) SetIfPresent(value *string) invitationsWithPrismaEmailSetParam {
	if value == nil {
		return invitationsWithPrismaEmailSetParam{}
	}

	return r.Set(*value)
}

func (r invitationsQueryEmailString) Equals(value string) invitationsWithPrismaEmailEqualsParam {

	return invitationsWithPrismaEmailEqualsParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryEmailString) EqualsIfPresent(value *string) invitationsWithPrismaEmailEqualsParam {
	if value == nil {
		return invitationsWithPrismaEmailEqualsParam{}
	}
	return r.Equals(*value)
}

func (r invitationsQueryEmailString) Order(direction SortOrder) invitationsDefaultParam {
	return invitationsDefaultParam{
		data: builder.Field{
			Name:  "email",
			Value: direction,
		},
	}
}

func (r invitationsQueryEmailString) Cursor(cursor string) invitationsCursorParam {
	return invitationsCursorParam{
		data: builder.Field{
			Name:  "email",
			Value: cursor,
		},
	}
}

func (r invitationsQueryEmailString) In(value []string) invitationsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r invitationsQueryEmailString) InIfPresent(value []string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.In(value)
}

func (r invitationsQueryEmailString) NotIn(value []string) invitationsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r invitationsQueryEmailString) NotInIfPresent(value []string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r invitationsQueryEmailString) Lt(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryEmailString) LtIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r invitationsQueryEmailString) Lte(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryEmailString) LteIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r invitationsQueryEmailString) Gt(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryEmailString) GtIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r invitationsQueryEmailString) Gte(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryEmailString) GteIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r invitationsQueryEmailString) Contains(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryEmailString) ContainsIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r invitationsQueryEmailString) StartsWith(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryEmailString) StartsWithIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r invitationsQueryEmailString) EndsWith(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryEmailString) EndsWithIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r invitationsQueryEmailString) Mode(value QueryMode) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryEmailString) ModeIfPresent(value *QueryMode) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r invitationsQueryEmailString) Not(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryEmailString) NotIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r invitationsQueryEmailString) HasPrefix(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r invitationsQueryEmailString) HasPrefixIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r invitationsQueryEmailString) HasSuffix(value string) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r invitationsQueryEmailString) HasSuffixIfPresent(value *string) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type invitationsQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r invitationsQueryCreatedAtDateTime) Set(value DateTime) invitationsSetParam {

	return invitationsSetParam{
		data: builder.Field{
			Name:  "created_at",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r invitationsQueryCreatedAtDateTime) SetIfPresent(value *DateTime) invitationsSetParam {
	if value == nil {
		return invitationsSetParam{}
	}

	return r.Set(*value)
}

func (r invitationsQueryCreatedAtDateTime) Equals(value DateTime) invitationsWithPrismaCreatedAtEqualsParam {

	return invitationsWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) invitationsWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return invitationsWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r invitationsQueryCreatedAtDateTime) Order(direction SortOrder) invitationsDefaultParam {
	return invitationsDefaultParam{
		data: builder.Field{
			Name:  "created_at",
			Value: direction,
		},
	}
}

func (r invitationsQueryCreatedAtDateTime) Cursor(cursor DateTime) invitationsCursorParam {
	return invitationsCursorParam{
		data: builder.Field{
			Name:  "created_at",
			Value: cursor,
		},
	}
}

func (r invitationsQueryCreatedAtDateTime) In(value []DateTime) invitationsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r invitationsQueryCreatedAtDateTime) InIfPresent(value []DateTime) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.In(value)
}

func (r invitationsQueryCreatedAtDateTime) NotIn(value []DateTime) invitationsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r invitationsQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r invitationsQueryCreatedAtDateTime) Lt(value DateTime) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryCreatedAtDateTime) LtIfPresent(value *DateTime) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r invitationsQueryCreatedAtDateTime) Lte(value DateTime) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryCreatedAtDateTime) LteIfPresent(value *DateTime) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r invitationsQueryCreatedAtDateTime) Gt(value DateTime) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryCreatedAtDateTime) GtIfPresent(value *DateTime) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r invitationsQueryCreatedAtDateTime) Gte(value DateTime) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryCreatedAtDateTime) GteIfPresent(value *DateTime) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r invitationsQueryCreatedAtDateTime) Not(value DateTime) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r invitationsQueryCreatedAtDateTime) NotIfPresent(value *DateTime) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r invitationsQueryCreatedAtDateTime) Before(value DateTime) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r invitationsQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r invitationsQueryCreatedAtDateTime) After(value DateTime) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r invitationsQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r invitationsQueryCreatedAtDateTime) BeforeEquals(value DateTime) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r invitationsQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r invitationsQueryCreatedAtDateTime) AfterEquals(value DateTime) invitationsDefaultParam {

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r invitationsQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) invitationsDefaultParam {
	if value == nil {
		return invitationsDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type invitationsQueryTeamsteams struct{}

type invitationsQueryTeamsRelations struct{}

// Invitations -> Teams
//
// @relation
// @required
func (invitationsQueryTeamsRelations) Where(
	params ...TeamsWhereParam,
) invitationsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return invitationsDefaultParam{
		data: builder.Field{
			Name: "teams",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (invitationsQueryTeamsRelations) Fetch() invitationsToTeamsFindUnique {
	var v invitationsToTeamsFindUnique

	v.query.Operation = "query"
	v.query.Method = "teams"
	v.query.Outputs = teamsOutput

	return v
}

func (r invitationsQueryTeamsRelations) Link(
	params TeamsWhereParam,
) invitationsWithPrismaTeamsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return invitationsWithPrismaTeamsSetParam{}
	}

	fields = append(fields, f)

	return invitationsWithPrismaTeamsSetParam{
		data: builder.Field{
			Name: "teams",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r invitationsQueryTeamsRelations) Unlink() invitationsWithPrismaTeamsSetParam {
	var v invitationsWithPrismaTeamsSetParam

	v = invitationsWithPrismaTeamsSetParam{
		data: builder.Field{
			Name: "teams",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// Projects acts as a namespaces to access query methods for the Projects model
var Projects = projectsQuery{}

// projectsQuery exposes query functions for the projects model
type projectsQuery struct {

	// ID
	//
	// @required
	ID projectsQueryIDString

	// Name
	//
	// @required
	Name projectsQueryNameString

	// CreatedAt
	//
	// @required
	CreatedAt projectsQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt projectsQueryUpdatedAtDateTime

	TeamsProjects projectsQueryTeamsProjectsRelations
}

func (projectsQuery) Not(params ...ProjectsWhereParam) projectsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return projectsDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (projectsQuery) Or(params ...ProjectsWhereParam) projectsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return projectsDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (projectsQuery) And(params ...ProjectsWhereParam) projectsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return projectsDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type projectsQueryIDString struct{}

// Set the required value of ID
func (r projectsQueryIDString) Set(value string) projectsSetParam {

	return projectsSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r projectsQueryIDString) SetIfPresent(value *string) projectsSetParam {
	if value == nil {
		return projectsSetParam{}
	}

	return r.Set(*value)
}

func (r projectsQueryIDString) Equals(value string) projectsWithPrismaIDEqualsUniqueParam {

	return projectsWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryIDString) EqualsIfPresent(value *string) projectsWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return projectsWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r projectsQueryIDString) Order(direction SortOrder) projectsDefaultParam {
	return projectsDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r projectsQueryIDString) Cursor(cursor string) projectsCursorParam {
	return projectsCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r projectsQueryIDString) In(value []string) projectsParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return projectsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r projectsQueryIDString) InIfPresent(value []string) projectsParamUnique {
	if value == nil {
		return projectsParamUnique{}
	}
	return r.In(value)
}

func (r projectsQueryIDString) NotIn(value []string) projectsParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return projectsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r projectsQueryIDString) NotInIfPresent(value []string) projectsParamUnique {
	if value == nil {
		return projectsParamUnique{}
	}
	return r.NotIn(value)
}

func (r projectsQueryIDString) Lt(value string) projectsParamUnique {

	return projectsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryIDString) LtIfPresent(value *string) projectsParamUnique {
	if value == nil {
		return projectsParamUnique{}
	}
	return r.Lt(*value)
}

func (r projectsQueryIDString) Lte(value string) projectsParamUnique {

	return projectsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryIDString) LteIfPresent(value *string) projectsParamUnique {
	if value == nil {
		return projectsParamUnique{}
	}
	return r.Lte(*value)
}

func (r projectsQueryIDString) Gt(value string) projectsParamUnique {

	return projectsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryIDString) GtIfPresent(value *string) projectsParamUnique {
	if value == nil {
		return projectsParamUnique{}
	}
	return r.Gt(*value)
}

func (r projectsQueryIDString) Gte(value string) projectsParamUnique {

	return projectsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryIDString) GteIfPresent(value *string) projectsParamUnique {
	if value == nil {
		return projectsParamUnique{}
	}
	return r.Gte(*value)
}

func (r projectsQueryIDString) Contains(value string) projectsParamUnique {

	return projectsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryIDString) ContainsIfPresent(value *string) projectsParamUnique {
	if value == nil {
		return projectsParamUnique{}
	}
	return r.Contains(*value)
}

func (r projectsQueryIDString) StartsWith(value string) projectsParamUnique {

	return projectsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryIDString) StartsWithIfPresent(value *string) projectsParamUnique {
	if value == nil {
		return projectsParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r projectsQueryIDString) EndsWith(value string) projectsParamUnique {

	return projectsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryIDString) EndsWithIfPresent(value *string) projectsParamUnique {
	if value == nil {
		return projectsParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r projectsQueryIDString) Mode(value QueryMode) projectsParamUnique {

	return projectsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryIDString) ModeIfPresent(value *QueryMode) projectsParamUnique {
	if value == nil {
		return projectsParamUnique{}
	}
	return r.Mode(*value)
}

func (r projectsQueryIDString) Not(value string) projectsParamUnique {

	return projectsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryIDString) NotIfPresent(value *string) projectsParamUnique {
	if value == nil {
		return projectsParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r projectsQueryIDString) HasPrefix(value string) projectsParamUnique {

	return projectsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r projectsQueryIDString) HasPrefixIfPresent(value *string) projectsParamUnique {
	if value == nil {
		return projectsParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r projectsQueryIDString) HasSuffix(value string) projectsParamUnique {

	return projectsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r projectsQueryIDString) HasSuffixIfPresent(value *string) projectsParamUnique {
	if value == nil {
		return projectsParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type projectsQueryNameString struct{}

// Set the required value of Name
func (r projectsQueryNameString) Set(value string) projectsWithPrismaNameSetParam {

	return projectsWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r projectsQueryNameString) SetIfPresent(value *string) projectsWithPrismaNameSetParam {
	if value == nil {
		return projectsWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r projectsQueryNameString) Equals(value string) projectsWithPrismaNameEqualsParam {

	return projectsWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryNameString) EqualsIfPresent(value *string) projectsWithPrismaNameEqualsParam {
	if value == nil {
		return projectsWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r projectsQueryNameString) Order(direction SortOrder) projectsDefaultParam {
	return projectsDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r projectsQueryNameString) Cursor(cursor string) projectsCursorParam {
	return projectsCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r projectsQueryNameString) In(value []string) projectsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return projectsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r projectsQueryNameString) InIfPresent(value []string) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.In(value)
}

func (r projectsQueryNameString) NotIn(value []string) projectsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return projectsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r projectsQueryNameString) NotInIfPresent(value []string) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r projectsQueryNameString) Lt(value string) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryNameString) LtIfPresent(value *string) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r projectsQueryNameString) Lte(value string) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryNameString) LteIfPresent(value *string) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r projectsQueryNameString) Gt(value string) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryNameString) GtIfPresent(value *string) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r projectsQueryNameString) Gte(value string) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryNameString) GteIfPresent(value *string) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r projectsQueryNameString) Contains(value string) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryNameString) ContainsIfPresent(value *string) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r projectsQueryNameString) StartsWith(value string) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryNameString) StartsWithIfPresent(value *string) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r projectsQueryNameString) EndsWith(value string) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryNameString) EndsWithIfPresent(value *string) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r projectsQueryNameString) Mode(value QueryMode) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryNameString) ModeIfPresent(value *QueryMode) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r projectsQueryNameString) Not(value string) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryNameString) NotIfPresent(value *string) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r projectsQueryNameString) HasPrefix(value string) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r projectsQueryNameString) HasPrefixIfPresent(value *string) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r projectsQueryNameString) HasSuffix(value string) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r projectsQueryNameString) HasSuffixIfPresent(value *string) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type projectsQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r projectsQueryCreatedAtDateTime) Set(value DateTime) projectsSetParam {

	return projectsSetParam{
		data: builder.Field{
			Name:  "created_at",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r projectsQueryCreatedAtDateTime) SetIfPresent(value *DateTime) projectsSetParam {
	if value == nil {
		return projectsSetParam{}
	}

	return r.Set(*value)
}

func (r projectsQueryCreatedAtDateTime) Equals(value DateTime) projectsWithPrismaCreatedAtEqualsParam {

	return projectsWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) projectsWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return projectsWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r projectsQueryCreatedAtDateTime) Order(direction SortOrder) projectsDefaultParam {
	return projectsDefaultParam{
		data: builder.Field{
			Name:  "created_at",
			Value: direction,
		},
	}
}

func (r projectsQueryCreatedAtDateTime) Cursor(cursor DateTime) projectsCursorParam {
	return projectsCursorParam{
		data: builder.Field{
			Name:  "created_at",
			Value: cursor,
		},
	}
}

func (r projectsQueryCreatedAtDateTime) In(value []DateTime) projectsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return projectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r projectsQueryCreatedAtDateTime) InIfPresent(value []DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.In(value)
}

func (r projectsQueryCreatedAtDateTime) NotIn(value []DateTime) projectsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return projectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r projectsQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r projectsQueryCreatedAtDateTime) Lt(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryCreatedAtDateTime) LtIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r projectsQueryCreatedAtDateTime) Lte(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryCreatedAtDateTime) LteIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r projectsQueryCreatedAtDateTime) Gt(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryCreatedAtDateTime) GtIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r projectsQueryCreatedAtDateTime) Gte(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryCreatedAtDateTime) GteIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r projectsQueryCreatedAtDateTime) Not(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryCreatedAtDateTime) NotIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r projectsQueryCreatedAtDateTime) Before(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r projectsQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r projectsQueryCreatedAtDateTime) After(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r projectsQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r projectsQueryCreatedAtDateTime) BeforeEquals(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r projectsQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r projectsQueryCreatedAtDateTime) AfterEquals(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r projectsQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type projectsQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r projectsQueryUpdatedAtDateTime) Set(value DateTime) projectsSetParam {

	return projectsSetParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r projectsQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) projectsSetParam {
	if value == nil {
		return projectsSetParam{}
	}

	return r.Set(*value)
}

func (r projectsQueryUpdatedAtDateTime) Equals(value DateTime) projectsWithPrismaUpdatedAtEqualsParam {

	return projectsWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) projectsWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return projectsWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r projectsQueryUpdatedAtDateTime) Order(direction SortOrder) projectsDefaultParam {
	return projectsDefaultParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: direction,
		},
	}
}

func (r projectsQueryUpdatedAtDateTime) Cursor(cursor DateTime) projectsCursorParam {
	return projectsCursorParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: cursor,
		},
	}
}

func (r projectsQueryUpdatedAtDateTime) In(value []DateTime) projectsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return projectsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r projectsQueryUpdatedAtDateTime) InIfPresent(value []DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.In(value)
}

func (r projectsQueryUpdatedAtDateTime) NotIn(value []DateTime) projectsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return projectsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r projectsQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r projectsQueryUpdatedAtDateTime) Lt(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r projectsQueryUpdatedAtDateTime) Lte(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r projectsQueryUpdatedAtDateTime) Gt(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r projectsQueryUpdatedAtDateTime) Gte(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r projectsQueryUpdatedAtDateTime) Not(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r projectsQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r projectsQueryUpdatedAtDateTime) Before(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r projectsQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r projectsQueryUpdatedAtDateTime) After(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r projectsQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r projectsQueryUpdatedAtDateTime) BeforeEquals(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r projectsQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r projectsQueryUpdatedAtDateTime) AfterEquals(value DateTime) projectsDefaultParam {

	return projectsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r projectsQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) projectsDefaultParam {
	if value == nil {
		return projectsDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type projectsQueryTeamsProjectsteams_projects struct{}

type projectsQueryTeamsProjectsRelations struct{}

// Projects -> TeamsProjects
//
// @relation
// @required
func (projectsQueryTeamsProjectsRelations) Some(
	params ...TeamsProjectsWhereParam,
) projectsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return projectsDefaultParam{
		data: builder.Field{
			Name: "teams_projects",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Projects -> TeamsProjects
//
// @relation
// @required
func (projectsQueryTeamsProjectsRelations) Every(
	params ...TeamsProjectsWhereParam,
) projectsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return projectsDefaultParam{
		data: builder.Field{
			Name: "teams_projects",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (projectsQueryTeamsProjectsRelations) Fetch(

	params ...TeamsProjectsWhereParam,

) projectsToTeamsProjectsFindMany {
	var v projectsToTeamsProjectsFindMany

	v.query.Operation = "query"
	v.query.Method = "teams_projects"
	v.query.Outputs = teamsProjectsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r projectsQueryTeamsProjectsRelations) Link(
	params ...TeamsProjectsWhereParam,
) projectsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return projectsSetParam{
		data: builder.Field{
			Name: "teams_projects",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r projectsQueryTeamsProjectsRelations) Unlink(
	params ...TeamsProjectsWhereParam,
) projectsSetParam {
	var v projectsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = projectsSetParam{
		data: builder.Field{
			Name: "teams_projects",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// Teams acts as a namespaces to access query methods for the Teams model
var Teams = teamsQuery{}

// teamsQuery exposes query functions for the teams model
type teamsQuery struct {

	// ID
	//
	// @required
	ID teamsQueryIDString

	// Name
	//
	// @required
	Name teamsQueryNameString

	// CreatedAt
	//
	// @required
	CreatedAt teamsQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt teamsQueryUpdatedAtDateTime

	Invitations teamsQueryInvitationsRelations

	TeamsProjects teamsQueryTeamsProjectsRelations

	TeamsUsers teamsQueryTeamsUsersRelations
}

func (teamsQuery) Not(params ...TeamsWhereParam) teamsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (teamsQuery) Or(params ...TeamsWhereParam) teamsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (teamsQuery) And(params ...TeamsWhereParam) teamsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type teamsQueryIDString struct{}

// Set the required value of ID
func (r teamsQueryIDString) Set(value string) teamsSetParam {

	return teamsSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r teamsQueryIDString) SetIfPresent(value *string) teamsSetParam {
	if value == nil {
		return teamsSetParam{}
	}

	return r.Set(*value)
}

func (r teamsQueryIDString) Equals(value string) teamsWithPrismaIDEqualsUniqueParam {

	return teamsWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryIDString) EqualsIfPresent(value *string) teamsWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return teamsWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r teamsQueryIDString) Order(direction SortOrder) teamsDefaultParam {
	return teamsDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r teamsQueryIDString) Cursor(cursor string) teamsCursorParam {
	return teamsCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r teamsQueryIDString) In(value []string) teamsParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsQueryIDString) InIfPresent(value []string) teamsParamUnique {
	if value == nil {
		return teamsParamUnique{}
	}
	return r.In(value)
}

func (r teamsQueryIDString) NotIn(value []string) teamsParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsQueryIDString) NotInIfPresent(value []string) teamsParamUnique {
	if value == nil {
		return teamsParamUnique{}
	}
	return r.NotIn(value)
}

func (r teamsQueryIDString) Lt(value string) teamsParamUnique {

	return teamsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryIDString) LtIfPresent(value *string) teamsParamUnique {
	if value == nil {
		return teamsParamUnique{}
	}
	return r.Lt(*value)
}

func (r teamsQueryIDString) Lte(value string) teamsParamUnique {

	return teamsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryIDString) LteIfPresent(value *string) teamsParamUnique {
	if value == nil {
		return teamsParamUnique{}
	}
	return r.Lte(*value)
}

func (r teamsQueryIDString) Gt(value string) teamsParamUnique {

	return teamsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryIDString) GtIfPresent(value *string) teamsParamUnique {
	if value == nil {
		return teamsParamUnique{}
	}
	return r.Gt(*value)
}

func (r teamsQueryIDString) Gte(value string) teamsParamUnique {

	return teamsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryIDString) GteIfPresent(value *string) teamsParamUnique {
	if value == nil {
		return teamsParamUnique{}
	}
	return r.Gte(*value)
}

func (r teamsQueryIDString) Contains(value string) teamsParamUnique {

	return teamsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryIDString) ContainsIfPresent(value *string) teamsParamUnique {
	if value == nil {
		return teamsParamUnique{}
	}
	return r.Contains(*value)
}

func (r teamsQueryIDString) StartsWith(value string) teamsParamUnique {

	return teamsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryIDString) StartsWithIfPresent(value *string) teamsParamUnique {
	if value == nil {
		return teamsParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r teamsQueryIDString) EndsWith(value string) teamsParamUnique {

	return teamsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryIDString) EndsWithIfPresent(value *string) teamsParamUnique {
	if value == nil {
		return teamsParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r teamsQueryIDString) Mode(value QueryMode) teamsParamUnique {

	return teamsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryIDString) ModeIfPresent(value *QueryMode) teamsParamUnique {
	if value == nil {
		return teamsParamUnique{}
	}
	return r.Mode(*value)
}

func (r teamsQueryIDString) Not(value string) teamsParamUnique {

	return teamsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryIDString) NotIfPresent(value *string) teamsParamUnique {
	if value == nil {
		return teamsParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r teamsQueryIDString) HasPrefix(value string) teamsParamUnique {

	return teamsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r teamsQueryIDString) HasPrefixIfPresent(value *string) teamsParamUnique {
	if value == nil {
		return teamsParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r teamsQueryIDString) HasSuffix(value string) teamsParamUnique {

	return teamsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r teamsQueryIDString) HasSuffixIfPresent(value *string) teamsParamUnique {
	if value == nil {
		return teamsParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type teamsQueryNameString struct{}

// Set the required value of Name
func (r teamsQueryNameString) Set(value string) teamsWithPrismaNameSetParam {

	return teamsWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r teamsQueryNameString) SetIfPresent(value *string) teamsWithPrismaNameSetParam {
	if value == nil {
		return teamsWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r teamsQueryNameString) Equals(value string) teamsWithPrismaNameEqualsParam {

	return teamsWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryNameString) EqualsIfPresent(value *string) teamsWithPrismaNameEqualsParam {
	if value == nil {
		return teamsWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r teamsQueryNameString) Order(direction SortOrder) teamsDefaultParam {
	return teamsDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r teamsQueryNameString) Cursor(cursor string) teamsCursorParam {
	return teamsCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r teamsQueryNameString) In(value []string) teamsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsQueryNameString) InIfPresent(value []string) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.In(value)
}

func (r teamsQueryNameString) NotIn(value []string) teamsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsQueryNameString) NotInIfPresent(value []string) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r teamsQueryNameString) Lt(value string) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryNameString) LtIfPresent(value *string) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r teamsQueryNameString) Lte(value string) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryNameString) LteIfPresent(value *string) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r teamsQueryNameString) Gt(value string) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryNameString) GtIfPresent(value *string) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r teamsQueryNameString) Gte(value string) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryNameString) GteIfPresent(value *string) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r teamsQueryNameString) Contains(value string) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryNameString) ContainsIfPresent(value *string) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r teamsQueryNameString) StartsWith(value string) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryNameString) StartsWithIfPresent(value *string) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r teamsQueryNameString) EndsWith(value string) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryNameString) EndsWithIfPresent(value *string) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r teamsQueryNameString) Mode(value QueryMode) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryNameString) ModeIfPresent(value *QueryMode) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r teamsQueryNameString) Not(value string) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryNameString) NotIfPresent(value *string) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r teamsQueryNameString) HasPrefix(value string) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r teamsQueryNameString) HasPrefixIfPresent(value *string) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r teamsQueryNameString) HasSuffix(value string) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r teamsQueryNameString) HasSuffixIfPresent(value *string) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type teamsQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r teamsQueryCreatedAtDateTime) Set(value DateTime) teamsSetParam {

	return teamsSetParam{
		data: builder.Field{
			Name:  "created_at",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r teamsQueryCreatedAtDateTime) SetIfPresent(value *DateTime) teamsSetParam {
	if value == nil {
		return teamsSetParam{}
	}

	return r.Set(*value)
}

func (r teamsQueryCreatedAtDateTime) Equals(value DateTime) teamsWithPrismaCreatedAtEqualsParam {

	return teamsWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) teamsWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return teamsWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r teamsQueryCreatedAtDateTime) Order(direction SortOrder) teamsDefaultParam {
	return teamsDefaultParam{
		data: builder.Field{
			Name:  "created_at",
			Value: direction,
		},
	}
}

func (r teamsQueryCreatedAtDateTime) Cursor(cursor DateTime) teamsCursorParam {
	return teamsCursorParam{
		data: builder.Field{
			Name:  "created_at",
			Value: cursor,
		},
	}
}

func (r teamsQueryCreatedAtDateTime) In(value []DateTime) teamsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsQueryCreatedAtDateTime) InIfPresent(value []DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.In(value)
}

func (r teamsQueryCreatedAtDateTime) NotIn(value []DateTime) teamsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r teamsQueryCreatedAtDateTime) Lt(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryCreatedAtDateTime) LtIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r teamsQueryCreatedAtDateTime) Lte(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryCreatedAtDateTime) LteIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r teamsQueryCreatedAtDateTime) Gt(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryCreatedAtDateTime) GtIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r teamsQueryCreatedAtDateTime) Gte(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryCreatedAtDateTime) GteIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r teamsQueryCreatedAtDateTime) Not(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryCreatedAtDateTime) NotIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r teamsQueryCreatedAtDateTime) Before(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r teamsQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r teamsQueryCreatedAtDateTime) After(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r teamsQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r teamsQueryCreatedAtDateTime) BeforeEquals(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r teamsQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r teamsQueryCreatedAtDateTime) AfterEquals(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r teamsQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type teamsQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r teamsQueryUpdatedAtDateTime) Set(value DateTime) teamsSetParam {

	return teamsSetParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r teamsQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) teamsSetParam {
	if value == nil {
		return teamsSetParam{}
	}

	return r.Set(*value)
}

func (r teamsQueryUpdatedAtDateTime) Equals(value DateTime) teamsWithPrismaUpdatedAtEqualsParam {

	return teamsWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) teamsWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return teamsWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r teamsQueryUpdatedAtDateTime) Order(direction SortOrder) teamsDefaultParam {
	return teamsDefaultParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: direction,
		},
	}
}

func (r teamsQueryUpdatedAtDateTime) Cursor(cursor DateTime) teamsCursorParam {
	return teamsCursorParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: cursor,
		},
	}
}

func (r teamsQueryUpdatedAtDateTime) In(value []DateTime) teamsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsQueryUpdatedAtDateTime) InIfPresent(value []DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.In(value)
}

func (r teamsQueryUpdatedAtDateTime) NotIn(value []DateTime) teamsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r teamsQueryUpdatedAtDateTime) Lt(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r teamsQueryUpdatedAtDateTime) Lte(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r teamsQueryUpdatedAtDateTime) Gt(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r teamsQueryUpdatedAtDateTime) Gte(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r teamsQueryUpdatedAtDateTime) Not(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r teamsQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r teamsQueryUpdatedAtDateTime) Before(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r teamsQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r teamsQueryUpdatedAtDateTime) After(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r teamsQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r teamsQueryUpdatedAtDateTime) BeforeEquals(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r teamsQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r teamsQueryUpdatedAtDateTime) AfterEquals(value DateTime) teamsDefaultParam {

	return teamsDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r teamsQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) teamsDefaultParam {
	if value == nil {
		return teamsDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type teamsQueryInvitationsinvitations struct{}

type teamsQueryInvitationsRelations struct{}

// Teams -> Invitations
//
// @relation
// @required
func (teamsQueryInvitationsRelations) Some(
	params ...InvitationsWhereParam,
) teamsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name: "invitations",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Teams -> Invitations
//
// @relation
// @required
func (teamsQueryInvitationsRelations) Every(
	params ...InvitationsWhereParam,
) teamsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name: "invitations",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (teamsQueryInvitationsRelations) Fetch(

	params ...InvitationsWhereParam,

) teamsToInvitationsFindMany {
	var v teamsToInvitationsFindMany

	v.query.Operation = "query"
	v.query.Method = "invitations"
	v.query.Outputs = invitationsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r teamsQueryInvitationsRelations) Link(
	params ...InvitationsWhereParam,
) teamsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsSetParam{
		data: builder.Field{
			Name: "invitations",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r teamsQueryInvitationsRelations) Unlink(
	params ...InvitationsWhereParam,
) teamsSetParam {
	var v teamsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = teamsSetParam{
		data: builder.Field{
			Name: "invitations",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type teamsQueryTeamsProjectsteams_projects struct{}

type teamsQueryTeamsProjectsRelations struct{}

// Teams -> TeamsProjects
//
// @relation
// @required
func (teamsQueryTeamsProjectsRelations) Some(
	params ...TeamsProjectsWhereParam,
) teamsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name: "teams_projects",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Teams -> TeamsProjects
//
// @relation
// @required
func (teamsQueryTeamsProjectsRelations) Every(
	params ...TeamsProjectsWhereParam,
) teamsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name: "teams_projects",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (teamsQueryTeamsProjectsRelations) Fetch(

	params ...TeamsProjectsWhereParam,

) teamsToTeamsProjectsFindMany {
	var v teamsToTeamsProjectsFindMany

	v.query.Operation = "query"
	v.query.Method = "teams_projects"
	v.query.Outputs = teamsProjectsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r teamsQueryTeamsProjectsRelations) Link(
	params ...TeamsProjectsWhereParam,
) teamsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsSetParam{
		data: builder.Field{
			Name: "teams_projects",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r teamsQueryTeamsProjectsRelations) Unlink(
	params ...TeamsProjectsWhereParam,
) teamsSetParam {
	var v teamsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = teamsSetParam{
		data: builder.Field{
			Name: "teams_projects",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type teamsQueryTeamsUsersteams_users struct{}

type teamsQueryTeamsUsersRelations struct{}

// Teams -> TeamsUsers
//
// @relation
// @required
func (teamsQueryTeamsUsersRelations) Some(
	params ...TeamsUsersWhereParam,
) teamsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name: "teams_users",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Teams -> TeamsUsers
//
// @relation
// @required
func (teamsQueryTeamsUsersRelations) Every(
	params ...TeamsUsersWhereParam,
) teamsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsDefaultParam{
		data: builder.Field{
			Name: "teams_users",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (teamsQueryTeamsUsersRelations) Fetch(

	params ...TeamsUsersWhereParam,

) teamsToTeamsUsersFindMany {
	var v teamsToTeamsUsersFindMany

	v.query.Operation = "query"
	v.query.Method = "teams_users"
	v.query.Outputs = teamsUsersOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r teamsQueryTeamsUsersRelations) Link(
	params ...TeamsUsersWhereParam,
) teamsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsSetParam{
		data: builder.Field{
			Name: "teams_users",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r teamsQueryTeamsUsersRelations) Unlink(
	params ...TeamsUsersWhereParam,
) teamsSetParam {
	var v teamsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = teamsSetParam{
		data: builder.Field{
			Name: "teams_users",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// TeamsProjects acts as a namespaces to access query methods for the TeamsProjects model
var TeamsProjects = teamsProjectsQuery{}

// teamsProjectsQuery exposes query functions for the teamsProjects model
type teamsProjectsQuery struct {

	// ProjectID
	//
	// @required
	ProjectID teamsProjectsQueryProjectIDString

	// TeamID
	//
	// @required
	TeamID teamsProjectsQueryTeamIDString

	// CreatedAt
	//
	// @required
	CreatedAt teamsProjectsQueryCreatedAtDateTime

	Projects teamsProjectsQueryProjectsRelations

	Teams teamsProjectsQueryTeamsRelations
}

func (teamsProjectsQuery) Not(params ...TeamsProjectsWhereParam) teamsProjectsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (teamsProjectsQuery) Or(params ...TeamsProjectsWhereParam) teamsProjectsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (teamsProjectsQuery) And(params ...TeamsProjectsWhereParam) teamsProjectsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (teamsProjectsQuery) ProjectIDTeamID(
	_projectID TeamsProjectsWithPrismaProjectIDWhereParam,

	_teamID TeamsProjectsWithPrismaTeamIDWhereParam,
) TeamsProjectsEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _projectID.field())
	fields = append(fields, _teamID.field())

	return teamsProjectsEqualsUniqueParam{
		data: builder.Field{
			Name:   "project_id_team_id",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type teamsProjectsQueryProjectIDString struct{}

// Set the required value of ProjectID
func (r teamsProjectsQueryProjectIDString) Set(value string) teamsProjectsSetParam {

	return teamsProjectsSetParam{
		data: builder.Field{
			Name:  "project_id",
			Value: value,
		},
	}

}

// Set the optional value of ProjectID dynamically
func (r teamsProjectsQueryProjectIDString) SetIfPresent(value *string) teamsProjectsSetParam {
	if value == nil {
		return teamsProjectsSetParam{}
	}

	return r.Set(*value)
}

func (r teamsProjectsQueryProjectIDString) Equals(value string) teamsProjectsWithPrismaProjectIDEqualsParam {

	return teamsProjectsWithPrismaProjectIDEqualsParam{
		data: builder.Field{
			Name: "project_id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryProjectIDString) EqualsIfPresent(value *string) teamsProjectsWithPrismaProjectIDEqualsParam {
	if value == nil {
		return teamsProjectsWithPrismaProjectIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r teamsProjectsQueryProjectIDString) Order(direction SortOrder) teamsProjectsDefaultParam {
	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name:  "project_id",
			Value: direction,
		},
	}
}

func (r teamsProjectsQueryProjectIDString) Cursor(cursor string) teamsProjectsCursorParam {
	return teamsProjectsCursorParam{
		data: builder.Field{
			Name:  "project_id",
			Value: cursor,
		},
	}
}

func (r teamsProjectsQueryProjectIDString) In(value []string) teamsProjectsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "project_id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsProjectsQueryProjectIDString) InIfPresent(value []string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.In(value)
}

func (r teamsProjectsQueryProjectIDString) NotIn(value []string) teamsProjectsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "project_id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsProjectsQueryProjectIDString) NotInIfPresent(value []string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r teamsProjectsQueryProjectIDString) Lt(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "project_id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryProjectIDString) LtIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r teamsProjectsQueryProjectIDString) Lte(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "project_id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryProjectIDString) LteIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r teamsProjectsQueryProjectIDString) Gt(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "project_id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryProjectIDString) GtIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r teamsProjectsQueryProjectIDString) Gte(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "project_id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryProjectIDString) GteIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r teamsProjectsQueryProjectIDString) Contains(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "project_id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryProjectIDString) ContainsIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r teamsProjectsQueryProjectIDString) StartsWith(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "project_id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryProjectIDString) StartsWithIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r teamsProjectsQueryProjectIDString) EndsWith(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "project_id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryProjectIDString) EndsWithIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r teamsProjectsQueryProjectIDString) Mode(value QueryMode) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "project_id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryProjectIDString) ModeIfPresent(value *QueryMode) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r teamsProjectsQueryProjectIDString) Not(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "project_id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryProjectIDString) NotIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r teamsProjectsQueryProjectIDString) HasPrefix(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "project_id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r teamsProjectsQueryProjectIDString) HasPrefixIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r teamsProjectsQueryProjectIDString) HasSuffix(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "project_id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r teamsProjectsQueryProjectIDString) HasSuffixIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type teamsProjectsQueryTeamIDString struct{}

// Set the required value of TeamID
func (r teamsProjectsQueryTeamIDString) Set(value string) teamsProjectsSetParam {

	return teamsProjectsSetParam{
		data: builder.Field{
			Name:  "team_id",
			Value: value,
		},
	}

}

// Set the optional value of TeamID dynamically
func (r teamsProjectsQueryTeamIDString) SetIfPresent(value *string) teamsProjectsSetParam {
	if value == nil {
		return teamsProjectsSetParam{}
	}

	return r.Set(*value)
}

func (r teamsProjectsQueryTeamIDString) Equals(value string) teamsProjectsWithPrismaTeamIDEqualsParam {

	return teamsProjectsWithPrismaTeamIDEqualsParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryTeamIDString) EqualsIfPresent(value *string) teamsProjectsWithPrismaTeamIDEqualsParam {
	if value == nil {
		return teamsProjectsWithPrismaTeamIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r teamsProjectsQueryTeamIDString) Order(direction SortOrder) teamsProjectsDefaultParam {
	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name:  "team_id",
			Value: direction,
		},
	}
}

func (r teamsProjectsQueryTeamIDString) Cursor(cursor string) teamsProjectsCursorParam {
	return teamsProjectsCursorParam{
		data: builder.Field{
			Name:  "team_id",
			Value: cursor,
		},
	}
}

func (r teamsProjectsQueryTeamIDString) In(value []string) teamsProjectsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsProjectsQueryTeamIDString) InIfPresent(value []string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.In(value)
}

func (r teamsProjectsQueryTeamIDString) NotIn(value []string) teamsProjectsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsProjectsQueryTeamIDString) NotInIfPresent(value []string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r teamsProjectsQueryTeamIDString) Lt(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryTeamIDString) LtIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r teamsProjectsQueryTeamIDString) Lte(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryTeamIDString) LteIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r teamsProjectsQueryTeamIDString) Gt(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryTeamIDString) GtIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r teamsProjectsQueryTeamIDString) Gte(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryTeamIDString) GteIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r teamsProjectsQueryTeamIDString) Contains(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryTeamIDString) ContainsIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r teamsProjectsQueryTeamIDString) StartsWith(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryTeamIDString) StartsWithIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r teamsProjectsQueryTeamIDString) EndsWith(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryTeamIDString) EndsWithIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r teamsProjectsQueryTeamIDString) Mode(value QueryMode) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryTeamIDString) ModeIfPresent(value *QueryMode) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r teamsProjectsQueryTeamIDString) Not(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryTeamIDString) NotIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r teamsProjectsQueryTeamIDString) HasPrefix(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r teamsProjectsQueryTeamIDString) HasPrefixIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r teamsProjectsQueryTeamIDString) HasSuffix(value string) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r teamsProjectsQueryTeamIDString) HasSuffixIfPresent(value *string) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type teamsProjectsQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r teamsProjectsQueryCreatedAtDateTime) Set(value DateTime) teamsProjectsSetParam {

	return teamsProjectsSetParam{
		data: builder.Field{
			Name:  "created_at",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r teamsProjectsQueryCreatedAtDateTime) SetIfPresent(value *DateTime) teamsProjectsSetParam {
	if value == nil {
		return teamsProjectsSetParam{}
	}

	return r.Set(*value)
}

func (r teamsProjectsQueryCreatedAtDateTime) Equals(value DateTime) teamsProjectsWithPrismaCreatedAtEqualsParam {

	return teamsProjectsWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) teamsProjectsWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return teamsProjectsWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r teamsProjectsQueryCreatedAtDateTime) Order(direction SortOrder) teamsProjectsDefaultParam {
	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name:  "created_at",
			Value: direction,
		},
	}
}

func (r teamsProjectsQueryCreatedAtDateTime) Cursor(cursor DateTime) teamsProjectsCursorParam {
	return teamsProjectsCursorParam{
		data: builder.Field{
			Name:  "created_at",
			Value: cursor,
		},
	}
}

func (r teamsProjectsQueryCreatedAtDateTime) In(value []DateTime) teamsProjectsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsProjectsQueryCreatedAtDateTime) InIfPresent(value []DateTime) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.In(value)
}

func (r teamsProjectsQueryCreatedAtDateTime) NotIn(value []DateTime) teamsProjectsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsProjectsQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r teamsProjectsQueryCreatedAtDateTime) Lt(value DateTime) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryCreatedAtDateTime) LtIfPresent(value *DateTime) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r teamsProjectsQueryCreatedAtDateTime) Lte(value DateTime) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryCreatedAtDateTime) LteIfPresent(value *DateTime) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r teamsProjectsQueryCreatedAtDateTime) Gt(value DateTime) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryCreatedAtDateTime) GtIfPresent(value *DateTime) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r teamsProjectsQueryCreatedAtDateTime) Gte(value DateTime) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryCreatedAtDateTime) GteIfPresent(value *DateTime) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r teamsProjectsQueryCreatedAtDateTime) Not(value DateTime) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r teamsProjectsQueryCreatedAtDateTime) NotIfPresent(value *DateTime) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r teamsProjectsQueryCreatedAtDateTime) Before(value DateTime) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r teamsProjectsQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r teamsProjectsQueryCreatedAtDateTime) After(value DateTime) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r teamsProjectsQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r teamsProjectsQueryCreatedAtDateTime) BeforeEquals(value DateTime) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r teamsProjectsQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r teamsProjectsQueryCreatedAtDateTime) AfterEquals(value DateTime) teamsProjectsDefaultParam {

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r teamsProjectsQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) teamsProjectsDefaultParam {
	if value == nil {
		return teamsProjectsDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type teamsProjectsQueryProjectsprojects struct{}

type teamsProjectsQueryProjectsRelations struct{}

// TeamsProjects -> Projects
//
// @relation
// @required
func (teamsProjectsQueryProjectsRelations) Where(
	params ...ProjectsWhereParam,
) teamsProjectsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "projects",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (teamsProjectsQueryProjectsRelations) Fetch() teamsProjectsToProjectsFindUnique {
	var v teamsProjectsToProjectsFindUnique

	v.query.Operation = "query"
	v.query.Method = "projects"
	v.query.Outputs = projectsOutput

	return v
}

func (r teamsProjectsQueryProjectsRelations) Link(
	params ProjectsWhereParam,
) teamsProjectsWithPrismaProjectsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return teamsProjectsWithPrismaProjectsSetParam{}
	}

	fields = append(fields, f)

	return teamsProjectsWithPrismaProjectsSetParam{
		data: builder.Field{
			Name: "projects",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r teamsProjectsQueryProjectsRelations) Unlink() teamsProjectsWithPrismaProjectsSetParam {
	var v teamsProjectsWithPrismaProjectsSetParam

	v = teamsProjectsWithPrismaProjectsSetParam{
		data: builder.Field{
			Name: "projects",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type teamsProjectsQueryTeamsteams struct{}

type teamsProjectsQueryTeamsRelations struct{}

// TeamsProjects -> Teams
//
// @relation
// @required
func (teamsProjectsQueryTeamsRelations) Where(
	params ...TeamsWhereParam,
) teamsProjectsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsProjectsDefaultParam{
		data: builder.Field{
			Name: "teams",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (teamsProjectsQueryTeamsRelations) Fetch() teamsProjectsToTeamsFindUnique {
	var v teamsProjectsToTeamsFindUnique

	v.query.Operation = "query"
	v.query.Method = "teams"
	v.query.Outputs = teamsOutput

	return v
}

func (r teamsProjectsQueryTeamsRelations) Link(
	params TeamsWhereParam,
) teamsProjectsWithPrismaTeamsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return teamsProjectsWithPrismaTeamsSetParam{}
	}

	fields = append(fields, f)

	return teamsProjectsWithPrismaTeamsSetParam{
		data: builder.Field{
			Name: "teams",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r teamsProjectsQueryTeamsRelations) Unlink() teamsProjectsWithPrismaTeamsSetParam {
	var v teamsProjectsWithPrismaTeamsSetParam

	v = teamsProjectsWithPrismaTeamsSetParam{
		data: builder.Field{
			Name: "teams",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// TeamsUsers acts as a namespaces to access query methods for the TeamsUsers model
var TeamsUsers = teamsUsersQuery{}

// teamsUsersQuery exposes query functions for the teamsUsers model
type teamsUsersQuery struct {

	// TeamID
	//
	// @required
	TeamID teamsUsersQueryTeamIDString

	// UserID
	//
	// @required
	UserID teamsUsersQueryUserIDString

	// CreatedAt
	//
	// @required
	CreatedAt teamsUsersQueryCreatedAtDateTime

	Teams teamsUsersQueryTeamsRelations

	Users teamsUsersQueryUsersRelations
}

func (teamsUsersQuery) Not(params ...TeamsUsersWhereParam) teamsUsersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (teamsUsersQuery) Or(params ...TeamsUsersWhereParam) teamsUsersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (teamsUsersQuery) And(params ...TeamsUsersWhereParam) teamsUsersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (teamsUsersQuery) TeamIDUserID(
	_teamID TeamsUsersWithPrismaTeamIDWhereParam,

	_userID TeamsUsersWithPrismaUserIDWhereParam,
) TeamsUsersEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _teamID.field())
	fields = append(fields, _userID.field())

	return teamsUsersEqualsUniqueParam{
		data: builder.Field{
			Name:   "team_id_user_id",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type teamsUsersQueryTeamIDString struct{}

// Set the required value of TeamID
func (r teamsUsersQueryTeamIDString) Set(value string) teamsUsersSetParam {

	return teamsUsersSetParam{
		data: builder.Field{
			Name:  "team_id",
			Value: value,
		},
	}

}

// Set the optional value of TeamID dynamically
func (r teamsUsersQueryTeamIDString) SetIfPresent(value *string) teamsUsersSetParam {
	if value == nil {
		return teamsUsersSetParam{}
	}

	return r.Set(*value)
}

func (r teamsUsersQueryTeamIDString) Equals(value string) teamsUsersWithPrismaTeamIDEqualsParam {

	return teamsUsersWithPrismaTeamIDEqualsParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryTeamIDString) EqualsIfPresent(value *string) teamsUsersWithPrismaTeamIDEqualsParam {
	if value == nil {
		return teamsUsersWithPrismaTeamIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r teamsUsersQueryTeamIDString) Order(direction SortOrder) teamsUsersDefaultParam {
	return teamsUsersDefaultParam{
		data: builder.Field{
			Name:  "team_id",
			Value: direction,
		},
	}
}

func (r teamsUsersQueryTeamIDString) Cursor(cursor string) teamsUsersCursorParam {
	return teamsUsersCursorParam{
		data: builder.Field{
			Name:  "team_id",
			Value: cursor,
		},
	}
}

func (r teamsUsersQueryTeamIDString) In(value []string) teamsUsersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsUsersQueryTeamIDString) InIfPresent(value []string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.In(value)
}

func (r teamsUsersQueryTeamIDString) NotIn(value []string) teamsUsersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsUsersQueryTeamIDString) NotInIfPresent(value []string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r teamsUsersQueryTeamIDString) Lt(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryTeamIDString) LtIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r teamsUsersQueryTeamIDString) Lte(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryTeamIDString) LteIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r teamsUsersQueryTeamIDString) Gt(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryTeamIDString) GtIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r teamsUsersQueryTeamIDString) Gte(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryTeamIDString) GteIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r teamsUsersQueryTeamIDString) Contains(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryTeamIDString) ContainsIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r teamsUsersQueryTeamIDString) StartsWith(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryTeamIDString) StartsWithIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r teamsUsersQueryTeamIDString) EndsWith(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryTeamIDString) EndsWithIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r teamsUsersQueryTeamIDString) Mode(value QueryMode) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryTeamIDString) ModeIfPresent(value *QueryMode) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r teamsUsersQueryTeamIDString) Not(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryTeamIDString) NotIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r teamsUsersQueryTeamIDString) HasPrefix(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r teamsUsersQueryTeamIDString) HasPrefixIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r teamsUsersQueryTeamIDString) HasSuffix(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "team_id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r teamsUsersQueryTeamIDString) HasSuffixIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type teamsUsersQueryUserIDString struct{}

// Set the required value of UserID
func (r teamsUsersQueryUserIDString) Set(value string) teamsUsersSetParam {

	return teamsUsersSetParam{
		data: builder.Field{
			Name:  "user_id",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r teamsUsersQueryUserIDString) SetIfPresent(value *string) teamsUsersSetParam {
	if value == nil {
		return teamsUsersSetParam{}
	}

	return r.Set(*value)
}

func (r teamsUsersQueryUserIDString) Equals(value string) teamsUsersWithPrismaUserIDEqualsParam {

	return teamsUsersWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryUserIDString) EqualsIfPresent(value *string) teamsUsersWithPrismaUserIDEqualsParam {
	if value == nil {
		return teamsUsersWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r teamsUsersQueryUserIDString) Order(direction SortOrder) teamsUsersDefaultParam {
	return teamsUsersDefaultParam{
		data: builder.Field{
			Name:  "user_id",
			Value: direction,
		},
	}
}

func (r teamsUsersQueryUserIDString) Cursor(cursor string) teamsUsersCursorParam {
	return teamsUsersCursorParam{
		data: builder.Field{
			Name:  "user_id",
			Value: cursor,
		},
	}
}

func (r teamsUsersQueryUserIDString) In(value []string) teamsUsersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsUsersQueryUserIDString) InIfPresent(value []string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.In(value)
}

func (r teamsUsersQueryUserIDString) NotIn(value []string) teamsUsersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsUsersQueryUserIDString) NotInIfPresent(value []string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r teamsUsersQueryUserIDString) Lt(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryUserIDString) LtIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r teamsUsersQueryUserIDString) Lte(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryUserIDString) LteIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r teamsUsersQueryUserIDString) Gt(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryUserIDString) GtIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r teamsUsersQueryUserIDString) Gte(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryUserIDString) GteIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r teamsUsersQueryUserIDString) Contains(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryUserIDString) ContainsIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r teamsUsersQueryUserIDString) StartsWith(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryUserIDString) StartsWithIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r teamsUsersQueryUserIDString) EndsWith(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryUserIDString) EndsWithIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r teamsUsersQueryUserIDString) Mode(value QueryMode) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryUserIDString) ModeIfPresent(value *QueryMode) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r teamsUsersQueryUserIDString) Not(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryUserIDString) NotIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r teamsUsersQueryUserIDString) HasPrefix(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r teamsUsersQueryUserIDString) HasPrefixIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r teamsUsersQueryUserIDString) HasSuffix(value string) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "user_id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r teamsUsersQueryUserIDString) HasSuffixIfPresent(value *string) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type teamsUsersQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r teamsUsersQueryCreatedAtDateTime) Set(value DateTime) teamsUsersSetParam {

	return teamsUsersSetParam{
		data: builder.Field{
			Name:  "created_at",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r teamsUsersQueryCreatedAtDateTime) SetIfPresent(value *DateTime) teamsUsersSetParam {
	if value == nil {
		return teamsUsersSetParam{}
	}

	return r.Set(*value)
}

func (r teamsUsersQueryCreatedAtDateTime) Equals(value DateTime) teamsUsersWithPrismaCreatedAtEqualsParam {

	return teamsUsersWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) teamsUsersWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return teamsUsersWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r teamsUsersQueryCreatedAtDateTime) Order(direction SortOrder) teamsUsersDefaultParam {
	return teamsUsersDefaultParam{
		data: builder.Field{
			Name:  "created_at",
			Value: direction,
		},
	}
}

func (r teamsUsersQueryCreatedAtDateTime) Cursor(cursor DateTime) teamsUsersCursorParam {
	return teamsUsersCursorParam{
		data: builder.Field{
			Name:  "created_at",
			Value: cursor,
		},
	}
}

func (r teamsUsersQueryCreatedAtDateTime) In(value []DateTime) teamsUsersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsUsersQueryCreatedAtDateTime) InIfPresent(value []DateTime) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.In(value)
}

func (r teamsUsersQueryCreatedAtDateTime) NotIn(value []DateTime) teamsUsersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r teamsUsersQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r teamsUsersQueryCreatedAtDateTime) Lt(value DateTime) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryCreatedAtDateTime) LtIfPresent(value *DateTime) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r teamsUsersQueryCreatedAtDateTime) Lte(value DateTime) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryCreatedAtDateTime) LteIfPresent(value *DateTime) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r teamsUsersQueryCreatedAtDateTime) Gt(value DateTime) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryCreatedAtDateTime) GtIfPresent(value *DateTime) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r teamsUsersQueryCreatedAtDateTime) Gte(value DateTime) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryCreatedAtDateTime) GteIfPresent(value *DateTime) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r teamsUsersQueryCreatedAtDateTime) Not(value DateTime) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r teamsUsersQueryCreatedAtDateTime) NotIfPresent(value *DateTime) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r teamsUsersQueryCreatedAtDateTime) Before(value DateTime) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r teamsUsersQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r teamsUsersQueryCreatedAtDateTime) After(value DateTime) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r teamsUsersQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r teamsUsersQueryCreatedAtDateTime) BeforeEquals(value DateTime) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r teamsUsersQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r teamsUsersQueryCreatedAtDateTime) AfterEquals(value DateTime) teamsUsersDefaultParam {

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r teamsUsersQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) teamsUsersDefaultParam {
	if value == nil {
		return teamsUsersDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type teamsUsersQueryTeamsteams struct{}

type teamsUsersQueryTeamsRelations struct{}

// TeamsUsers -> Teams
//
// @relation
// @required
func (teamsUsersQueryTeamsRelations) Where(
	params ...TeamsWhereParam,
) teamsUsersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "teams",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (teamsUsersQueryTeamsRelations) Fetch() teamsUsersToTeamsFindUnique {
	var v teamsUsersToTeamsFindUnique

	v.query.Operation = "query"
	v.query.Method = "teams"
	v.query.Outputs = teamsOutput

	return v
}

func (r teamsUsersQueryTeamsRelations) Link(
	params TeamsWhereParam,
) teamsUsersWithPrismaTeamsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return teamsUsersWithPrismaTeamsSetParam{}
	}

	fields = append(fields, f)

	return teamsUsersWithPrismaTeamsSetParam{
		data: builder.Field{
			Name: "teams",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r teamsUsersQueryTeamsRelations) Unlink() teamsUsersWithPrismaTeamsSetParam {
	var v teamsUsersWithPrismaTeamsSetParam

	v = teamsUsersWithPrismaTeamsSetParam{
		data: builder.Field{
			Name: "teams",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type teamsUsersQueryUsersusers struct{}

type teamsUsersQueryUsersRelations struct{}

// TeamsUsers -> Users
//
// @relation
// @required
func (teamsUsersQueryUsersRelations) Where(
	params ...UsersWhereParam,
) teamsUsersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return teamsUsersDefaultParam{
		data: builder.Field{
			Name: "users",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (teamsUsersQueryUsersRelations) Fetch() teamsUsersToUsersFindUnique {
	var v teamsUsersToUsersFindUnique

	v.query.Operation = "query"
	v.query.Method = "users"
	v.query.Outputs = usersOutput

	return v
}

func (r teamsUsersQueryUsersRelations) Link(
	params UsersWhereParam,
) teamsUsersWithPrismaUsersSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return teamsUsersWithPrismaUsersSetParam{}
	}

	fields = append(fields, f)

	return teamsUsersWithPrismaUsersSetParam{
		data: builder.Field{
			Name: "users",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r teamsUsersQueryUsersRelations) Unlink() teamsUsersWithPrismaUsersSetParam {
	var v teamsUsersWithPrismaUsersSetParam

	v = teamsUsersWithPrismaUsersSetParam{
		data: builder.Field{
			Name: "users",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// --- template upsert.gotpl ---

type contactFormSubmissionsUpsertOne struct {
	query builder.Query
}

func (r contactFormSubmissionsUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r contactFormSubmissionsUpsertOne) with()                           {}
func (r contactFormSubmissionsUpsertOne) contactFormSubmissionsModel()    {}
func (r contactFormSubmissionsUpsertOne) contactFormSubmissionsRelation() {}

func (r contactFormSubmissionsActions) UpsertOne(
	params ContactFormSubmissionsEqualsUniqueWhereParam,
) contactFormSubmissionsUpsertOne {
	var v contactFormSubmissionsUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "contact_form_submissions"
	v.query.Outputs = contactFormSubmissionsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r contactFormSubmissionsUpsertOne) Create(

	_email ContactFormSubmissionsWithPrismaEmailSetParam,
	_message ContactFormSubmissionsWithPrismaMessageSetParam,

	optional ...ContactFormSubmissionsSetParam,
) contactFormSubmissionsUpsertOne {
	var v contactFormSubmissionsUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _email.field())
	fields = append(fields, _message.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r contactFormSubmissionsUpsertOne) Update(
	params ...ContactFormSubmissionsSetParam,
) contactFormSubmissionsUpsertOne {
	var v contactFormSubmissionsUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r contactFormSubmissionsUpsertOne) Exec(ctx context.Context) (*ContactFormSubmissionsModel, error) {
	var v ContactFormSubmissionsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r contactFormSubmissionsUpsertOne) Tx() contactFormSubmissionsUniqueTxResult {
	v := NewcontactFormSubmissionsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersUpsertOne struct {
	query builder.Query
}

func (r usersUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r usersUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r usersUpsertOne) with()          {}
func (r usersUpsertOne) usersModel()    {}
func (r usersUpsertOne) usersRelation() {}

func (r usersActions) UpsertOne(
	params UsersEqualsUniqueWhereParam,
) usersUpsertOne {
	var v usersUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "users"
	v.query.Outputs = usersOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r usersUpsertOne) Create(

	_email UsersWithPrismaEmailSetParam,
	_hashedPassword UsersWithPrismaHashedPasswordSetParam,

	optional ...UsersSetParam,
) usersUpsertOne {
	var v usersUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _email.field())
	fields = append(fields, _hashedPassword.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r usersUpsertOne) Update(
	params ...UsersSetParam,
) usersUpsertOne {
	var v usersUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r usersUpsertOne) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersUpsertOne) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type invitationsUpsertOne struct {
	query builder.Query
}

func (r invitationsUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r invitationsUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r invitationsUpsertOne) with()                {}
func (r invitationsUpsertOne) invitationsModel()    {}
func (r invitationsUpsertOne) invitationsRelation() {}

func (r invitationsActions) UpsertOne(
	params InvitationsEqualsUniqueWhereParam,
) invitationsUpsertOne {
	var v invitationsUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "invitations"
	v.query.Outputs = invitationsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r invitationsUpsertOne) Create(

	_email InvitationsWithPrismaEmailSetParam,
	_teams InvitationsWithPrismaTeamsSetParam,

	optional ...InvitationsSetParam,
) invitationsUpsertOne {
	var v invitationsUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _email.field())
	fields = append(fields, _teams.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r invitationsUpsertOne) Update(
	params ...InvitationsSetParam,
) invitationsUpsertOne {
	var v invitationsUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r invitationsUpsertOne) Exec(ctx context.Context) (*InvitationsModel, error) {
	var v InvitationsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r invitationsUpsertOne) Tx() invitationsUniqueTxResult {
	v := NewinvitationsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type projectsUpsertOne struct {
	query builder.Query
}

func (r projectsUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r projectsUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r projectsUpsertOne) with()             {}
func (r projectsUpsertOne) projectsModel()    {}
func (r projectsUpsertOne) projectsRelation() {}

func (r projectsActions) UpsertOne(
	params ProjectsEqualsUniqueWhereParam,
) projectsUpsertOne {
	var v projectsUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "projects"
	v.query.Outputs = projectsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r projectsUpsertOne) Create(

	_name ProjectsWithPrismaNameSetParam,

	optional ...ProjectsSetParam,
) projectsUpsertOne {
	var v projectsUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r projectsUpsertOne) Update(
	params ...ProjectsSetParam,
) projectsUpsertOne {
	var v projectsUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r projectsUpsertOne) Exec(ctx context.Context) (*ProjectsModel, error) {
	var v ProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r projectsUpsertOne) Tx() projectsUniqueTxResult {
	v := NewprojectsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsUpsertOne struct {
	query builder.Query
}

func (r teamsUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r teamsUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUpsertOne) with()          {}
func (r teamsUpsertOne) teamsModel()    {}
func (r teamsUpsertOne) teamsRelation() {}

func (r teamsActions) UpsertOne(
	params TeamsEqualsUniqueWhereParam,
) teamsUpsertOne {
	var v teamsUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "teams"
	v.query.Outputs = teamsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r teamsUpsertOne) Create(

	_name TeamsWithPrismaNameSetParam,

	optional ...TeamsSetParam,
) teamsUpsertOne {
	var v teamsUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r teamsUpsertOne) Update(
	params ...TeamsSetParam,
) teamsUpsertOne {
	var v teamsUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r teamsUpsertOne) Exec(ctx context.Context) (*TeamsModel, error) {
	var v TeamsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUpsertOne) Tx() teamsUniqueTxResult {
	v := NewteamsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsProjectsUpsertOne struct {
	query builder.Query
}

func (r teamsProjectsUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r teamsProjectsUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsProjectsUpsertOne) with()                  {}
func (r teamsProjectsUpsertOne) teamsProjectsModel()    {}
func (r teamsProjectsUpsertOne) teamsProjectsRelation() {}

func (r teamsProjectsActions) UpsertOne(
	params TeamsProjectsEqualsUniqueWhereParam,
) teamsProjectsUpsertOne {
	var v teamsProjectsUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "teams_projects"
	v.query.Outputs = teamsProjectsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r teamsProjectsUpsertOne) Create(

	_projects TeamsProjectsWithPrismaProjectsSetParam,
	_teams TeamsProjectsWithPrismaTeamsSetParam,

	optional ...TeamsProjectsSetParam,
) teamsProjectsUpsertOne {
	var v teamsProjectsUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _projects.field())
	fields = append(fields, _teams.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r teamsProjectsUpsertOne) Update(
	params ...TeamsProjectsSetParam,
) teamsProjectsUpsertOne {
	var v teamsProjectsUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r teamsProjectsUpsertOne) Exec(ctx context.Context) (*TeamsProjectsModel, error) {
	var v TeamsProjectsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsProjectsUpsertOne) Tx() teamsProjectsUniqueTxResult {
	v := NewteamsProjectsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type teamsUsersUpsertOne struct {
	query builder.Query
}

func (r teamsUsersUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r teamsUsersUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r teamsUsersUpsertOne) with()               {}
func (r teamsUsersUpsertOne) teamsUsersModel()    {}
func (r teamsUsersUpsertOne) teamsUsersRelation() {}

func (r teamsUsersActions) UpsertOne(
	params TeamsUsersEqualsUniqueWhereParam,
) teamsUsersUpsertOne {
	var v teamsUsersUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "teams_users"
	v.query.Outputs = teamsUsersOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r teamsUsersUpsertOne) Create(

	_teams TeamsUsersWithPrismaTeamsSetParam,
	_users TeamsUsersWithPrismaUsersSetParam,

	optional ...TeamsUsersSetParam,
) teamsUsersUpsertOne {
	var v teamsUsersUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _teams.field())
	fields = append(fields, _users.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r teamsUsersUpsertOne) Update(
	params ...TeamsUsersSetParam,
) teamsUsersUpsertOne {
	var v teamsUsersUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r teamsUsersUpsertOne) Exec(ctx context.Context) (*TeamsUsersModel, error) {
	var v TeamsUsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r teamsUsersUpsertOne) Tx() teamsUsersUniqueTxResult {
	v := NewteamsUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}
